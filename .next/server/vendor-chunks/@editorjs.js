"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@editorjs";
exports.ids = ["vendor-chunks/@editorjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@editorjs/editorjs/dist/editorjs.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Aa)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-hint--align-start{text-align:left}.ce-hint--align-center{text-align:center}.ce-hint__description{opacity:.6;margin-top:3px}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nvar Ce = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Ke(n) {\n  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, \"default\") ? n.default : n;\n}\nfunction Xn(n) {\n  if (n.__esModule)\n    return n;\n  var e = n.default;\n  if (typeof e == \"function\") {\n    var t = function o() {\n      return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);\n    };\n    t.prototype = e.prototype;\n  } else\n    t = {};\n  return Object.defineProperty(t, \"__esModule\", { value: !0 }), Object.keys(n).forEach(function(o) {\n    var i = Object.getOwnPropertyDescriptor(n, o);\n    Object.defineProperty(t, o, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return n[o];\n      }\n    });\n  }), t;\n}\nfunction ot() {\n}\nObject.assign(ot, {\n  default: ot,\n  register: ot,\n  revert: function() {\n  },\n  __esModule: !0\n});\nElement.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(n) {\n  const e = (this.document || this.ownerDocument).querySelectorAll(n);\n  let t = e.length;\n  for (; --t >= 0 && e.item(t) !== this; )\n    ;\n  return t > -1;\n});\nElement.prototype.closest || (Element.prototype.closest = function(n) {\n  let e = this;\n  if (!document.documentElement.contains(e))\n    return null;\n  do {\n    if (e.matches(n))\n      return e;\n    e = e.parentElement || e.parentNode;\n  } while (e !== null);\n  return null;\n});\nElement.prototype.prepend || (Element.prototype.prepend = function(e) {\n  const t = document.createDocumentFragment();\n  Array.isArray(e) || (e = [e]), e.forEach((o) => {\n    const i = o instanceof Node;\n    t.appendChild(i ? o : document.createTextNode(o));\n  }), this.insertBefore(t, this.firstChild);\n});\nElement.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(n) {\n  n = arguments.length === 0 ? !0 : !!n;\n  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue(\"border-top-width\")), i = parseInt(t.getPropertyValue(\"border-left-width\")), s = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = s && !r;\n  (s || r) && n && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && n && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (s || r || a || l) && !n && this.scrollIntoView(c);\n});\nwindow.requestIdleCallback = window.requestIdleCallback || function(n) {\n  const e = Date.now();\n  return setTimeout(function() {\n    n({\n      didTimeout: !1,\n      timeRemaining: function() {\n        return Math.max(0, 50 - (Date.now() - e));\n      }\n    });\n  }, 1);\n};\nwindow.cancelIdleCallback = window.cancelIdleCallback || function(n) {\n  clearTimeout(n);\n};\nlet Vn = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += \"-\" : e += \"_\", e), \"\");\nvar Lo = /* @__PURE__ */ ((n) => (n.VERBOSE = \"VERBOSE\", n.INFO = \"INFO\", n.WARN = \"WARN\", n.ERROR = \"ERROR\", n))(Lo || {});\nconst y = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, qn = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nfunction Ie(n, e, t = \"log\", o, i = \"color: inherit\") {\n  if (!(\"console\" in window) || !window.console[t])\n    return;\n  const s = [\"info\", \"log\", \"warn\", \"error\"].includes(t), r = [];\n  switch (Ie.logLevel) {\n    case \"ERROR\":\n      if (t !== \"error\")\n        return;\n      break;\n    case \"WARN\":\n      if (![\"error\", \"warn\"].includes(t))\n        return;\n      break;\n    case \"INFO\":\n      if (!s || n)\n        return;\n      break;\n  }\n  o && r.push(o);\n  const a = \"Editor.js 2.31.0-rc.7\", l = `line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;`;\n  n && (s ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);\n  try {\n    s ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);\n  } catch {\n  }\n}\nIe.logLevel = \"VERBOSE\";\nfunction Zn(n) {\n  Ie.logLevel = n;\n}\nconst S = Ie.bind(window, !1), X = Ie.bind(window, !0);\nfunction le(n) {\n  return Object.prototype.toString.call(n).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction A(n) {\n  return le(n) === \"function\" || le(n) === \"asyncfunction\";\n}\nfunction D(n) {\n  return le(n) === \"object\";\n}\nfunction te(n) {\n  return le(n) === \"string\";\n}\nfunction Gn(n) {\n  return le(n) === \"boolean\";\n}\nfunction yo(n) {\n  return le(n) === \"number\";\n}\nfunction wo(n) {\n  return le(n) === \"undefined\";\n}\nfunction V(n) {\n  return n ? Object.keys(n).length === 0 && n.constructor === Object : !0;\n}\nfunction Po(n) {\n  return n > 47 && n < 58 || // number keys\n  n === 32 || n === 13 || // Space bar & return key(s)\n  n === 229 || // processing key input for certain languages — Chinese, Japanese, etc.\n  n > 64 && n < 91 || // letter keys\n  n > 95 && n < 112 || // Numpad keys\n  n > 185 && n < 193 || // ;=,-./` (in order)\n  n > 218 && n < 223;\n}\nasync function Qn(n, e = () => {\n}, t = () => {\n}) {\n  async function o(i, s, r) {\n    try {\n      await i.function(i.data), await s(wo(i.data) ? {} : i.data);\n    } catch {\n      r(wo(i.data) ? {} : i.data);\n    }\n  }\n  return n.reduce(async (i, s) => (await i, o(s, e, t)), Promise.resolve());\n}\nfunction No(n) {\n  return Array.prototype.slice.call(n);\n}\nfunction Fe(n, e) {\n  return function() {\n    const t = this, o = arguments;\n    window.setTimeout(() => n.apply(t, o), e);\n  };\n}\nfunction Jn(n) {\n  return n.name.split(\".\").pop();\n}\nfunction ei(n) {\n  return /^[-\\w]+\\/([-+\\w]+|\\*)$/.test(n);\n}\nfunction Eo(n, e, t) {\n  let o;\n  return (...i) => {\n    const s = this, r = () => {\n      o = null, t || n.apply(s, i);\n    }, a = t && !o;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);\n  };\n}\nfunction dt(n, e, t = void 0) {\n  let o, i, s, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r || (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !a && t.leading === !1 && (a = c);\n    const u = e - (c - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r || (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), s;\n  };\n}\nfunction ti() {\n  const n = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e && (n[e] = !0), n;\n}\nfunction je(n) {\n  return n[0].toUpperCase() + n.slice(1);\n}\nfunction ut(n, ...e) {\n  if (!e.length)\n    return n;\n  const t = e.shift();\n  if (D(n) && D(t))\n    for (const o in t)\n      D(t[o]) ? (n[o] || Object.assign(n, { [o]: {} }), ut(n[o], t[o])) : Object.assign(n, { [o]: t[o] });\n  return ut(n, ...e);\n}\nfunction vt(n) {\n  const e = ti();\n  return n = n.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \" + \"), e.mac ? n = n.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : n = n.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), n;\n}\nfunction oi(n) {\n  try {\n    return new URL(n).href;\n  } catch {\n  }\n  return n.substring(0, 2) === \"//\" ? window.location.protocol + n : window.location.origin + n;\n}\nfunction ni() {\n  return Vn(10);\n}\nfunction ii(n) {\n  window.open(n, \"_blank\");\n}\nfunction si(n = \"\") {\n  return `${n}${Math.floor(Math.random() * 1e8).toString(16)}`;\n}\nfunction ht(n, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  n && X(o, \"warn\");\n}\nfunction me(n, e, t) {\n  const o = t.value ? \"value\" : \"get\", i = t[o], s = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[s] === void 0 && (this[s] = i.apply(this, ...r)), this[s];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete n[s], r.apply(this, a);\n    };\n  }\n  return t;\n}\nconst Ro = 650;\nfunction be() {\n  return window.matchMedia(`(max-width: ${Ro}px)`).matches;\n}\nconst pt = typeof window < \"u\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction ri(n, e) {\n  const t = Array.isArray(n) || D(n), o = Array.isArray(e) || D(e);\n  return t || o ? JSON.stringify(n) === JSON.stringify(e) : n === e;\n}\nclass d {\n  /**\n   * Check if passed tag has no closed tag\n   *\n   * @param {HTMLElement} tag - element to check\n   * @returns {boolean}\n   */\n  static isSingleTag(e) {\n    return e.tagName && [\n      \"AREA\",\n      \"BASE\",\n      \"BR\",\n      \"COL\",\n      \"COMMAND\",\n      \"EMBED\",\n      \"HR\",\n      \"IMG\",\n      \"INPUT\",\n      \"KEYGEN\",\n      \"LINK\",\n      \"META\",\n      \"PARAM\",\n      \"SOURCE\",\n      \"TRACK\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Check if element is BR or WBR\n   *\n   * @param {HTMLElement} element - element to check\n   * @returns {boolean}\n   */\n  static isLineBreakTag(e) {\n    return e && e.tagName && [\n      \"BR\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Helper for making Elements with class name and attributes\n   *\n   * @param  {string} tagName - new Element tag name\n   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)\n   * @param  {object} [attributes] - any attributes\n   * @returns {HTMLElement}\n   */\n  static make(e, t = null, o = {}) {\n    const i = document.createElement(e);\n    if (Array.isArray(t)) {\n      const s = t.filter((r) => r !== void 0);\n      i.classList.add(...s);\n    } else\n      t && i.classList.add(t);\n    for (const s in o)\n      Object.prototype.hasOwnProperty.call(o, s) && (i[s] = o[s]);\n    return i;\n  }\n  /**\n   * Creates Text Node with the passed content\n   *\n   * @param {string} content - text content\n   * @returns {Text}\n   */\n  static text(e) {\n    return document.createTextNode(e);\n  }\n  /**\n   * Append one or several elements to the parent\n   *\n   * @param  {Element|DocumentFragment} parent - where to append\n   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list\n   */\n  static append(e, t) {\n    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);\n  }\n  /**\n   * Append element or a couple to the beginning of the parent elements\n   *\n   * @param {Element} parent - where to append\n   * @param {Element|Element[]} elements - element or elements list\n   */\n  static prepend(e, t) {\n    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);\n  }\n  /**\n   * Swap two elements in parent\n   *\n   * @param {HTMLElement} el1 - from\n   * @param {HTMLElement} el2 - to\n   * @deprecated\n   */\n  static swap(e, t) {\n    const o = document.createElement(\"div\"), i = e.parentNode;\n    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);\n  }\n  /**\n   * Selector Decorator\n   *\n   * Returns first match\n   *\n   * @param {Element} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {Element}\n   */\n  static find(e = document, t) {\n    return e.querySelector(t);\n  }\n  /**\n   * Get Element by Id\n   *\n   * @param {string} id - id to find\n   * @returns {HTMLElement | null}\n   */\n  static get(e) {\n    return document.getElementById(e);\n  }\n  /**\n   * Selector Decorator.\n   *\n   * Returns all matches\n   *\n   * @param {Element|Document} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {NodeList}\n   */\n  static findAll(e = document, t) {\n    return e.querySelectorAll(t);\n  }\n  /**\n   * Returns CSS selector for all text inputs\n   */\n  static get allInputsSelector() {\n    return \"[contenteditable=true], textarea, input:not([type]), \" + [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"].map((t) => `input[type=\"${t}\"]`).join(\", \");\n  }\n  /**\n   * Find all contenteditable, textarea and editable input elements passed holder contains\n   *\n   * @param holder - element where to find inputs\n   */\n  static findAllInputs(e) {\n    return No(e.querySelectorAll(d.allInputsSelector)).reduce((t, o) => d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Search for deepest node which is Leaf.\n   * Leaf is the vertex that doesn't have any child nodes\n   *\n   * @description Method recursively goes throw the all Node until it finds the Leaf\n   * @param {Node} node - root Node. From this vertex we start Deep-first search\n   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}\n   * @param {boolean} [atLast] - find last text node\n   * @returns - it can be text Node or Element Node, so that caret will able to work with it\n   *            Can return null if node is Document or DocumentFragment, or node is not attached to the DOM\n   */\n  static getDeepestNode(e, t = !1) {\n    const o = t ? \"lastChild\" : \"firstChild\", i = t ? \"previousSibling\" : \"nextSibling\";\n    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {\n      let s = e[o];\n      if (d.isSingleTag(s) && !d.isNativeInput(s) && !d.isLineBreakTag(s))\n        if (s[i])\n          s = s[i];\n        else if (s.parentNode[i])\n          s = s.parentNode[i];\n        else\n          return s.parentNode;\n      return this.getDeepestNode(s, t);\n    }\n    return e;\n  }\n  /**\n   * Check if object is DOM node\n   *\n   * @param {*} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isElement(e) {\n    return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Check if object is DocumentFragment node\n   *\n   * @param {object} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isFragment(e) {\n    return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Check if passed element is contenteditable\n   *\n   * @param {HTMLElement} element - html element to check\n   * @returns {boolean}\n   */\n  static isContentEditable(e) {\n    return e.contentEditable === \"true\";\n  }\n  /**\n   * Checks target if it is native input\n   *\n   * @param {*} target - HTML element or string\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isNativeInput(e) {\n    const t = [\n      \"INPUT\",\n      \"TEXTAREA\"\n    ];\n    return e && e.tagName ? t.includes(e.tagName) : !1;\n  }\n  /**\n   * Checks if we can set caret\n   *\n   * @param {HTMLElement} target - target to check\n   * @returns {boolean}\n   */\n  static canSetCaret(e) {\n    let t = !0;\n    if (d.isNativeInput(e))\n      switch (e.type) {\n        case \"file\":\n        case \"checkbox\":\n        case \"radio\":\n        case \"hidden\":\n        case \"submit\":\n        case \"button\":\n        case \"image\":\n        case \"reset\":\n          t = !1;\n          break;\n      }\n    else\n      t = d.isContentEditable(e);\n    return t;\n  }\n  /**\n   * Checks node if it is empty\n   *\n   * @description Method checks simple Node without any childs for emptiness\n   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean} true if it is empty\n   */\n  static isNodeEmpty(e, t) {\n    let o;\n    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace(\"​\", \"\"), t && (o = o.replace(new RegExp(t, \"g\"), \"\")), o.length === 0);\n  }\n  /**\n   * checks node if it is doesn't have any child nodes\n   *\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isLeaf(e) {\n    return e ? e.childNodes.length === 0 : !1;\n  }\n  /**\n   * breadth-first search (BFS)\n   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}\n   *\n   * @description Pushes to stack all DOM leafs and checks for emptiness\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean}\n   */\n  static isEmpty(e, t) {\n    const o = [e];\n    for (; o.length > 0; )\n      if (e = o.shift(), !!e) {\n        if (this.isLeaf(e) && !this.isNodeEmpty(e, t))\n          return !1;\n        e.childNodes && o.push(...Array.from(e.childNodes));\n      }\n    return !0;\n  }\n  /**\n   * Check if string contains html elements\n   *\n   * @param {string} str - string to check\n   * @returns {boolean}\n   */\n  static isHTMLString(e) {\n    const t = d.make(\"div\");\n    return t.innerHTML = e, t.childElementCount > 0;\n  }\n  /**\n   * Return length of node`s text content\n   *\n   * @param {Node} node - node with content\n   * @returns {number}\n   */\n  static getContentLength(e) {\n    return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;\n  }\n  /**\n   * Return array of names of block html elements\n   *\n   * @returns {string[]}\n   */\n  static get blockElements() {\n    return [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"blockquote\",\n      \"canvas\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"li\",\n      \"main\",\n      \"nav\",\n      \"noscript\",\n      \"ol\",\n      \"output\",\n      \"p\",\n      \"pre\",\n      \"ruby\",\n      \"section\",\n      \"table\",\n      \"tbody\",\n      \"thead\",\n      \"tr\",\n      \"tfoot\",\n      \"ul\",\n      \"video\"\n    ];\n  }\n  /**\n   * Check if passed content includes only inline elements\n   *\n   * @param {string|HTMLElement} data - element or html string\n   * @returns {boolean}\n   */\n  static containsOnlyInlineElements(e) {\n    let t;\n    te(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n    const o = (i) => !d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);\n    return Array.from(t.children).every(o);\n  }\n  /**\n   * Find and return all block elements in the passed parent (including subtree)\n   *\n   * @param {HTMLElement} parent - root element\n   * @returns {HTMLElement[]}\n   */\n  static getDeepestBlockElements(e) {\n    return d.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Helper for get holder from {string} or return HTMLElement\n   *\n   * @param {string | HTMLElement} element - holder's id or holder's HTML Element\n   * @returns {HTMLElement}\n   */\n  static getHolder(e) {\n    return te(e) ? document.getElementById(e) : e;\n  }\n  /**\n   * Returns true if element is anchor (is A tag)\n   *\n   * @param {Element} element - element to check\n   * @returns {boolean}\n   */\n  static isAnchor(e) {\n    return e.tagName.toLowerCase() === \"a\";\n  }\n  /**\n   * Return element's offset related to the document\n   *\n   * @todo handle case when editor initialized in scrollable popup\n   * @param el - element to compute offset\n   */\n  static offset(e) {\n    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, s = t.top + i, r = t.left + o;\n    return {\n      top: s,\n      left: r,\n      bottom: s + t.height,\n      right: r + t.width\n    };\n  }\n}\nfunction ai(n) {\n  return !/[^\\t\\n\\r ]/.test(n);\n}\nfunction li(n) {\n  const e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2;\n  return r + s + i + l + a;\n}\nfunction Do(n) {\n  n.dataset.empty = d.isEmpty(n) ? \"true\" : \"false\";\n}\nconst ci = {\n  blockTunes: {\n    toggler: {\n      \"Click to tune\": \"\",\n      \"or drag to move\": \"\"\n    }\n  },\n  inlineToolbar: {\n    converter: {\n      \"Convert to\": \"\"\n    }\n  },\n  toolbar: {\n    toolbox: {\n      Add: \"\"\n    }\n  },\n  popover: {\n    Filter: \"\",\n    \"Nothing found\": \"\",\n    \"Convert to\": \"\"\n  }\n}, di = {\n  Text: \"\",\n  Link: \"\",\n  Bold: \"\",\n  Italic: \"\"\n}, ui = {\n  link: {\n    \"Add a link\": \"\"\n  },\n  stub: {\n    \"The block can not be displayed correctly.\": \"\"\n  }\n}, hi = {\n  delete: {\n    Delete: \"\",\n    \"Click to delete\": \"\"\n  },\n  moveUp: {\n    \"Move up\": \"\"\n  },\n  moveDown: {\n    \"Move down\": \"\"\n  }\n}, Fo = {\n  ui: ci,\n  toolNames: di,\n  tools: ui,\n  blockTunes: hi\n}, jo = class he {\n  /**\n   * Type-safe translation for internal UI texts:\n   * Perform translation of the string by namespace and a key\n   *\n   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')\n   * @param internalNamespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static ui(e, t) {\n    return he._t(e, t);\n  }\n  /**\n   * Translate for external strings that is not presented in default dictionary.\n   * For example, for user-specified tool names\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static t(e, t) {\n    return he._t(e, t);\n  }\n  /**\n   * Adjust module for using external dictionary\n   *\n   * @param dictionary - new messages list to override default\n   */\n  static setDictionary(e) {\n    he.currentDictionary = e;\n  }\n  /**\n   * Perform translation both for internal and external namespaces\n   * If there is no translation found, returns passed key as a translated message\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static _t(e, t) {\n    const o = he.getNamespace(e);\n    return !o || !o[t] ? t : o[t];\n  }\n  /**\n   * Find messages section by namespace path\n   *\n   * @param namespace - path to section\n   */\n  static getNamespace(e) {\n    return e.split(\".\").reduce((o, i) => !o || !Object.keys(o).length ? {} : o[i], he.currentDictionary);\n  }\n};\njo.currentDictionary = Fo;\nlet z = jo;\nclass Ho extends Error {\n}\nclass Oe {\n  constructor() {\n    this.subscribers = {};\n  }\n  /**\n   * Subscribe any event on callback\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  on(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);\n  }\n  /**\n   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  once(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []);\n    const o = (i) => {\n      const s = t(i), r = this.subscribers[e].indexOf(o);\n      return r !== -1 && this.subscribers[e].splice(r, 1), s;\n    };\n    this.subscribers[e].push(o);\n  }\n  /**\n   * Emit callbacks with passed data\n   *\n   * @param eventName - event name\n   * @param data - subscribers get this data when they were fired\n   */\n  emit(e, t) {\n    V(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {\n      const s = i(o);\n      return s !== void 0 ? s : o;\n    }, t);\n  }\n  /**\n   * Unsubscribe callback from event\n   *\n   * @param eventName - event name\n   * @param callback - event handler\n   */\n  off(e, t) {\n    if (this.subscribers[e] === void 0) {\n      console.warn(`EventDispatcher .off(): there is no subscribers for event \"${e.toString()}\". Probably, .off() called before .on()`);\n      return;\n    }\n    for (let o = 0; o < this.subscribers[e].length; o++)\n      if (this.subscribers[e][o] === t) {\n        delete this.subscribers[e][o];\n        break;\n      }\n  }\n  /**\n   * Destroyer\n   * clears subscribers list\n   */\n  destroy() {\n    this.subscribers = {};\n  }\n}\nfunction J(n) {\n  Object.setPrototypeOf(this, {\n    /**\n     * Block id\n     *\n     * @returns {string}\n     */\n    get id() {\n      return n.id;\n    },\n    /**\n     * Tool name\n     *\n     * @returns {string}\n     */\n    get name() {\n      return n.name;\n    },\n    /**\n     * Tool config passed on Editor's initialization\n     *\n     * @returns {ToolConfig}\n     */\n    get config() {\n      return n.config;\n    },\n    /**\n     * .ce-block element, that wraps plugin contents\n     *\n     * @returns {HTMLElement}\n     */\n    get holder() {\n      return n.holder;\n    },\n    /**\n     * True if Block content is empty\n     *\n     * @returns {boolean}\n     */\n    get isEmpty() {\n      return n.isEmpty;\n    },\n    /**\n     * True if Block is selected with Cross-Block selection\n     *\n     * @returns {boolean}\n     */\n    get selected() {\n      return n.selected;\n    },\n    /**\n     * Set Block's stretch state\n     *\n     * @param {boolean} state — state to set\n     */\n    set stretched(t) {\n      n.stretched = t;\n    },\n    /**\n     * True if Block is stretched\n     *\n     * @returns {boolean}\n     */\n    get stretched() {\n      return n.stretched;\n    },\n    /**\n     * True if Block has inputs to be focused\n     */\n    get focusable() {\n      return n.focusable;\n    },\n    /**\n     * Call Tool method with errors handler under-the-hood\n     *\n     * @param {string} methodName - method to call\n     * @param {object} param - object with parameters\n     * @returns {unknown}\n     */\n    call(t, o) {\n      return n.call(t, o);\n    },\n    /**\n     * Save Block content\n     *\n     * @returns {Promise<void|SavedData>}\n     */\n    save() {\n      return n.save();\n    },\n    /**\n     * Validate Block data\n     *\n     * @param {BlockToolData} data - data to validate\n     * @returns {Promise<boolean>}\n     */\n    validate(t) {\n      return n.validate(t);\n    },\n    /**\n     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n     * Can be useful for block changes invisible for editor core.\n     */\n    dispatchChange() {\n      n.dispatchChange();\n    },\n    /**\n     * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n     * This method returns the entry that is related to the Block (depended on the Block data)\n     */\n    getActiveToolboxEntry() {\n      return n.getActiveToolboxEntry();\n    }\n  });\n}\nclass _e {\n  constructor() {\n    this.allListeners = [];\n  }\n  /**\n   * Assigns event listener on element and returns unique identifier\n   *\n   * @param {EventTarget} element - DOM element that needs to be listened\n   * @param {string} eventType - event type\n   * @param {Function} handler - method that will be fired on event\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  on(e, t, o, i = !1) {\n    const s = si(\"l\"), r = {\n      id: s,\n      element: e,\n      eventType: t,\n      handler: o,\n      options: i\n    };\n    if (!this.findOne(e, t, o))\n      return this.allListeners.push(r), e.addEventListener(t, o, i), s;\n  }\n  /**\n   * Removes event listener from element\n   *\n   * @param {EventTarget} element - DOM element that we removing listener\n   * @param {string} eventType - event type\n   * @param {Function} handler - remove handler, if element listens several handlers on the same event type\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  off(e, t, o, i) {\n    const s = this.findAll(e, t, o);\n    s.forEach((r, a) => {\n      const l = this.allListeners.indexOf(s[a]);\n      l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));\n    });\n  }\n  /**\n   * Removes listener by id\n   *\n   * @param {string} id - listener identifier\n   */\n  offById(e) {\n    const t = this.findById(e);\n    t && t.element.removeEventListener(t.eventType, t.handler, t.options);\n  }\n  /**\n   * Finds and returns first listener by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} [eventType] - event type\n   * @param {Function} [handler] - event handler\n   * @returns {ListenerData|null}\n   */\n  findOne(e, t, o) {\n    const i = this.findAll(e, t, o);\n    return i.length > 0 ? i[0] : null;\n  }\n  /**\n   * Return all stored listeners by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} eventType - event type\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]}\n   */\n  findAll(e, t, o) {\n    let i;\n    const s = e ? this.findByEventTarget(e) : [];\n    return e && t && o ? i = s.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = s.filter((r) => r.eventType === t) : i = s, i;\n  }\n  /**\n   * Removes all listeners\n   */\n  removeAll() {\n    this.allListeners.map((e) => {\n      e.element.removeEventListener(e.eventType, e.handler, e.options);\n    }), this.allListeners = [];\n  }\n  /**\n   * Module cleanup on destruction\n   */\n  destroy() {\n    this.removeAll();\n  }\n  /**\n   * Search method: looks for listener by passed element\n   *\n   * @param {EventTarget} element - searching element\n   * @returns {Array} listeners that found on element\n   */\n  findByEventTarget(e) {\n    return this.allListeners.filter((t) => {\n      if (t.element === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed event type\n   *\n   * @param {string} eventType - event type\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByType(e) {\n    return this.allListeners.filter((t) => {\n      if (t.eventType === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed handler\n   *\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByHandler(e) {\n    return this.allListeners.filter((t) => {\n      if (t.handler === e)\n        return t;\n    });\n  }\n  /**\n   * Returns listener data found by id\n   *\n   * @param {string} id - listener identifier\n   * @returns {ListenerData}\n   */\n  findById(e) {\n    return this.allListeners.find((t) => t.id === e);\n  }\n}\nclass E {\n  /**\n   * @class\n   * @param options - Module options\n   * @param options.config - Module config\n   * @param options.eventsDispatcher - Common event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    if (this.nodes = {}, this.listeners = new _e(), this.readOnlyMutableListeners = {\n      /**\n       * Assigns event listener on DOM element and pushes into special array that might be removed\n       *\n       * @param {EventTarget} element - DOM Element\n       * @param {string} eventType - Event name\n       * @param {Function} handler - Event handler\n       * @param {boolean|AddEventListenerOptions} options - Listening options\n       */\n      on: (o, i, s, r = !1) => {\n        this.mutableListenerIds.push(\n          this.listeners.on(o, i, s, r)\n        );\n      },\n      /**\n       * Clears all mutable listeners\n       */\n      clearAll: () => {\n        for (const o of this.mutableListenerIds)\n          this.listeners.offById(o);\n        this.mutableListenerIds = [];\n      }\n    }, this.mutableListenerIds = [], new.target === E)\n      throw new TypeError(\"Constructors for abstract class Module are not allowed.\");\n    this.config = e, this.eventsDispatcher = t;\n  }\n  /**\n   * Editor modules setter\n   *\n   * @param {EditorModules} Editor - Editor's Modules\n   */\n  set state(e) {\n    this.Editor = e;\n  }\n  /**\n   * Remove memorized nodes\n   */\n  removeAllNodes() {\n    for (const e in this.nodes) {\n      const t = this.nodes[e];\n      t instanceof HTMLElement && t.remove();\n    }\n  }\n  /**\n   * Returns true if current direction is RTL (Right-To-Left)\n   */\n  get isRtl() {\n    return this.config.i18n.direction === \"rtl\";\n  }\n}\nclass b {\n  constructor() {\n    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = \"backColor\", this.commandRemoveFormat = \"removeFormat\";\n  }\n  /**\n   * Editor styles\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  static get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorZone: \"codex-editor__redactor\"\n    };\n  }\n  /**\n   * Returns selected anchor\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}\n   *\n   * @returns {Node|null}\n   */\n  static get anchorNode() {\n    const e = window.getSelection();\n    return e ? e.anchorNode : null;\n  }\n  /**\n   * Returns selected anchor element\n   *\n   * @returns {Element|null}\n   */\n  static get anchorElement() {\n    const e = window.getSelection();\n    if (!e)\n      return null;\n    const t = e.anchorNode;\n    return t ? d.isElement(t) ? t : t.parentElement : null;\n  }\n  /**\n   * Returns selection offset according to the anchor node\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}\n   *\n   * @returns {number|null}\n   */\n  static get anchorOffset() {\n    const e = window.getSelection();\n    return e ? e.anchorOffset : null;\n  }\n  /**\n   * Is current selection range collapsed\n   *\n   * @returns {boolean|null}\n   */\n  static get isCollapsed() {\n    const e = window.getSelection();\n    return e ? e.isCollapsed : null;\n  }\n  /**\n   * Check current selection if it is at Editor's zone\n   *\n   * @returns {boolean}\n   */\n  static get isAtEditor() {\n    return this.isSelectionAtEditor(b.get());\n  }\n  /**\n   * Check if passed selection is at Editor's zone\n   *\n   * @param selection - Selection object to check\n   */\n  static isSelectionAtEditor(e) {\n    if (!e)\n      return !1;\n    let t = e.anchorNode || e.focusNode;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Check if passed range at Editor zone\n   *\n   * @param range - range to check\n   */\n  static isRangeAtEditor(e) {\n    if (!e)\n      return;\n    let t = e.startContainer;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Methods return boolean that true if selection exists on the page\n   */\n  static get isSelectionExists() {\n    return !!b.get().anchorNode;\n  }\n  /**\n   * Return first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    return this.getRangeFromSelection(this.get());\n  }\n  /**\n   * Returns range from passed Selection object\n   *\n   * @param selection - Selection object to get Range from\n   */\n  static getRangeFromSelection(e) {\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Calculates position and size of selected text\n   *\n   * @returns {DOMRect | ClientRect}\n   */\n  static get rect() {\n    let e = document.selection, t, o = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if (e && e.type !== \"Control\")\n      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;\n    if (!window.getSelection)\n      return S(\"Method window.getSelection is not supported\", \"warn\"), o;\n    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))\n      return S(\"Method SelectionUtils.rangeCount is not supported\", \"warn\"), o;\n    if (e.rangeCount === 0)\n      return o;\n    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {\n      const i = document.createElement(\"span\");\n      if (i.getBoundingClientRect) {\n        i.appendChild(document.createTextNode(\"​\")), t.insertNode(i), o = i.getBoundingClientRect();\n        const s = i.parentNode;\n        s.removeChild(i), s.normalize();\n      }\n    }\n    return o;\n  }\n  /**\n   * Returns selected text as String\n   *\n   * @returns {string}\n   */\n  static get text() {\n    return window.getSelection ? window.getSelection().toString() : \"\";\n  }\n  /**\n   * Returns window SelectionUtils\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}\n   *\n   * @returns {Selection}\n   */\n  static get() {\n    return window.getSelection();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param element - element where to set focus\n   * @param offset - offset of cursor\n   */\n  static setCursor(e, t = 0) {\n    const o = document.createRange(), i = window.getSelection();\n    return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());\n  }\n  /**\n   * Check if current range exists and belongs to container\n   *\n   * @param container - where range should be\n   */\n  static isRangeInsideContainer(e) {\n    const t = b.range;\n    return t === null ? !1 : e.contains(t.startContainer);\n  }\n  /**\n   * Adds fake cursor to the current range\n   */\n  static addFakeCursor() {\n    const e = b.range;\n    if (e === null)\n      return;\n    const t = d.make(\"span\", \"codex-editor__fake-cursor\");\n    t.dataset.mutationFree = \"true\", e.collapse(), e.insertNode(t);\n  }\n  /**\n   * Check if passed element contains a fake cursor\n   *\n   * @param el - where to check\n   */\n  static isFakeCursorInsideContainer(e) {\n    return d.find(e, \".codex-editor__fake-cursor\") !== null;\n  }\n  /**\n   * Removes fake cursor from a container\n   *\n   * @param container - container to look for\n   */\n  static removeFakeCursor(e = document.body) {\n    const t = d.find(e, \".codex-editor__fake-cursor\");\n    t && t.remove();\n  }\n  /**\n   * Removes fake background\n   */\n  removeFakeBackground() {\n    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));\n  }\n  /**\n   * Sets fake background\n   */\n  setFakeBackground() {\n    document.execCommand(this.commandBackground, !1, \"#a8d6ff\"), this.isFakeBackgroundEnabled = !0;\n  }\n  /**\n   * Save SelectionUtils's range\n   */\n  save() {\n    this.savedSelectionRange = b.range;\n  }\n  /**\n   * Restore saved SelectionUtils's range\n   */\n  restore() {\n    if (!this.savedSelectionRange)\n      return;\n    const e = window.getSelection();\n    e.removeAllRanges(), e.addRange(this.savedSelectionRange);\n  }\n  /**\n   * Clears saved selection\n   */\n  clearSaved() {\n    this.savedSelectionRange = null;\n  }\n  /**\n   * Collapse current selection\n   */\n  collapseToEnd() {\n    const e = window.getSelection(), t = document.createRange();\n    t.selectNodeContents(e.focusNode), t.collapse(!1), e.removeAllRanges(), e.addRange(t);\n  }\n  /**\n   * Looks ahead to find passed tag from current selection\n   *\n   * @param  {string} tagName       - tag to found\n   * @param  {string} [className]   - tag's class name\n   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t, o = 10) {\n    const i = window.getSelection();\n    let s = null;\n    return !i || !i.anchorNode || !i.focusNode ? null : ([\n      /** the Node in which the selection begins */\n      i.anchorNode,\n      /** the Node in which the selection ends */\n      i.focusNode\n    ].forEach((a) => {\n      let l = o;\n      for (; l > 0 && a.parentNode && !(a.tagName === e && (s = a, t && a.classList && !a.classList.contains(t) && (s = null), s)); )\n        a = a.parentNode, l--;\n    }), s);\n  }\n  /**\n   * Expands selection range to the passed parent node\n   *\n   * @param {HTMLElement} element - element which contents should be selected\n   */\n  expandToTag(e) {\n    const t = window.getSelection();\n    t.removeAllRanges();\n    const o = document.createRange();\n    o.selectNodeContents(e), t.addRange(o);\n  }\n}\nfunction pi(n, e) {\n  const { type: t, target: o, addedNodes: i, removedNodes: s } = n;\n  return n.type === \"attributes\" && n.attributeName === \"data-empty\" ? !1 : !!(e.contains(o) || t === \"childList\" && (Array.from(i).some((l) => l === e) || Array.from(s).some((l) => l === e)));\n}\nconst ft = \"redactor dom changed\", $o = \"block changed\", zo = \"fake cursor is about to be toggled\", Uo = \"fake cursor have been set\", Te = \"editor mobile layout toggled\";\nfunction gt(n, e) {\n  if (!n.conversionConfig)\n    return !1;\n  const t = n.conversionConfig[e];\n  return A(t) || te(t);\n}\nfunction He(n, e) {\n  return gt(n.tool, e);\n}\nfunction Wo(n, e) {\n  return Object.entries(n).some(([t, o]) => e[t] && ri(e[t], o));\n}\nasync function Yo(n, e) {\n  const o = (await n.save()).data, i = e.find((s) => s.name === n.name);\n  return i !== void 0 && !gt(i, \"export\") ? [] : e.reduce((s, r) => {\n    if (!gt(r, \"import\") || r.toolbox === void 0)\n      return s;\n    const a = r.toolbox.filter((l) => {\n      if (V(l) || l.icon === void 0)\n        return !1;\n      if (l.data !== void 0) {\n        if (Wo(l.data, o))\n          return !1;\n      } else if (r.name === n.name)\n        return !1;\n      return !0;\n    });\n    return s.push({\n      ...r,\n      toolbox: a\n    }), s;\n  }, []);\n}\nfunction xo(n, e) {\n  return n.mergeable ? n.name === e.name ? !0 : He(e, \"export\") && He(n, \"import\") : !1;\n}\nfunction fi(n, e) {\n  const t = e == null ? void 0 : e.export;\n  return A(t) ? t(n) : te(t) ? n[t] : (t !== void 0 && S(\"Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export.\"), \"\");\n}\nfunction Bo(n, e, t) {\n  const o = e == null ? void 0 : e.import;\n  return A(o) ? o(n, t) : te(o) ? {\n    [o]: n\n  } : (o !== void 0 && S(\"Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data.\"), {});\n}\nvar _ = /* @__PURE__ */ ((n) => (n.Default = \"default\", n.Separator = \"separator\", n.Html = \"html\", n))(_ || {}), ee = /* @__PURE__ */ ((n) => (n.APPEND_CALLBACK = \"appendCallback\", n.RENDERED = \"rendered\", n.MOVED = \"moved\", n.UPDATED = \"updated\", n.REMOVED = \"removed\", n.ON_PASTE = \"onPaste\", n))(ee || {});\nclass R extends Oe {\n  /**\n   * @param options - block constructor options\n   * @param [options.id] - block's id. Will be generated if omitted.\n   * @param options.data - Tool's initial data\n   * @param options.tool — block's tool\n   * @param options.api - Editor API module for pass it to the Block Tunes\n   * @param options.readOnly - Read-Only flag\n   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when \"virtual\" Block is created. See BlocksAPI@composeBlockData.\n   */\n  constructor({\n    id: e = ni(),\n    data: t,\n    tool: o,\n    readOnly: i,\n    tunesData: s\n  }, r) {\n    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {\n      this.dropInputsCache(), this.updateCurrentInput();\n    }, this.didMutated = (a = void 0) => {\n      const l = a === void 0, c = a instanceof InputEvent;\n      !l && !c && this.detectToolRootChange(a);\n      let u;\n      l || c ? u = !0 : u = !(a.length > 0 && a.every((p) => {\n        const { addedNodes: g, removedNodes: f, target: v } = p;\n        return [\n          ...Array.from(g),\n          ...Array.from(f),\n          v\n        ].some((T) => (d.isElement(T) || (T = T.parentElement), T && T.closest('[data-mutation-free=\"true\"]') !== null));\n      })), u && (this.dropInputsCache(), this.updateCurrentInput(), this.toggleInputsEmptyMark(), this.call(\n        \"updated\"\n        /* UPDATED */\n      ), this.emit(\"didMutated\", this));\n    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.editorEventBus = r || null, this.blockAPI = new J(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, i), this.tunes = o.tunes, this.composeTunes(s), this.holder = this.compose(), window.requestIdleCallback(() => {\n      this.watchBlockMutations(), this.addInputEvents(), this.toggleInputsEmptyMark();\n    });\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      wrapper: \"ce-block\",\n      wrapperStretched: \"ce-block--stretched\",\n      content: \"ce-block__content\",\n      selected: \"ce-block--selected\",\n      dropTarget: \"ce-block--drop-target\"\n    };\n  }\n  /**\n   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML\n   */\n  get inputs() {\n    if (this.cachedInputs.length !== 0)\n      return this.cachedInputs;\n    const e = d.findAllInputs(this.holder);\n    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;\n  }\n  /**\n   * Return current Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get currentInput() {\n    return this.inputs[this.inputIndex];\n  }\n  /**\n   * Set input index to the passed element\n   *\n   * @param element - HTML Element to set as current input\n   */\n  set currentInput(e) {\n    const t = this.inputs.findIndex((o) => o === e || o.contains(e));\n    t !== -1 && (this.inputIndex = t);\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get firstInput() {\n    return this.inputs[0];\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get lastInput() {\n    const e = this.inputs;\n    return e[e.length - 1];\n  }\n  /**\n   * Return next Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get nextInput() {\n    return this.inputs[this.inputIndex + 1];\n  }\n  /**\n   * Return previous Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get previousInput() {\n    return this.inputs[this.inputIndex - 1];\n  }\n  /**\n   * Get Block's JSON data\n   *\n   * @returns {object}\n   */\n  get data() {\n    return this.save().then((e) => e && !V(e.data) ? e.data : {});\n  }\n  /**\n   * Returns tool's sanitizer config\n   *\n   * @returns {object}\n   */\n  get sanitize() {\n    return this.tool.sanitizeConfig;\n  }\n  /**\n   * is block mergeable\n   * We plugin have merge function then we call it mergeable\n   *\n   * @returns {boolean}\n   */\n  get mergeable() {\n    return A(this.toolInstance.merge);\n  }\n  /**\n   * If Block contains inputs, it is focusable\n   */\n  get focusable() {\n    return this.inputs.length !== 0;\n  }\n  /**\n   * Check block for emptiness\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    const e = d.isEmpty(this.pluginsContent, \"/\"), t = !this.hasMedia;\n    return e && t;\n  }\n  /**\n   * Check if block has a media content such as images, iframe and other\n   *\n   * @returns {boolean}\n   */\n  get hasMedia() {\n    const e = [\n      \"img\",\n      \"iframe\",\n      \"video\",\n      \"audio\",\n      \"source\",\n      \"input\",\n      \"textarea\",\n      \"twitterwidget\"\n    ];\n    return !!this.holder.querySelector(e.join(\",\"));\n  }\n  /**\n   * Set selected state\n   * We don't need to mark Block as Selected when it is empty\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set selected(e) {\n    var i, s;\n    this.holder.classList.toggle(R.CSS.selected, e);\n    const t = e === !0 && b.isRangeInsideContainer(this.holder), o = e === !1 && b.isFakeCursorInsideContainer(this.holder);\n    (t || o) && ((i = this.editorEventBus) == null || i.emit(zo, { state: e }), t ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (s = this.editorEventBus) == null || s.emit(Uo, { state: e }));\n  }\n  /**\n   * Returns True if it is Selected\n   *\n   * @returns {boolean}\n   */\n  get selected() {\n    return this.holder.classList.contains(R.CSS.selected);\n  }\n  /**\n   * Set stretched state\n   *\n   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state\n   */\n  set stretched(e) {\n    this.holder.classList.toggle(R.CSS.wrapperStretched, e);\n  }\n  /**\n   * Return Block's stretched state\n   *\n   * @returns {boolean}\n   */\n  get stretched() {\n    return this.holder.classList.contains(R.CSS.wrapperStretched);\n  }\n  /**\n   * Toggle drop target state\n   *\n   * @param {boolean} state - 'true' if block is drop target, false otherwise\n   */\n  set dropTarget(e) {\n    this.holder.classList.toggle(R.CSS.dropTarget, e);\n  }\n  /**\n   * Returns Plugins content\n   *\n   * @returns {HTMLElement}\n   */\n  get pluginsContent() {\n    return this.toolRenderedElement;\n  }\n  /**\n   * Calls Tool's method\n   *\n   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function\n   *\n   * @param {string} methodName - method to call\n   * @param {object} params - method argument\n   */\n  call(e, t) {\n    if (A(this.toolInstance[e])) {\n      e === \"appendCallback\" && S(\n        \"`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead\",\n        \"warn\"\n      );\n      try {\n        this.toolInstance[e].call(this.toolInstance, t);\n      } catch (o) {\n        S(`Error during '${e}' call: ${o.message}`, \"error\");\n      }\n    }\n  }\n  /**\n   * Call plugins merge method\n   *\n   * @param {BlockToolData} data - data to merge\n   */\n  async mergeWith(e) {\n    await this.toolInstance.merge(e);\n  }\n  /**\n   * Extracts data from Block\n   * Groups Tool's save processing time\n   *\n   * @returns {object}\n   */\n  async save() {\n    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;\n    [\n      ...this.tunesInstances.entries(),\n      ...this.defaultTunesInstances.entries()\n    ].forEach(([s, r]) => {\n      if (A(r.save))\n        try {\n          t[s] = r.save();\n        } catch (a) {\n          S(`Tune ${r.constructor.name} save method throws an Error %o`, \"warn\", a);\n        }\n    });\n    const o = window.performance.now();\n    let i;\n    return Promise.resolve(e).then((s) => (i = window.performance.now(), {\n      id: this.id,\n      tool: this.name,\n      data: s,\n      tunes: t,\n      time: i - o\n    })).catch((s) => {\n      S(`Saving process for ${this.name} tool failed due to the ${s}`, \"log\", \"red\");\n    });\n  }\n  /**\n   * Uses Tool's validation method to check the correctness of output data\n   * Tool's validation method is optional\n   *\n   * @description Method returns true|false whether data passed the validation or not\n   * @param {BlockToolData} data - data to validate\n   * @returns {Promise<boolean>} valid\n   */\n  async validate(e) {\n    let t = !0;\n    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;\n  }\n  /**\n   * Returns data to render in Block Tunes menu.\n   * Splits block tunes into 2 groups: block specific tunes and common tunes\n   */\n  getTunes() {\n    const e = [], t = [], o = typeof this.toolInstance.renderSettings == \"function\" ? this.toolInstance.renderSettings() : [];\n    return d.isElement(o) ? e.push({\n      type: _.Html,\n      element: o\n    }) : Array.isArray(o) ? e.push(...o) : e.push(o), [\n      ...this.tunesInstances.values(),\n      ...this.defaultTunesInstances.values()\n    ].map((s) => s.render()).forEach((s) => {\n      d.isElement(s) ? t.push({\n        type: _.Html,\n        element: s\n      }) : Array.isArray(s) ? t.push(...s) : t.push(s);\n    }), {\n      toolTunes: e,\n      commonTunes: t\n    };\n  }\n  /**\n   * Update current input index with selection anchor node\n   */\n  updateCurrentInput() {\n    this.currentInput = d.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;\n  }\n  /**\n   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n   * Can be useful for block changes invisible for editor core.\n   */\n  dispatchChange() {\n    this.didMutated();\n  }\n  /**\n   * Call Tool instance destroy method\n   */\n  destroy() {\n    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), A(this.toolInstance.destroy) && this.toolInstance.destroy();\n  }\n  /**\n   * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n   * This method returns the entry that is related to the Block (depended on the Block data)\n   */\n  async getActiveToolboxEntry() {\n    const e = this.tool.toolbox;\n    if (e.length === 1)\n      return Promise.resolve(this.tool.toolbox[0]);\n    const t = await this.data, o = e;\n    return o == null ? void 0 : o.find((i) => Wo(i.data, t));\n  }\n  /**\n   * Exports Block data as string using conversion config\n   */\n  async exportDataAsString() {\n    const e = await this.data;\n    return fi(e, this.tool.conversionConfig);\n  }\n  /**\n   * Make default Block wrappers and put Tool`s content there\n   *\n   * @returns {HTMLDivElement}\n   */\n  compose() {\n    const e = d.make(\"div\", R.CSS.wrapper), t = d.make(\"div\", R.CSS.content), o = this.toolInstance.render();\n    e.setAttribute(\"data-cy\", \"block-wrapper\"), e.dataset.id = this.id, this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);\n    let i = t;\n    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((s) => {\n      if (A(s.wrap))\n        try {\n          i = s.wrap(i);\n        } catch (r) {\n          S(`Tune ${s.constructor.name} wrap method throws an Error %o`, \"warn\", r);\n        }\n    }), e.appendChild(i), e;\n  }\n  /**\n   * Instantiate Block Tunes\n   *\n   * @param tunesData - current Block tunes data\n   * @private\n   */\n  composeTunes(e) {\n    Array.from(this.tunes.values()).forEach((t) => {\n      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));\n    }), Object.entries(e).forEach(([t, o]) => {\n      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);\n    });\n  }\n  /**\n   * Adds focus event listeners to all inputs and contenteditable\n   */\n  addInputEvents() {\n    this.inputs.forEach((e) => {\n      e.addEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.addEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * removes focus event listeners from all inputs and contenteditable\n   */\n  removeInputEvents() {\n    this.inputs.forEach((e) => {\n      e.removeEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.removeEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * Listen common editor Dom Changed event and detect mutations related to the  Block\n   */\n  watchBlockMutations() {\n    var e;\n    this.redactorDomChangedCallback = (t) => {\n      const { mutations: o } = t;\n      o.some((s) => pi(s, this.toolRenderedElement)) && this.didMutated(o);\n    }, (e = this.editorEventBus) == null || e.on(ft, this.redactorDomChangedCallback);\n  }\n  /**\n   * Remove redactor dom change event listener\n   */\n  unwatchBlockMutations() {\n    var e;\n    (e = this.editorEventBus) == null || e.off(ft, this.redactorDomChangedCallback);\n  }\n  /**\n   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL\n   * We need to detect such changes and update a link to tools main element with the new one\n   *\n   * @param mutations - records of block content mutations\n   */\n  detectToolRootChange(e) {\n    e.forEach((t) => {\n      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {\n        const i = t.addedNodes[t.addedNodes.length - 1];\n        this.toolRenderedElement = i;\n      }\n    });\n  }\n  /**\n   * Clears inputs cached value\n   */\n  dropInputsCache() {\n    this.cachedInputs = [];\n  }\n  /**\n   * Mark inputs with 'data-empty' attribute with the empty state\n   */\n  toggleInputsEmptyMark() {\n    this.inputs.forEach(Do);\n  }\n}\nclass gi extends E {\n  constructor() {\n    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, s, r, a) => {\n      const l = this.Editor.BlockManager.insert({\n        id: a,\n        tool: e,\n        data: t,\n        index: i,\n        needToFocus: s,\n        replace: r\n      });\n      return new J(l);\n    }, this.composeBlockData = async (e) => {\n      const t = this.Editor.Tools.blockTools.get(e);\n      return new R({\n        tool: t,\n        api: this.Editor.API,\n        readOnly: !0,\n        data: {},\n        tunesData: {}\n      }).data;\n    }, this.update = async (e, t, o) => {\n      const { BlockManager: i } = this.Editor, s = i.getBlockById(e);\n      if (s === void 0)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const r = await i.update(s, t, o);\n      return new J(r);\n    }, this.convert = async (e, t, o) => {\n      var h, p;\n      const { BlockManager: i, Tools: s } = this.Editor, r = i.getBlockById(e);\n      if (!r)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const a = s.blockTools.get(r.name), l = s.blockTools.get(t);\n      if (!l)\n        throw new Error(`Block Tool with type \"${t}\" not found`);\n      const c = ((h = a == null ? void 0 : a.conversionConfig) == null ? void 0 : h.export) !== void 0, u = ((p = l.conversionConfig) == null ? void 0 : p.import) !== void 0;\n      if (c && u) {\n        const g = await i.convert(r, t, o);\n        return new J(g);\n      } else {\n        const g = [\n          c ? !1 : je(r.name),\n          u ? !1 : je(t)\n        ].filter(Boolean).join(\" and \");\n        throw new Error(`Conversion from \"${r.name}\" to \"${t}\" is not possible. ${g} tool(s) should provide a \"conversionConfig\"`);\n      }\n    }, this.insertMany = (e, t = this.Editor.BlockManager.blocks.length - 1) => {\n      this.validateIndex(t);\n      const o = e.map(({ id: i, type: s, data: r }) => this.Editor.BlockManager.composeBlock({\n        id: i,\n        tool: s || this.config.defaultBlock,\n        data: r\n      }));\n      return this.Editor.BlockManager.insertMany(o, t), o.map((i) => new J(i));\n    };\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Blocks}\n   */\n  get methods() {\n    return {\n      clear: () => this.clear(),\n      render: (e) => this.render(e),\n      renderFromHTML: (e) => this.renderFromHTML(e),\n      delete: (e) => this.delete(e),\n      swap: (e, t) => this.swap(e, t),\n      move: (e, t) => this.move(e, t),\n      getBlockByIndex: (e) => this.getBlockByIndex(e),\n      getById: (e) => this.getById(e),\n      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),\n      getBlockIndex: (e) => this.getBlockIndex(e),\n      getBlocksCount: () => this.getBlocksCount(),\n      getBlockByElement: (e) => this.getBlockByElement(e),\n      stretchBlock: (e, t = !0) => this.stretchBlock(e, t),\n      insertNewBlock: () => this.insertNewBlock(),\n      insert: this.insert,\n      insertMany: this.insertMany,\n      update: this.update,\n      composeBlockData: this.composeBlockData,\n      convert: this.convert\n    };\n  }\n  /**\n   * Returns Blocks count\n   *\n   * @returns {number}\n   */\n  getBlocksCount() {\n    return this.Editor.BlockManager.blocks.length;\n  }\n  /**\n   * Returns current block index\n   *\n   * @returns {number}\n   */\n  getCurrentBlockIndex() {\n    return this.Editor.BlockManager.currentBlockIndex;\n  }\n  /**\n   * Returns the index of Block by id;\n   *\n   * @param id - block id\n   */\n  getBlockIndex(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    if (!t) {\n      X(\"There is no block with id `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return this.Editor.BlockManager.getBlockIndex(t);\n  }\n  /**\n   * Returns BlockAPI object by Block index\n   *\n   * @param {number} index - index to get\n   */\n  getBlockByIndex(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(e);\n    if (t === void 0) {\n      X(\"There is no block at index `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new J(t);\n  }\n  /**\n   * Returns BlockAPI object by Block id\n   *\n   * @param id - id of block to get\n   */\n  getById(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    return t === void 0 ? (X(\"There is no block with id `\" + e + \"`\", \"warn\"), null) : new J(t);\n  }\n  /**\n   * Get Block API object by any child html element\n   *\n   * @param element - html element to get Block by\n   */\n  getBlockByElement(e) {\n    const t = this.Editor.BlockManager.getBlock(e);\n    if (t === void 0) {\n      X(\"There is no block corresponding to element `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new J(t);\n  }\n  /**\n   * Call Block Manager method that swap Blocks\n   *\n   * @param {number} fromIndex - position of first Block\n   * @param {number} toIndex - position of second Block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    S(\n      \"`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead\",\n      \"info\"\n    ), this.Editor.BlockManager.swap(e, t);\n  }\n  /**\n   * Move block from one index to another\n   *\n   * @param {number} toIndex - index to move to\n   * @param {number} fromIndex - index to move from\n   */\n  move(e, t) {\n    this.Editor.BlockManager.move(e, t);\n  }\n  /**\n   * Deletes Block\n   *\n   * @param {number} blockIndex - index of Block to delete\n   */\n  delete(e = this.Editor.BlockManager.currentBlockIndex) {\n    try {\n      const t = this.Editor.BlockManager.getBlockByIndex(e);\n      this.Editor.BlockManager.removeBlock(t);\n    } catch (t) {\n      X(t, \"warn\");\n      return;\n    }\n    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();\n  }\n  /**\n   * Clear Editor's area\n   */\n  async clear() {\n    await this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Fills Editor with Blocks data\n   *\n   * @param {OutputData} data — Saved Editor data\n   */\n  async render(e) {\n    if (e === void 0 || e.blocks === void 0)\n      throw new Error(\"Incorrect data passed to the render() method\");\n    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();\n  }\n  /**\n   * Render passed HTML string\n   *\n   * @param {string} data - HTML string to render\n   * @returns {Promise<void>}\n   */\n  renderFromHTML(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);\n  }\n  /**\n   * Stretch Block's content\n   *\n   * @param {number} index - index of Block to stretch\n   * @param {boolean} status - true to enable, false to disable\n   * @deprecated Use BlockAPI interface to stretch Blocks\n   */\n  stretchBlock(e, t = !0) {\n    ht(\n      !0,\n      \"blocks.stretchBlock()\",\n      \"BlockAPI\"\n    );\n    const o = this.Editor.BlockManager.getBlockByIndex(e);\n    o && (o.stretched = t);\n  }\n  /**\n   * Insert new Block\n   * After set caret to this Block\n   *\n   * @todo remove in 3.0.0\n   * @deprecated with insert() method\n   */\n  insertNewBlock() {\n    S(\"Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.\", \"warn\"), this.insert();\n  }\n  /**\n   * Validated block index and throws an error if it's invalid\n   *\n   * @param index - index to validate\n   */\n  validateIndex(e) {\n    if (typeof e != \"number\")\n      throw new Error(\"Index should be a number\");\n    if (e < 0)\n      throw new Error(\"Index should be greater than or equal to 0\");\n    if (e === null)\n      throw new Error(\"Index should be greater than or equal to 0\");\n  }\n}\nfunction mi(n, e) {\n  return typeof n == \"number\" ? e.BlockManager.getBlockByIndex(n) : typeof n == \"string\" ? e.BlockManager.getBlockById(n) : e.BlockManager.getBlockById(n.id);\n}\nclass bi extends E {\n  constructor() {\n    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), !0) : !1, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => {\n      const i = mi(e, this.Editor);\n      return i === void 0 ? !1 : (this.Editor.Caret.setToBlock(i, t, o), !0);\n    }, this.focus = (e = !1) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Caret}\n   */\n  get methods() {\n    return {\n      setToFirstBlock: this.setToFirstBlock,\n      setToLastBlock: this.setToLastBlock,\n      setToPreviousBlock: this.setToPreviousBlock,\n      setToNextBlock: this.setToNextBlock,\n      setToBlock: this.setToBlock,\n      focus: this.focus\n    };\n  }\n}\nclass vi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Events}\n   */\n  get methods() {\n    return {\n      emit: (e, t) => this.emit(e, t),\n      off: (e, t) => this.off(e, t),\n      on: (e, t) => this.on(e, t)\n    };\n  }\n  /**\n   * Subscribe on Events\n   *\n   * @param {string} eventName - event name to subscribe\n   * @param {Function} callback - event handler\n   */\n  on(e, t) {\n    this.eventsDispatcher.on(e, t);\n  }\n  /**\n   * Emit event with data\n   *\n   * @param {string} eventName - event to emit\n   * @param {object} data - event's data\n   */\n  emit(e, t) {\n    this.eventsDispatcher.emit(e, t);\n  }\n  /**\n   * Unsubscribe from Event\n   *\n   * @param {string} eventName - event to unsubscribe\n   * @param {Function} callback - event handler\n   */\n  off(e, t) {\n    this.eventsDispatcher.off(e, t);\n  }\n}\nclass kt extends E {\n  /**\n   * Return namespace section for tool or block tune\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  static getNamespace(e, t) {\n    return t ? `blockTunes.${e}` : `tools.${e}`;\n  }\n  /**\n   * Return I18n API methods with global dictionary access\n   */\n  get methods() {\n    return {\n      t: () => {\n        X(\"I18n.t() method can be accessed only from Tools\", \"warn\");\n      }\n    };\n  }\n  /**\n   * Return I18n API methods with tool namespaced dictionary\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        t: (o) => z.t(kt.getNamespace(e, t), o)\n      }\n    );\n  }\n}\nclass ki extends E {\n  /**\n   * Editor.js Core API modules\n   */\n  get methods() {\n    return {\n      blocks: this.Editor.BlocksAPI.methods,\n      caret: this.Editor.CaretAPI.methods,\n      tools: this.Editor.ToolsAPI.methods,\n      events: this.Editor.EventsAPI.methods,\n      listeners: this.Editor.ListenersAPI.methods,\n      notifier: this.Editor.NotifierAPI.methods,\n      sanitizer: this.Editor.SanitizerAPI.methods,\n      saver: this.Editor.SaverAPI.methods,\n      selection: this.Editor.SelectionAPI.methods,\n      styles: this.Editor.StylesAPI.classes,\n      toolbar: this.Editor.ToolbarAPI.methods,\n      inlineToolbar: this.Editor.InlineToolbarAPI.methods,\n      tooltip: this.Editor.TooltipAPI.methods,\n      i18n: this.Editor.I18nAPI.methods,\n      readOnly: this.Editor.ReadOnlyAPI.methods,\n      ui: this.Editor.UiAPI.methods\n    };\n  }\n  /**\n   * Returns Editor.js Core API methods for passed tool\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        i18n: this.Editor.I18nAPI.getMethodsForTool(e, t)\n      }\n    );\n  }\n}\nclass yi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {InlineToolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open()\n    };\n  }\n  /**\n   * Open Inline Toolbar\n   */\n  open() {\n    this.Editor.InlineToolbar.tryToShow();\n  }\n  /**\n   * Close Inline Toolbar\n   */\n  close() {\n    this.Editor.InlineToolbar.close();\n  }\n}\nclass wi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Listeners}\n   */\n  get methods() {\n    return {\n      on: (e, t, o, i) => this.on(e, t, o, i),\n      off: (e, t, o, i) => this.off(e, t, o, i),\n      offById: (e) => this.offById(e)\n    };\n  }\n  /**\n   * Ads a DOM event listener. Return it's id.\n   *\n   * @param {HTMLElement} element - Element to set handler to\n   * @param {string} eventType - event type\n   * @param {() => void} handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  on(e, t, o, i) {\n    return this.listeners.on(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener from element\n   *\n   * @param {Element} element - Element to remove handler from\n   * @param eventType - event type\n   * @param handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  off(e, t, o, i) {\n    this.listeners.off(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener by the listener id\n   *\n   * @param id - id of the listener to remove\n   */\n  offById(e) {\n    this.listeners.offById(e);\n  }\n}\nvar Ko = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"/\", i(i.s = 0);\n    }([function(t, o, i) {\n      i(1), /*!\n       * Codex JavaScript Notification module\n       * https://github.com/codex-team/js-notifier\n       */\n      t.exports = function() {\n        var s = i(6), r = \"cdx-notify--bounce-in\", a = null;\n        return { show: function(l) {\n          if (l.message) {\n            (function() {\n              if (a)\n                return !0;\n              a = s.getWrapper(), document.body.appendChild(a);\n            })();\n            var c = null, u = l.time || 8e3;\n            switch (l.type) {\n              case \"confirm\":\n                c = s.confirm(l);\n                break;\n              case \"prompt\":\n                c = s.prompt(l);\n                break;\n              default:\n                c = s.alert(l), window.setTimeout(function() {\n                  c.remove();\n                }, u);\n            }\n            a.appendChild(c), c.classList.add(r);\n          }\n        } };\n      }();\n    }, function(t, o, i) {\n      var s = i(2);\n      typeof s == \"string\" && (s = [[t.i, s, \"\"]]);\n      var r = { hmr: !0, transform: void 0, insertInto: void 0 };\n      i(4)(s, r), s.locals && (t.exports = s.locals);\n    }, function(t, o, i) {\n      (t.exports = i(3)(!1)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, \"\"]);\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = [];\n        return s.toString = function() {\n          return this.map(function(r) {\n            var a = function(l, c) {\n              var u = l[1] || \"\", h = l[3];\n              if (!h)\n                return u;\n              if (c && typeof btoa == \"function\") {\n                var p = (f = h, \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(f)))) + \" */\"), g = h.sources.map(function(v) {\n                  return \"/*# sourceURL=\" + h.sourceRoot + v + \" */\";\n                });\n                return [u].concat(g).concat([p]).join(`\n`);\n              }\n              var f;\n              return [u].join(`\n`);\n            }(r, i);\n            return r[2] ? \"@media \" + r[2] + \"{\" + a + \"}\" : a;\n          }).join(\"\");\n        }, s.i = function(r, a) {\n          typeof r == \"string\" && (r = [[null, r, \"\"]]);\n          for (var l = {}, c = 0; c < this.length; c++) {\n            var u = this[c][0];\n            typeof u == \"number\" && (l[u] = !0);\n          }\n          for (c = 0; c < r.length; c++) {\n            var h = r[c];\n            typeof h[0] == \"number\" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = \"(\" + h[2] + \") and (\" + a + \")\"), s.push(h));\n          }\n        }, s;\n      };\n    }, function(t, o, i) {\n      var s, r, a = {}, l = (s = function() {\n        return window && document && document.all && !window.atob;\n      }, function() {\n        return r === void 0 && (r = s.apply(this, arguments)), r;\n      }), c = function(k) {\n        var m = {};\n        return function(w) {\n          if (typeof w == \"function\")\n            return w();\n          if (m[w] === void 0) {\n            var x = (function(I) {\n              return document.querySelector(I);\n            }).call(this, w);\n            if (window.HTMLIFrameElement && x instanceof window.HTMLIFrameElement)\n              try {\n                x = x.contentDocument.head;\n              } catch {\n                x = null;\n              }\n            m[w] = x;\n          }\n          return m[w];\n        };\n      }(), u = null, h = 0, p = [], g = i(5);\n      function f(k, m) {\n        for (var w = 0; w < k.length; w++) {\n          var x = k[w], I = a[x.id];\n          if (I) {\n            I.refs++;\n            for (var C = 0; C < I.parts.length; C++)\n              I.parts[C](x.parts[C]);\n            for (; C < x.parts.length; C++)\n              I.parts.push(F(x.parts[C], m));\n          } else {\n            var N = [];\n            for (C = 0; C < x.parts.length; C++)\n              N.push(F(x.parts[C], m));\n            a[x.id] = { id: x.id, refs: 1, parts: N };\n          }\n        }\n      }\n      function v(k, m) {\n        for (var w = [], x = {}, I = 0; I < k.length; I++) {\n          var C = k[I], N = m.base ? C[0] + m.base : C[0], B = { css: C[1], media: C[2], sourceMap: C[3] };\n          x[N] ? x[N].parts.push(B) : w.push(x[N] = { id: N, parts: [B] });\n        }\n        return w;\n      }\n      function O(k, m) {\n        var w = c(k.insertInto);\n        if (!w)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n        var x = p[p.length - 1];\n        if (k.insertAt === \"top\")\n          x ? x.nextSibling ? w.insertBefore(m, x.nextSibling) : w.appendChild(m) : w.insertBefore(m, w.firstChild), p.push(m);\n        else if (k.insertAt === \"bottom\")\n          w.appendChild(m);\n        else {\n          if (typeof k.insertAt != \"object\" || !k.insertAt.before)\n            throw new Error(`[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n`);\n          var I = c(k.insertInto + \" \" + k.insertAt.before);\n          w.insertBefore(m, I);\n        }\n      }\n      function T(k) {\n        if (k.parentNode === null)\n          return !1;\n        k.parentNode.removeChild(k);\n        var m = p.indexOf(k);\n        m >= 0 && p.splice(m, 1);\n      }\n      function M(k) {\n        var m = document.createElement(\"style\");\n        return k.attrs.type === void 0 && (k.attrs.type = \"text/css\"), q(m, k.attrs), O(k, m), m;\n      }\n      function q(k, m) {\n        Object.keys(m).forEach(function(w) {\n          k.setAttribute(w, m[w]);\n        });\n      }\n      function F(k, m) {\n        var w, x, I, C;\n        if (m.transform && k.css) {\n          if (!(C = m.transform(k.css)))\n            return function() {\n            };\n          k.css = C;\n        }\n        if (m.singleton) {\n          var N = h++;\n          w = u || (u = M(m)), x = ie.bind(null, w, N, !1), I = ie.bind(null, w, N, !0);\n        } else\n          k.sourceMap && typeof URL == \"function\" && typeof URL.createObjectURL == \"function\" && typeof URL.revokeObjectURL == \"function\" && typeof Blob == \"function\" && typeof btoa == \"function\" ? (w = function(B) {\n            var W = document.createElement(\"link\");\n            return B.attrs.type === void 0 && (B.attrs.type = \"text/css\"), B.attrs.rel = \"stylesheet\", q(W, B.attrs), O(B, W), W;\n          }(m), x = (function(B, W, ve) {\n            var se = ve.css, tt = ve.sourceMap, Yn = W.convertToAbsoluteUrls === void 0 && tt;\n            (W.convertToAbsoluteUrls || Yn) && (se = g(se)), tt && (se += `\n/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(tt)))) + \" */\");\n            var Kn = new Blob([se], { type: \"text/css\" }), ko = B.href;\n            B.href = URL.createObjectURL(Kn), ko && URL.revokeObjectURL(ko);\n          }).bind(null, w, m), I = function() {\n            T(w), w.href && URL.revokeObjectURL(w.href);\n          }) : (w = M(m), x = (function(B, W) {\n            var ve = W.css, se = W.media;\n            if (se && B.setAttribute(\"media\", se), B.styleSheet)\n              B.styleSheet.cssText = ve;\n            else {\n              for (; B.firstChild; )\n                B.removeChild(B.firstChild);\n              B.appendChild(document.createTextNode(ve));\n            }\n          }).bind(null, w), I = function() {\n            T(w);\n          });\n        return x(k), function(B) {\n          if (B) {\n            if (B.css === k.css && B.media === k.media && B.sourceMap === k.sourceMap)\n              return;\n            x(k = B);\n          } else\n            I();\n        };\n      }\n      t.exports = function(k, m) {\n        if (typeof DEBUG < \"u\" && DEBUG && typeof document != \"object\")\n          throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n        (m = m || {}).attrs = typeof m.attrs == \"object\" ? m.attrs : {}, m.singleton || typeof m.singleton == \"boolean\" || (m.singleton = l()), m.insertInto || (m.insertInto = \"head\"), m.insertAt || (m.insertAt = \"bottom\");\n        var w = v(k, m);\n        return f(w, m), function(x) {\n          for (var I = [], C = 0; C < w.length; C++) {\n            var N = w[C];\n            (B = a[N.id]).refs--, I.push(B);\n          }\n          for (x && f(v(x, m), m), C = 0; C < I.length; C++) {\n            var B;\n            if ((B = I[C]).refs === 0) {\n              for (var W = 0; W < B.parts.length; W++)\n                B.parts[W]();\n              delete a[B.id];\n            }\n          }\n        };\n      };\n      var H, Q = (H = [], function(k, m) {\n        return H[k] = m, H.filter(Boolean).join(`\n`);\n      });\n      function ie(k, m, w, x) {\n        var I = w ? \"\" : x.css;\n        if (k.styleSheet)\n          k.styleSheet.cssText = Q(m, I);\n        else {\n          var C = document.createTextNode(I), N = k.childNodes;\n          N[m] && k.removeChild(N[m]), N.length ? k.insertBefore(C, N[m]) : k.appendChild(C);\n        }\n      }\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = typeof window < \"u\" && window.location;\n        if (!s)\n          throw new Error(\"fixUrls requires window.location\");\n        if (!i || typeof i != \"string\")\n          return i;\n        var r = s.protocol + \"//\" + s.host, a = r + s.pathname.replace(/\\/[^\\/]*$/, \"/\");\n        return i.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(l, c) {\n          var u, h = c.trim().replace(/^\"(.*)\"$/, function(p, g) {\n            return g;\n          }).replace(/^'(.*)'$/, function(p, g) {\n            return g;\n          });\n          return /^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(h) ? l : (u = h.indexOf(\"//\") === 0 ? h : h.indexOf(\"/\") === 0 ? r + h : a + h.replace(/^\\.\\//, \"\"), \"url(\" + JSON.stringify(u) + \")\");\n        });\n      };\n    }, function(t, o, i) {\n      var s, r, a, l, c, u, h, p, g;\n      t.exports = (s = \"cdx-notifies\", r = \"cdx-notify\", a = \"cdx-notify__cross\", l = \"cdx-notify__button--confirm\", c = \"cdx-notify__button--cancel\", u = \"cdx-notify__input\", h = \"cdx-notify__button\", p = \"cdx-notify__btns-wrapper\", { alert: g = function(f) {\n        var v = document.createElement(\"DIV\"), O = document.createElement(\"DIV\"), T = f.message, M = f.style;\n        return v.classList.add(r), M && v.classList.add(r + \"--\" + M), v.innerHTML = T, O.classList.add(a), O.addEventListener(\"click\", v.remove.bind(v)), v.appendChild(O), v;\n      }, confirm: function(f) {\n        var v = g(f), O = document.createElement(\"div\"), T = document.createElement(\"button\"), M = document.createElement(\"button\"), q = v.querySelector(\".\" + a), F = f.cancelHandler, H = f.okHandler;\n        return O.classList.add(p), T.innerHTML = f.okText || \"Confirm\", M.innerHTML = f.cancelText || \"Cancel\", T.classList.add(h), M.classList.add(h), T.classList.add(l), M.classList.add(c), F && typeof F == \"function\" && (M.addEventListener(\"click\", F), q.addEventListener(\"click\", F)), H && typeof H == \"function\" && T.addEventListener(\"click\", H), T.addEventListener(\"click\", v.remove.bind(v)), M.addEventListener(\"click\", v.remove.bind(v)), O.appendChild(T), O.appendChild(M), v.appendChild(O), v;\n      }, prompt: function(f) {\n        var v = g(f), O = document.createElement(\"div\"), T = document.createElement(\"button\"), M = document.createElement(\"input\"), q = v.querySelector(\".\" + a), F = f.cancelHandler, H = f.okHandler;\n        return O.classList.add(p), T.innerHTML = f.okText || \"Ok\", T.classList.add(h), T.classList.add(l), M.classList.add(u), f.placeholder && M.setAttribute(\"placeholder\", f.placeholder), f.default && (M.value = f.default), f.inputType && (M.type = f.inputType), F && typeof F == \"function\" && q.addEventListener(\"click\", F), H && typeof H == \"function\" && T.addEventListener(\"click\", function() {\n          H(M.value);\n        }), T.addEventListener(\"click\", v.remove.bind(v)), O.appendChild(M), O.appendChild(T), v.appendChild(O), v;\n      }, getWrapper: function() {\n        var f = document.createElement(\"DIV\");\n        return f.classList.add(s), f;\n      } });\n    }]);\n  });\n})(Ko);\nvar Ei = Ko.exports;\nconst xi = /* @__PURE__ */ Ke(Ei);\nclass Bi {\n  /**\n   * Show web notification\n   *\n   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options\n   */\n  show(e) {\n    xi.show(e);\n  }\n}\nclass Ci extends E {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.notifier = new Bi();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e) => this.show(e)\n    };\n  }\n  /**\n   * Show notification\n   *\n   * @param {NotifierOptions} options - message option\n   */\n  show(e) {\n    return this.notifier.show(e);\n  }\n}\nclass Ti extends E {\n  /**\n   * Available methods\n   */\n  get methods() {\n    const e = () => this.isEnabled;\n    return {\n      toggle: (t) => this.toggle(t),\n      get isEnabled() {\n        return e();\n      }\n    };\n  }\n  /**\n   * Set or toggle read-only state\n   *\n   * @param {boolean|undefined} state - set or toggle state\n   * @returns {boolean} current value\n   */\n  toggle(e) {\n    return this.Editor.ReadOnly.toggle(e);\n  }\n  /**\n   * Returns current read-only state\n   */\n  get isEnabled() {\n    return this.Editor.ReadOnly.isEnabled;\n  }\n}\nvar Xo = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(Ce, function() {\n    function t(h) {\n      var p = h.tags, g = Object.keys(p), f = g.map(function(v) {\n        return typeof p[v];\n      }).every(function(v) {\n        return v === \"object\" || v === \"boolean\" || v === \"function\";\n      });\n      if (!f)\n        throw new Error(\"The configuration was invalid\");\n      this.config = h;\n    }\n    var o = [\"P\", \"LI\", \"TD\", \"TH\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\"];\n    function i(h) {\n      return o.indexOf(h.nodeName) !== -1;\n    }\n    var s = [\"A\", \"B\", \"STRONG\", \"I\", \"EM\", \"SUB\", \"SUP\", \"U\", \"STRIKE\"];\n    function r(h) {\n      return s.indexOf(h.nodeName) !== -1;\n    }\n    t.prototype.clean = function(h) {\n      const p = document.implementation.createHTMLDocument(), g = p.createElement(\"div\");\n      return g.innerHTML = h, this._sanitize(p, g), g.innerHTML;\n    }, t.prototype._sanitize = function(h, p) {\n      var g = a(h, p), f = g.firstChild();\n      if (f)\n        do {\n          if (f.nodeType === Node.TEXT_NODE)\n            if (f.data.trim() === \"\" && (f.previousElementSibling && i(f.previousElementSibling) || f.nextElementSibling && i(f.nextElementSibling))) {\n              p.removeChild(f), this._sanitize(h, p);\n              break;\n            } else\n              continue;\n          if (f.nodeType === Node.COMMENT_NODE) {\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          var v = r(f), O;\n          v && (O = Array.prototype.some.call(f.childNodes, i));\n          var T = !!p.parentNode, M = i(p) && i(f) && T, q = f.nodeName.toLowerCase(), F = l(this.config, q, f), H = v && O;\n          if (H || c(f, F) || !this.config.keepNestedBlockElements && M) {\n            if (!(f.nodeName === \"SCRIPT\" || f.nodeName === \"STYLE\"))\n              for (; f.childNodes.length > 0; )\n                p.insertBefore(f.childNodes[0], f);\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          for (var Q = 0; Q < f.attributes.length; Q += 1) {\n            var ie = f.attributes[Q];\n            u(ie, F, f) && (f.removeAttribute(ie.name), Q = Q - 1);\n          }\n          this._sanitize(h, f);\n        } while (f = g.nextSibling());\n    };\n    function a(h, p) {\n      return h.createTreeWalker(\n        p,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n        null,\n        !1\n      );\n    }\n    function l(h, p, g) {\n      return typeof h.tags[p] == \"function\" ? h.tags[p](g) : h.tags[p];\n    }\n    function c(h, p) {\n      return typeof p > \"u\" ? !0 : typeof p == \"boolean\" ? !p : !1;\n    }\n    function u(h, p, g) {\n      var f = h.name.toLowerCase();\n      return p === !0 ? !1 : typeof p[f] == \"function\" ? !p[f](h.value, g) : typeof p[f] > \"u\" || p[f] === !1 ? !0 : typeof p[f] == \"string\" ? p[f] !== h.value : !1;\n    }\n    return t;\n  });\n})(Xo);\nvar Si = Xo.exports;\nconst Ii = /* @__PURE__ */ Ke(Si);\nfunction yt(n, e) {\n  return n.map((t) => {\n    const o = A(e) ? e(t.tool) : e;\n    return V(o) || (t.data = wt(t.data, o)), t;\n  });\n}\nfunction Z(n, e = {}) {\n  const t = {\n    tags: e\n  };\n  return new Ii(t).clean(n);\n}\nfunction wt(n, e) {\n  return Array.isArray(n) ? Oi(n, e) : D(n) ? _i(n, e) : te(n) ? Mi(n, e) : n;\n}\nfunction Oi(n, e) {\n  return n.map((t) => wt(t, e));\n}\nfunction _i(n, e) {\n  const t = {};\n  for (const o in n) {\n    if (!Object.prototype.hasOwnProperty.call(n, o))\n      continue;\n    const i = n[o], s = Ai(e[o]) ? e[o] : e;\n    t[o] = wt(i, s);\n  }\n  return t;\n}\nfunction Mi(n, e) {\n  return D(e) ? Z(n, e) : e === !1 ? Z(n, {}) : n;\n}\nfunction Ai(n) {\n  return D(n) || Gn(n) || A(n);\n}\nclass Li extends E {\n  /**\n   * Available methods\n   *\n   * @returns {SanitizerConfig}\n   */\n  get methods() {\n    return {\n      clean: (e, t) => this.clean(e, t)\n    };\n  }\n  /**\n   * Perform sanitizing of a string\n   *\n   * @param {string} taintString - what to sanitize\n   * @param {SanitizerConfig} config - sanitizer config\n   * @returns {string}\n   */\n  clean(e, t) {\n    return Z(e, t);\n  }\n}\nclass Pi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Saver}\n   */\n  get methods() {\n    return {\n      save: () => this.save()\n    };\n  }\n  /**\n   * Return Editor's data\n   *\n   * @returns {OutputData}\n   */\n  save() {\n    const e = \"Editor's content can not be saved in read-only mode\";\n    return this.Editor.ReadOnly.isEnabled ? (X(e, \"warn\"), Promise.reject(new Error(e))) : this.Editor.Saver.save();\n  }\n}\nclass Ni extends E {\n  constructor() {\n    super(...arguments), this.selectionUtils = new b();\n  }\n  /**\n   * Available methods\n   *\n   * @returns {SelectionAPIInterface}\n   */\n  get methods() {\n    return {\n      findParentTag: (e, t) => this.findParentTag(e, t),\n      expandToTag: (e) => this.expandToTag(e),\n      save: () => this.selectionUtils.save(),\n      restore: () => this.selectionUtils.restore(),\n      setFakeBackground: () => this.selectionUtils.setFakeBackground(),\n      removeFakeBackground: () => this.selectionUtils.removeFakeBackground()\n    };\n  }\n  /**\n   * Looks ahead from selection and find passed tag with class name\n   *\n   * @param {string} tagName - tag to find\n   * @param {string} className - tag's class name\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t) {\n    return this.selectionUtils.findParentTag(e, t);\n  }\n  /**\n   * Expand selection to passed tag\n   *\n   * @param {HTMLElement} node - tag that should contain selection\n   */\n  expandToTag(e) {\n    this.selectionUtils.expandToTag(e);\n  }\n}\nclass Ri extends E {\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      getBlockTools: () => Array.from(this.Editor.Tools.blockTools.values())\n    };\n  }\n}\nclass Di extends E {\n  /**\n   * Exported classes\n   */\n  get classes() {\n    return {\n      /**\n       * Base Block styles\n       */\n      block: \"cdx-block\",\n      /**\n       * Inline Tools styles\n       */\n      inlineToolButton: \"ce-inline-tool\",\n      inlineToolButtonActive: \"ce-inline-tool--active\",\n      /**\n       * UI elements\n       */\n      input: \"cdx-input\",\n      loader: \"cdx-loader\",\n      button: \"cdx-button\",\n      /**\n       * Settings styles\n       */\n      settingsButton: \"cdx-settings-button\",\n      settingsButtonActive: \"cdx-settings-button--active\"\n    };\n  }\n}\nclass Fi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Toolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open(),\n      toggleBlockSettings: (e) => this.toggleBlockSettings(e),\n      toggleToolbox: (e) => this.toggleToolbox(e)\n    };\n  }\n  /**\n   * Open toolbar\n   */\n  open() {\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * Close toolbar and all included elements\n   */\n  close() {\n    this.Editor.Toolbar.close();\n  }\n  /**\n   * Toggles Block Setting of the current block\n   *\n   * @param {boolean} openingState —  opening state of Block Setting\n   */\n  toggleBlockSettings(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      X(\"Could't toggle the Toolbar because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();\n  }\n  /**\n   * Open toolbox\n   *\n   * @param {boolean} openingState - Opening state of toolbox\n   */\n  toggleToolbox(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      X(\"Could't toggle the Toolbox because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();\n  }\n}\nvar Vo = { exports: {} };\n/*!\n * CodeX.Tooltips\n * \n * @version 1.0.5\n * \n * @licence MIT\n * @author CodeX <https://codex.so>\n * \n * \n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      t.exports = i(1);\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return s;\n      });\n      class s {\n        constructor() {\n          this.nodes = { wrapper: null, content: null }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {\n            this.showed && this.hide(!0);\n          }, this.loadStyles(), this.prepare(), window.addEventListener(\"scroll\", this.handleWindowScroll, { passive: !0 });\n        }\n        get CSS() {\n          return { tooltip: \"ct\", tooltipContent: \"ct__content\", tooltipShown: \"ct--shown\", placement: { left: \"ct--left\", bottom: \"ct--bottom\", right: \"ct--right\", top: \"ct--top\" } };\n        }\n        show(a, l, c) {\n          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);\n          const u = Object.assign({ placement: \"bottom\", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c);\n          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = \"\", typeof l == \"string\")\n            this.nodes.content.appendChild(document.createTextNode(l));\n          else {\n            if (!(l instanceof Node))\n              throw Error(\"[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But \" + typeof l + \" given.\");\n            this.nodes.content.appendChild(l);\n          }\n          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {\n            case \"top\":\n              this.placeTop(a, u);\n              break;\n            case \"left\":\n              this.placeLeft(a, u);\n              break;\n            case \"right\":\n              this.placeRight(a, u);\n              break;\n            case \"bottom\":\n            default:\n              this.placeBottom(a, u);\n          }\n          u && u.delay ? this.showingTimeout = setTimeout(() => {\n            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;\n          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);\n        }\n        hide(a = !1) {\n          if (this.hidingDelay && !a)\n            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {\n              this.hide(!0);\n            }, this.hidingDelay));\n          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);\n        }\n        onHover(a, l, c) {\n          a.addEventListener(\"mouseenter\", () => {\n            this.show(a, l, c);\n          }), a.addEventListener(\"mouseleave\", () => {\n            this.hide();\n          });\n        }\n        destroy() {\n          this.nodes.wrapper.remove(), window.removeEventListener(\"scroll\", this.handleWindowScroll);\n        }\n        prepare() {\n          this.nodes.wrapper = this.make(\"div\", this.CSS.tooltip), this.nodes.content = this.make(\"div\", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);\n        }\n        loadStyles() {\n          const a = \"codex-tooltips-style\";\n          if (document.getElementById(a))\n            return;\n          const l = i(2), c = this.make(\"style\", null, { textContent: l.toString(), id: a });\n          this.prepend(document.head, c);\n        }\n        placeBottom(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + l.marginTop;\n          this.applyPlacement(\"bottom\", u, h);\n        }\n        placeTop(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;\n          this.applyPlacement(\"top\", u, h);\n        }\n        placeLeft(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"left\", u, h);\n        }\n        placeRight(a, l) {\n          const c = a.getBoundingClientRect(), u = c.right + this.offsetRight + l.marginRight, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"right\", u, h);\n        }\n        applyPlacement(a, l, c) {\n          this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + \"px\", this.nodes.wrapper.style.top = c + \"px\";\n        }\n        make(a, l = null, c = {}) {\n          const u = document.createElement(a);\n          Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);\n          for (const h in c)\n            c.hasOwnProperty(h) && (u[h] = c[h]);\n          return u;\n        }\n        append(a, l) {\n          Array.isArray(l) ? l.forEach((c) => a.appendChild(c)) : a.appendChild(l);\n        }\n        prepend(a, l) {\n          Array.isArray(l) ? (l = l.reverse()).forEach((c) => a.prepend(c)) : a.prepend(l);\n        }\n      }\n    }, function(t, o) {\n      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:\"\";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url(\"\")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path d=\"M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z\"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:\"\";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;\n    }]).default;\n  });\n})(Vo);\nvar ji = Vo.exports;\nconst Hi = /* @__PURE__ */ Ke(ji);\nlet U = null;\nfunction Et() {\n  U || (U = new Hi());\n}\nfunction $i(n, e, t) {\n  Et(), U == null || U.show(n, e, t);\n}\nfunction $e(n = !1) {\n  Et(), U == null || U.hide(n);\n}\nfunction ze(n, e, t) {\n  Et(), U == null || U.onHover(n, e, t);\n}\nfunction zi() {\n  U == null || U.destroy(), U = null;\n}\nclass Ui extends E {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    });\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e, t, o) => this.show(e, t, o),\n      hide: () => this.hide(),\n      onHover: (e, t, o) => this.onHover(e, t, o)\n    };\n  }\n  /**\n   * Method show tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  show(e, t, o) {\n    $i(e, t, o);\n  }\n  /**\n   * Method hides tooltip on HTML page\n   */\n  hide() {\n    $e();\n  }\n  /**\n   * Decorator for showing Tooltip by mouseenter/mouseleave\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  onHover(e, t, o) {\n    ze(e, t, o);\n  }\n}\nclass Wi extends E {\n  /**\n   * Available methods / getters\n   */\n  get methods() {\n    return {\n      nodes: this.editorNodes\n      /**\n       * There can be added some UI methods, like toggleThinMode() etc\n       */\n    };\n  }\n  /**\n   * Exported classes\n   */\n  get editorNodes() {\n    return {\n      /**\n       * Top-level editor instance wrapper\n       */\n      wrapper: this.Editor.UI.nodes.wrapper,\n      /**\n       * Element that holds all the Blocks\n       */\n      redactor: this.Editor.UI.nodes.redactor\n    };\n  }\n}\nfunction qo(n, e) {\n  const t = {};\n  return Object.entries(n).forEach(([o, i]) => {\n    if (D(i)) {\n      const s = e ? `${e}.${o}` : o;\n      Object.values(i).every((a) => te(a)) ? t[o] = s : t[o] = qo(i, s);\n      return;\n    }\n    t[o] = i;\n  }), t;\n}\nconst K = qo(Fo);\nfunction Yi(n, e) {\n  const t = {};\n  return Object.keys(n).forEach((o) => {\n    const i = e[o];\n    i !== void 0 ? t[i] = n[o] : t[o] = n[o];\n  }), t;\n}\nconst Zo = class Ee {\n  /**\n   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items\n   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process\n   */\n  constructor(e, t) {\n    this.cursor = -1, this.items = [], this.items = e || [], this.focusedCssClass = t;\n  }\n  /**\n   * Returns Focused button Node\n   *\n   * @returns {HTMLElement}\n   */\n  get currentItem() {\n    return this.cursor === -1 ? null : this.items[this.cursor];\n  }\n  /**\n   * Sets cursor to specified position\n   *\n   * @param cursorPosition - new cursor position\n   */\n  setCursor(e) {\n    e < this.items.length && e >= -1 && (this.dropCursor(), this.cursor = e, this.items[this.cursor].classList.add(this.focusedCssClass));\n  }\n  /**\n   * Sets items. Can be used when iterable items changed dynamically\n   *\n   * @param {HTMLElement[]} nodeList - nodes to iterate\n   */\n  setItems(e) {\n    this.items = e;\n  }\n  /**\n   * Sets cursor next to the current\n   */\n  next() {\n    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.RIGHT);\n  }\n  /**\n   * Sets cursor before current\n   */\n  previous() {\n    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.LEFT);\n  }\n  /**\n   * Sets cursor to the default position and removes CSS-class from previously focused item\n   */\n  dropCursor() {\n    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);\n  }\n  /**\n   * Leafs nodes inside the target list from active element\n   *\n   * @param {string} direction - leaf direction. Can be 'left' or 'right'\n   * @returns {number} index of focused node\n   */\n  leafNodesAndReturnIndex(e) {\n    if (this.items.length === 0)\n      return this.cursor;\n    let t = this.cursor;\n    return t === -1 ? t = e === Ee.directions.RIGHT ? -1 : 0 : this.items[t].classList.remove(this.focusedCssClass), e === Ee.directions.RIGHT ? t = (t + 1) % this.items.length : t = (this.items.length + t - 1) % this.items.length, d.canSetCaret(this.items[t]) && Fe(() => b.setCursor(this.items[t]), 50)(), this.items[t].classList.add(this.focusedCssClass), t;\n  }\n};\nZo.directions = {\n  RIGHT: \"right\",\n  LEFT: \"left\"\n};\nlet ke = Zo;\nclass ce {\n  /**\n   * @param options - different constructing settings\n   */\n  constructor(e) {\n    this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t) => {\n      if (this.isEventReadyForHandling(t))\n        switch (ce.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {\n          case y.TAB:\n            this.handleTabPress(t);\n            break;\n          case y.LEFT:\n          case y.UP:\n            this.flipLeft();\n            break;\n          case y.RIGHT:\n          case y.DOWN:\n            this.flipRight();\n            break;\n          case y.ENTER:\n            this.handleEnterPress(t);\n            break;\n        }\n    }, this.iterator = new ke(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || ce.usedKeys;\n  }\n  /**\n   * True if flipper is currently activated\n   */\n  get isActivated() {\n    return this.activated;\n  }\n  /**\n   * Array of keys (codes) that is handled by Flipper\n   * Used to:\n   *  - preventDefault only for this keys, not all keydowns (@see constructor)\n   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)\n   */\n  static get usedKeys() {\n    return [\n      y.TAB,\n      y.LEFT,\n      y.RIGHT,\n      y.ENTER,\n      y.UP,\n      y.DOWN\n    ];\n  }\n  /**\n   * Active tab/arrows handling by flipper\n   *\n   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically\n   * @param cursorPosition - index of the item that should be focused once flipper is activated\n   */\n  activate(e, t) {\n    this.activated = !0, e && this.iterator.setItems(e), t !== void 0 && this.iterator.setCursor(t), document.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  /**\n   * Disable tab/arrows handling by flipper\n   */\n  deactivate() {\n    this.activated = !1, this.dropCursor(), document.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n  /**\n   * Focus first item\n   */\n  focusFirst() {\n    this.dropCursor(), this.flipRight();\n  }\n  /**\n   * Focuses previous flipper iterator item\n   */\n  flipLeft() {\n    this.iterator.previous(), this.flipCallback();\n  }\n  /**\n   * Focuses next flipper iterator item\n   */\n  flipRight() {\n    this.iterator.next(), this.flipCallback();\n  }\n  /**\n   * Return true if some button is focused\n   */\n  hasFocus() {\n    return !!this.iterator.currentItem;\n  }\n  /**\n   * Registeres function that should be executed on each navigation action\n   *\n   * @param cb - function to execute\n   */\n  onFlip(e) {\n    this.flipCallbacks.push(e);\n  }\n  /**\n   * Unregisteres function that is executed on each navigation action\n   *\n   * @param cb - function to stop executing\n   */\n  removeOnFlip(e) {\n    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);\n  }\n  /**\n   * Drops flipper's iterator cursor\n   *\n   * @see DomIterator#dropCursor\n   */\n  dropCursor() {\n    this.iterator.dropCursor();\n  }\n  /**\n   * This function is fired before handling flipper keycodes\n   * The result of this function defines if it is need to be handled or not\n   *\n   * @param {KeyboardEvent} event - keydown keyboard event\n   * @returns {boolean}\n   */\n  isEventReadyForHandling(e) {\n    return this.activated && this.allowedKeys.includes(e.keyCode);\n  }\n  /**\n   * When flipper is activated tab press will leaf the items\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  handleTabPress(e) {\n    switch (e.shiftKey ? ke.directions.LEFT : ke.directions.RIGHT) {\n      case ke.directions.RIGHT:\n        this.flipRight();\n        break;\n      case ke.directions.LEFT:\n        this.flipLeft();\n        break;\n    }\n  }\n  /**\n   * Enter press will click current item if flipper is activated\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  handleEnterPress(e) {\n    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), A(this.activateCallback) && this.activateCallback(this.iterator.currentItem));\n  }\n  /**\n   * Fired after flipping in any direction\n   */\n  flipCallback() {\n    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());\n  }\n}\nconst Ki = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11\"/></svg>', Xi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>', Vi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.5 17.5L9.64142 12.6414C9.56331 12.5633 9.56331 12.4367 9.64142 12.3586L14.5 7.5\"/></svg>', qi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9.58284 17.5L14.4414 12.6414C14.5195 12.5633 14.5195 12.4367 14.4414 12.3586L9.58284 7.5\"/></svg>', Zi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15\"/></svg>', Gi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', Qi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>', Ji = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13.34 10C12.4223 12.7337 11 17 11 17\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.21 7H14.2\"/></svg>', Co = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72\"/></svg>', es = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 7.29999H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 7.29999H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.30999 12H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 12H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 16.7H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 16.7H14.59\"/></svg>', ts = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', Go = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M11.5 17.5L5 11M5 11V15.5M5 11H9.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12.5 6.5L19 13M19 13V8.5M19 13H14.5\"/></svg>', os = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"10.5\" cy=\"10.5\" r=\"5.5\" stroke=\"currentColor\" stroke-width=\"2\"/><line x1=\"15.4142\" x2=\"19\" y1=\"15\" y2=\"18.5858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', ns = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397\"/><line x1=\"12.1142\" x2=\"11.7\" y1=\"12.2\" y2=\"11.7858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', is = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>', ss = \"__\", rs = \"--\";\nfunction ne(n) {\n  return (e, t) => [[n, e].filter((i) => !!i).join(ss), t].filter((i) => !!i).join(rs);\n}\nconst ye = ne(\"ce-hint\"), we = {\n  root: ye(),\n  alignedStart: ye(null, \"align-left\"),\n  alignedCenter: ye(null, \"align-center\"),\n  title: ye(\"title\"),\n  description: ye(\"description\")\n};\nclass as {\n  /**\n   * Constructs the hint content instance\n   *\n   * @param params - hint content parameters\n   */\n  constructor(e) {\n    this.nodes = {\n      root: d.make(\"div\", [we.root, e.alignment === \"center\" ? we.alignedCenter : we.alignedStart]),\n      title: d.make(\"div\", we.title, { textContent: e.title })\n    }, this.nodes.root.appendChild(this.nodes.title), e.description !== void 0 && (this.nodes.description = d.make(\"div\", we.description, { textContent: e.description }), this.nodes.root.appendChild(this.nodes.description));\n  }\n  /**\n   * Returns the root element of the hint content\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n}\nclass xt {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    this.params = e;\n  }\n  /**\n   * Item name if exists\n   */\n  get name() {\n    if (this.params !== void 0 && \"name\" in this.params)\n      return this.params.name;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    $e();\n  }\n  /**\n   * Called when children popover is opened (if exists)\n   */\n  onChildrenOpen() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onOpen) == \"function\" && this.params.children.onOpen();\n  }\n  /**\n   * Called when children popover is closed (if exists)\n   */\n  onChildrenClose() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onClose) == \"function\" && this.params.children.onClose();\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    var e, t;\n    this.params !== void 0 && \"onActivate\" in this.params && ((t = (e = this.params).onActivate) == null || t.call(e, this.params));\n  }\n  /**\n   * Adds hint to the item element if hint data is provided\n   *\n   * @param itemElement - popover item root element to add hint to\n   * @param hintData - hint data\n   */\n  addHint(e, t) {\n    const o = new as(t);\n    ze(e, o.getElement(), {\n      placement: t.position,\n      hidingDelay: 100\n    });\n  }\n  /**\n   * Returns item children that are represented as popover items\n   */\n  get children() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.items) !== void 0 ? this.params.children.items : [];\n  }\n  /**\n   * Returns true if item has any type of children\n   */\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n  /**\n   * Returns true if item children should be open instantly after popover is opened and not on item click/hover\n   */\n  get isChildrenOpen() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.isOpen) === !0;\n  }\n  /**\n   * True if item children items should be navigatable via keyboard\n   */\n  get isChildrenFlippable() {\n    var e;\n    return !(this.params === void 0 || !(\"children\" in this.params) || ((e = this.params.children) == null ? void 0 : e.isFlippable) === !1);\n  }\n  /**\n   * Returns true if item has children that should be searchable\n   */\n  get isChildrenSearchable() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.searchable) === !0;\n  }\n  /**\n   * True if popover should close once item is activated\n   */\n  get closeOnActivate() {\n    return this.params !== void 0 && \"closeOnActivate\" in this.params && this.params.closeOnActivate;\n  }\n  /**\n   * True if item is active\n   */\n  get isActive() {\n    return this.params === void 0 || !(\"isActive\" in this.params) ? !1 : typeof this.params.isActive == \"function\" ? this.params.isActive() : this.params.isActive === !0;\n  }\n}\nconst Y = ne(\"ce-popover-item\"), L = {\n  container: Y(),\n  active: Y(null, \"active\"),\n  disabled: Y(null, \"disabled\"),\n  focused: Y(null, \"focused\"),\n  hidden: Y(null, \"hidden\"),\n  confirmationState: Y(null, \"confirmation\"),\n  noHover: Y(null, \"no-hover\"),\n  noFocus: Y(null, \"no-focus\"),\n  title: Y(\"title\"),\n  secondaryTitle: Y(\"secondary-title\"),\n  icon: Y(\"icon\"),\n  iconTool: Y(\"icon\", \"tool\"),\n  iconChevronRight: Y(\"icon\", \"chevron-right\"),\n  wobbleAnimation: ne(\"wobble\")()\n};\nclass re extends xt {\n  /**\n   * Constructs popover item instance\n   *\n   * @param params - popover item construction params\n   * @param renderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e), this.params = e, this.nodes = {\n      root: null,\n      icon: null\n    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noFocus);\n    }, this.removeSpecialHoverBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noHover);\n    }, this.onErrorAnimationEnd = () => {\n      var o, i;\n      (o = this.nodes.icon) == null || o.classList.remove(L.wobbleAnimation), (i = this.nodes.icon) == null || i.removeEventListener(\"animationend\", this.onErrorAnimationEnd);\n    }, this.nodes.root = this.make(e, t);\n  }\n  /**\n   * True if item is disabled and hence not clickable\n   */\n  get isDisabled() {\n    return this.params.isDisabled === !0;\n  }\n  /**\n   * Exposes popover item toggle parameter\n   */\n  get toggle() {\n    return this.params.toggle;\n  }\n  /**\n   * Item title\n   */\n  get title() {\n    return this.params.title;\n  }\n  /**\n   * True if confirmation state is enabled for popover item\n   */\n  get isConfirmationStateEnabled() {\n    return this.confirmationState !== null;\n  }\n  /**\n   * True if item is focused in keyboard navigation process\n   */\n  get isFocused() {\n    return this.nodes.root === null ? !1 : this.nodes.root.classList.contains(L.focused);\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    if (this.isConfirmationStateEnabled && this.confirmationState !== null) {\n      this.activateOrEnableConfirmationMode(this.confirmationState);\n      return;\n    }\n    this.activateOrEnableConfirmationMode(this.params);\n  }\n  /**\n   * Toggles item active state\n   *\n   * @param isActive - true if item should strictly should become active\n   */\n  toggleActive(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.active, e);\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.hidden, e);\n  }\n  /**\n   * Resets popover item to its original state\n   */\n  reset() {\n    this.isConfirmationStateEnabled && this.disableConfirmationMode();\n  }\n  /**\n   * Method called once item becomes focused during keyboard navigation\n   */\n  onFocus() {\n    this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Constructs HTML element corresponding to popover item params\n   *\n   * @param params - item construction params\n   * @param renderParams - popover item render params\n   */\n  make(e, t) {\n    var s, r;\n    const o = (t == null ? void 0 : t.wrapperTag) || \"div\", i = d.make(o, L.container, {\n      type: o === \"button\" ? \"button\" : void 0\n    });\n    return e.name && (i.dataset.itemName = e.name), this.nodes.icon = d.make(\"div\", [L.icon, L.iconTool], {\n      innerHTML: e.icon || Qi\n    }), i.appendChild(this.nodes.icon), e.title !== void 0 && i.appendChild(d.make(\"div\", L.title, {\n      innerHTML: e.title || \"\"\n    })), e.secondaryLabel && i.appendChild(d.make(\"div\", L.secondaryTitle, {\n      textContent: e.secondaryLabel\n    })), this.hasChildren && i.appendChild(d.make(\"div\", [L.icon, L.iconChevronRight], {\n      innerHTML: qi\n    })), this.isActive && i.classList.add(L.active), e.isDisabled && i.classList.add(L.disabled), e.hint !== void 0 && ((s = t == null ? void 0 : t.hint) == null ? void 0 : s.enabled) !== !1 && this.addHint(i, {\n      ...e.hint,\n      position: ((r = t == null ? void 0 : t.hint) == null ? void 0 : r.position) || \"right\"\n    }), i;\n  }\n  /**\n   * Activates confirmation mode for the item.\n   *\n   * @param newState - new popover item params that should be applied\n   */\n  enableConfirmationMode(e) {\n    if (this.nodes.root === null)\n      return;\n    const t = {\n      ...this.params,\n      ...e,\n      confirmation: \"confirmation\" in e ? e.confirmation : void 0\n    }, o = this.make(t);\n    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(L.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Returns item to its original state\n   */\n  disableConfirmationMode() {\n    if (this.nodes.root === null)\n      return;\n    const e = this.make(this.params);\n    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(L.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Enables special focus and hover behavior for item in confirmation state.\n   * This is needed to prevent item from being highlighted as hovered/focused just after click.\n   */\n  enableSpecialHoverAndFocusBehavior() {\n    var e, t, o;\n    (e = this.nodes.root) == null || e.classList.add(L.noHover), (t = this.nodes.root) == null || t.classList.add(L.noFocus), (o = this.nodes.root) == null || o.addEventListener(\"mouseleave\", this.removeSpecialHoverBehavior, { once: !0 });\n  }\n  /**\n   * Disables special focus and hover behavior\n   */\n  disableSpecialHoverAndFocusBehavior() {\n    var e;\n    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), (e = this.nodes.root) == null || e.removeEventListener(\"mouseleave\", this.removeSpecialHoverBehavior);\n  }\n  /**\n   * Executes item's onActivate callback if the item has no confirmation configured\n   *\n   * @param item - item to activate or bring to confirmation mode\n   */\n  activateOrEnableConfirmationMode(e) {\n    var t;\n    if (!(\"confirmation\" in e) || e.confirmation === void 0)\n      try {\n        (t = e.onActivate) == null || t.call(e, e), this.disableConfirmationMode();\n      } catch {\n        this.animateError();\n      }\n    else\n      this.enableConfirmationMode(e.confirmation);\n  }\n  /**\n   * Animates item which symbolizes that error occured while executing 'onActivate()' callback\n   */\n  animateError() {\n    var e, t, o;\n    (e = this.nodes.icon) != null && e.classList.contains(L.wobbleAnimation) || ((t = this.nodes.icon) == null || t.classList.add(L.wobbleAnimation), (o = this.nodes.icon) == null || o.addEventListener(\"animationend\", this.onErrorAnimationEnd));\n  }\n}\nconst nt = ne(\"ce-popover-item-separator\"), it = {\n  container: nt(),\n  line: nt(\"line\"),\n  hidden: nt(null, \"hidden\")\n};\nclass Qo extends xt {\n  /**\n   * Constructs the instance\n   */\n  constructor() {\n    super(), this.nodes = {\n      root: d.make(\"div\", it.container),\n      line: d.make(\"div\", it.line)\n    }, this.nodes.root.appendChild(this.nodes.line);\n  }\n  /**\n   * Returns popover separator root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(it.hidden, e);\n  }\n}\nvar G = /* @__PURE__ */ ((n) => (n.Closed = \"closed\", n.ClosedOnActivate = \"closed-on-activate\", n))(G || {});\nconst $ = ne(\"ce-popover\"), P = {\n  popover: $(),\n  popoverContainer: $(\"container\"),\n  popoverOpenTop: $(null, \"open-top\"),\n  popoverOpenLeft: $(null, \"open-left\"),\n  popoverOpened: $(null, \"opened\"),\n  search: $(\"search\"),\n  nothingFoundMessage: $(\"nothing-found-message\"),\n  nothingFoundMessageDisplayed: $(\"nothing-found-message\", \"displayed\"),\n  items: $(\"items\"),\n  overlay: $(\"overlay\"),\n  overlayHidden: $(\"overlay\", \"hidden\"),\n  popoverNested: $(null, \"nested\"),\n  getPopoverNestedClass: (n) => $(null, `nested-level-${n.toString()}`),\n  popoverInline: $(null, \"inline\"),\n  popoverHeader: $(\"header\")\n};\nvar fe = /* @__PURE__ */ ((n) => (n.NestingLevel = \"--nesting-level\", n.PopoverHeight = \"--popover-height\", n.InlinePopoverWidth = \"--inline-popover-width\", n.TriggerItemLeft = \"--trigger-item-left\", n.TriggerItemTop = \"--trigger-item-top\", n))(fe || {});\nconst To = ne(\"ce-popover-item-html\"), So = {\n  root: To(),\n  hidden: To(null, \"hidden\")\n};\nclass Se extends xt {\n  /**\n   * Constructs the instance\n   *\n   * @param params – instance parameters\n   * @param renderParams – popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    var o, i;\n    super(e), this.nodes = {\n      root: d.make(\"div\", So.root)\n    }, this.nodes.root.appendChild(e.element), e.name && (this.nodes.root.dataset.itemName = e.name), e.hint !== void 0 && ((o = t == null ? void 0 : t.hint) == null ? void 0 : o.enabled) !== !1 && this.addHint(this.nodes.root, {\n      ...e.hint,\n      position: ((i = t == null ? void 0 : t.hint) == null ? void 0 : i.position) || \"right\"\n    });\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(So.hidden, e);\n  }\n  /**\n   * Returns list of buttons and inputs inside custom content\n   */\n  getControls() {\n    const e = this.nodes.root.querySelectorAll(\n      `button, ${d.allInputsSelector}`\n    );\n    return Array.from(e);\n  }\n}\nclass Jo extends Oe {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover construction params\n   * @param itemsRenderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t = {}) {\n    super(), this.params = e, this.itemsRenderParams = t, this.listeners = new _e(), this.messages = {\n      nothingFound: \"Nothing found\",\n      search: \"Search\"\n    }, this.items = this.buildItems(e.items), e.messages && (this.messages = {\n      ...this.messages,\n      ...e.messages\n    }), this.nodes = {}, this.nodes.popoverContainer = d.make(\"div\", [P.popoverContainer]), this.nodes.nothingFoundMessage = d.make(\"div\", [P.nothingFoundMessage], {\n      textContent: this.messages.nothingFound\n    }), this.nodes.popoverContainer.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make(\"div\", [P.items]), this.items.forEach((o) => {\n      const i = o.getElement();\n      i !== null && this.nodes.items.appendChild(i);\n    }), this.nodes.popoverContainer.appendChild(this.nodes.items), this.listeners.on(this.nodes.popoverContainer, \"click\", (o) => this.handleClick(o)), this.nodes.popover = d.make(\"div\", [\n      P.popover,\n      this.params.class\n    ]), this.nodes.popover.appendChild(this.nodes.popoverContainer);\n  }\n  /**\n   * List of default popover items that are searchable and may have confirmation state\n   */\n  get itemsDefault() {\n    return this.items.filter((e) => e instanceof re);\n  }\n  /**\n   * Returns HTML element corresponding to the popover\n   */\n  getElement() {\n    return this.nodes.popover;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.popover.classList.add(P.popoverOpened), this.search !== void 0 && this.search.focus();\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.nodes.popover.classList.remove(P.popoverOpened), this.nodes.popover.classList.remove(P.popoverOpenTop), this.itemsDefault.forEach((e) => e.reset()), this.search !== void 0 && this.search.clear(), this.emit(G.Closed);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    var e;\n    this.items.forEach((t) => t.destroy()), this.nodes.popover.remove(), this.listeners.removeAll(), (e = this.search) == null || e.destroy();\n  }\n  /**\n   * Looks for the item by name and imitates click on it\n   *\n   * @param name - name of the item to activate\n   */\n  activateItemByName(e) {\n    const t = this.items.find((o) => o.name === e);\n    this.handleItemClick(t);\n  }\n  /**\n   * Factory method for creating popover items\n   *\n   * @param items - list of items params\n   */\n  buildItems(e) {\n    return e.map((t) => {\n      switch (t.type) {\n        case _.Separator:\n          return new Qo();\n        case _.Html:\n          return new Se(t, this.itemsRenderParams[_.Html]);\n        default:\n          return new re(t, this.itemsRenderParams[_.Default]);\n      }\n    });\n  }\n  /**\n   * Retrieves popover item that is the target of the specified event\n   *\n   * @param event - event to retrieve popover item from\n   */\n  getTargetItem(e) {\n    return this.items.filter((t) => t instanceof re || t instanceof Se).find((t) => {\n      const o = t.getElement();\n      return o === null ? !1 : e.composedPath().includes(o);\n    });\n  }\n  /**\n   * Handles popover item click\n   *\n   * @param item - item to handle click of\n   */\n  handleItemClick(e) {\n    if (!(\"isDisabled\" in e && e.isDisabled)) {\n      if (e.hasChildren) {\n        this.showNestedItems(e), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick();\n        return;\n      }\n      this.itemsDefault.filter((t) => t !== e).forEach((t) => t.reset()), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick(), this.toggleItemActivenessIfNeeded(e), e.closeOnActivate && (this.hide(), this.emit(G.ClosedOnActivate));\n    }\n  }\n  /**\n   * Handles clicks inside popover\n   *\n   * @param event - item to handle click of\n   */\n  handleClick(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.handleItemClick(t);\n  }\n  /**\n   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.\n   *\n   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.\n   * (All the other items with the same key get inactive, and the item gets active)\n   *\n   * @param clickedItem - popover item that was clicked\n   */\n  toggleItemActivenessIfNeeded(e) {\n    if (e instanceof re && (e.toggle === !0 && e.toggleActive(), typeof e.toggle == \"string\")) {\n      const t = this.itemsDefault.filter((o) => o.toggle === e.toggle);\n      if (t.length === 1) {\n        e.toggleActive();\n        return;\n      }\n      t.forEach((o) => {\n        o.toggleActive(o === e);\n      });\n    }\n  }\n}\nvar Ue = /* @__PURE__ */ ((n) => (n.Search = \"search\", n))(Ue || {});\nconst st = ne(\"cdx-search-field\"), rt = {\n  wrapper: st(),\n  icon: st(\"icon\"),\n  input: st(\"input\")\n};\nclass ls extends Oe {\n  /**\n   * @param options - available config\n   * @param options.items - searchable items list\n   * @param options.placeholder - input placeholder\n   */\n  constructor({ items: e, placeholder: t }) {\n    super(), this.listeners = new _e(), this.items = e, this.wrapper = d.make(\"div\", rt.wrapper);\n    const o = d.make(\"div\", rt.icon, {\n      innerHTML: os\n    });\n    this.input = d.make(\"input\", rt.input, {\n      placeholder: t,\n      /**\n       * Used to prevent focusing on the input by Tab key\n       * (Popover in the Toolbar lays below the blocks,\n       * so Tab in the last block will focus this hidden input if this property is not set)\n       */\n      tabIndex: -1\n    }), this.wrapper.appendChild(o), this.wrapper.appendChild(this.input), this.listeners.on(this.input, \"input\", () => {\n      this.searchQuery = this.input.value, this.emit(Ue.Search, {\n        query: this.searchQuery,\n        items: this.foundItems\n      });\n    });\n  }\n  /**\n   * Returns search field element\n   */\n  getElement() {\n    return this.wrapper;\n  }\n  /**\n   * Sets focus to the input\n   */\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Clears search query and results\n   */\n  clear() {\n    this.input.value = \"\", this.searchQuery = \"\", this.emit(Ue.Search, {\n      query: \"\",\n      items: this.foundItems\n    });\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.listeners.removeAll();\n  }\n  /**\n   * Returns list of found items for the current search query\n   */\n  get foundItems() {\n    return this.items.filter((e) => this.checkItem(e));\n  }\n  /**\n   * Contains logic for checking whether passed item conforms the search query\n   *\n   * @param item - item to be checked\n   */\n  checkItem(e) {\n    var i, s;\n    const t = ((i = e.title) == null ? void 0 : i.toLowerCase()) || \"\", o = (s = this.searchQuery) == null ? void 0 : s.toLowerCase();\n    return o !== void 0 ? t.includes(o) : !1;\n  }\n}\nvar cs = Object.defineProperty, ds = Object.getOwnPropertyDescriptor, us = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ds(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && cs(e, t, i), i;\n};\nconst en = class tn extends Jo {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   * @param itemsRenderParams – popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e, t), this.nestingLevel = 0, this.nestedPopoverTriggerItem = null, this.previouslyHoveredItem = null, this.scopeElement = document.body, this.hide = () => {\n      var o;\n      super.hide(), this.destroyNestedPopoverIfExists(), (o = this.flipper) == null || o.deactivate(), this.previouslyHoveredItem = null;\n    }, this.onFlip = () => {\n      const o = this.itemsDefault.find((i) => i.isFocused);\n      o == null || o.onFocus();\n    }, this.onSearch = (o) => {\n      var a;\n      const i = o.query === \"\", s = o.items.length === 0;\n      this.items.forEach((l) => {\n        let c = !1;\n        l instanceof re ? c = !o.items.includes(l) : (l instanceof Qo || l instanceof Se) && (c = s || !i), l.toggleHidden(c);\n      }), this.toggleNothingFoundMessage(s);\n      const r = o.query === \"\" ? this.flippableElements : o.items.map((l) => l.getElement());\n      (a = this.flipper) != null && a.isActivated && (this.flipper.deactivate(), this.flipper.activate(r));\n    }, e.nestingLevel !== void 0 && (this.nestingLevel = e.nestingLevel), this.nestingLevel > 0 && this.nodes.popover.classList.add(P.popoverNested), e.scopeElement !== void 0 && (this.scopeElement = e.scopeElement), this.nodes.popoverContainer !== null && this.listeners.on(this.nodes.popoverContainer, \"mouseover\", (o) => this.handleHover(o)), e.searchable && this.addSearch(), e.flippable !== !1 && (this.flipper = new ce({\n      items: this.flippableElements,\n      focusedItemClass: L.focused,\n      allowedKeys: [\n        y.TAB,\n        y.UP,\n        y.DOWN,\n        y.ENTER\n      ]\n    }), this.flipper.onFlip(this.onFlip));\n  }\n  /**\n   * Returns true if some item inside popover is focused\n   */\n  hasFocus() {\n    return this.flipper === void 0 ? !1 : this.flipper.hasFocus();\n  }\n  /**\n   * Scroll position inside items container of the popover\n   */\n  get scrollTop() {\n    return this.nodes.items === null ? 0 : this.nodes.items.scrollTop;\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetTop() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetTop;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    var e;\n    this.nodes.popover.style.setProperty(fe.PopoverHeight, this.size.height + \"px\"), this.shouldOpenBottom || this.nodes.popover.classList.add(P.popoverOpenTop), this.shouldOpenRight || this.nodes.popover.classList.add(P.popoverOpenLeft), super.show(), (e = this.flipper) == null || e.activate(this.flippableElements);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.hide(), super.destroy();\n  }\n  /**\n   * Handles displaying nested items for the item.\n   *\n   * @param item – item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.nestedPopover !== null && this.nestedPopover !== void 0 || (this.nestedPopoverTriggerItem = e, this.showNestedPopoverForItem(e));\n  }\n  /**\n   * Handles hover events inside popover items container\n   *\n   * @param event - hover event data\n   */\n  handleHover(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.previouslyHoveredItem !== t && (this.destroyNestedPopoverIfExists(), this.previouslyHoveredItem = t, t.hasChildren && this.showNestedPopoverForItem(t));\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used for correct positioning of the nested popover\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item – item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = (o ? o.offsetTop : 0) - this.scrollTop, s = this.offsetTop + i;\n    e.style.setProperty(fe.TriggerItemTop, s + \"px\");\n  }\n  /**\n   * Destroys existing nested popover\n   */\n  destroyNestedPopoverIfExists() {\n    var e, t;\n    this.nestedPopover === void 0 || this.nestedPopover === null || (this.nestedPopover.off(G.ClosedOnActivate, this.hide), this.nestedPopover.hide(), this.nestedPopover.destroy(), this.nestedPopover.getElement().remove(), this.nestedPopover = null, (e = this.flipper) == null || e.activate(this.flippableElements), (t = this.nestedPopoverTriggerItem) == null || t.onChildrenClose());\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    var o;\n    this.nestedPopover = new tn({\n      searchable: e.isChildrenSearchable,\n      items: e.children,\n      nestingLevel: this.nestingLevel + 1,\n      flippable: e.isChildrenFlippable,\n      messages: this.messages\n    }), e.onChildrenOpen(), this.nestedPopover.on(G.ClosedOnActivate, this.hide);\n    const t = this.nestedPopover.getElement();\n    return this.nodes.popover.appendChild(t), this.setTriggerItemPosition(t, e), t.style.setProperty(fe.NestingLevel, this.nestedPopover.nestingLevel.toString()), this.nestedPopover.show(), (o = this.flipper) == null || o.deactivate(), this.nestedPopover;\n  }\n  /**\n   * Checks if popover should be opened bottom.\n   * It should happen when there is enough space below or not enough space above\n   */\n  get shouldOpenBottom() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popoverContainer.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.height, i = e.top + o, s = e.top - o, r = Math.min(window.innerHeight, t.bottom);\n    return s < t.top || i <= r;\n  }\n  /**\n   * Checks if popover should be opened left.\n   * It should happen when there is enough space in the right or not enough space in the left\n   */\n  get shouldOpenRight() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popover.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.width, i = e.right + o, s = e.left - o, r = Math.min(window.innerWidth, t.right);\n    return s < t.left || i <= r;\n  }\n  get size() {\n    var i;\n    const e = {\n      height: 0,\n      width: 0\n    };\n    if (this.nodes.popover === null)\n      return e;\n    const t = this.nodes.popover.cloneNode(!0);\n    t.style.visibility = \"hidden\", t.style.position = \"absolute\", t.style.top = \"-1000px\", t.classList.add(P.popoverOpened), (i = t.querySelector(\".\" + P.popoverNested)) == null || i.remove(), document.body.appendChild(t);\n    const o = t.querySelector(\".\" + P.popoverContainer);\n    return e.height = o.offsetHeight, e.width = o.offsetWidth, t.remove(), e;\n  }\n  /**\n   * Returns list of elements available for keyboard navigation.\n   */\n  get flippableElements() {\n    return this.items.map((t) => {\n      if (t instanceof re)\n        return t.getElement();\n      if (t instanceof Se)\n        return t.getControls();\n    }).flat().filter((t) => t != null);\n  }\n  /**\n   * Adds search to the popover\n   */\n  addSearch() {\n    this.search = new ls({\n      items: this.itemsDefault,\n      placeholder: this.messages.search\n    }), this.search.on(Ue.Search, this.onSearch);\n    const e = this.search.getElement();\n    e.classList.add(P.search), this.nodes.popoverContainer.insertBefore(e, this.nodes.popoverContainer.firstChild);\n  }\n  /**\n   * Toggles nothing found message visibility\n   *\n   * @param isDisplayed - true if the message should be displayed\n   */\n  toggleNothingFoundMessage(e) {\n    this.nodes.nothingFoundMessage.classList.toggle(P.nothingFoundMessageDisplayed, e);\n  }\n};\nus([\n  me\n], en.prototype, \"size\", 1);\nlet Bt = en;\nclass hs extends Bt {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    const t = !be();\n    super(\n      {\n        ...e,\n        class: P.popoverInline\n      },\n      {\n        [_.Default]: {\n          /**\n           * We use button instead of div here to fix bug associated with focus loss (which leads to selection change) on click in safari\n           *\n           * @todo figure out better way to solve the issue\n           */\n          wrapperTag: \"button\",\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        },\n        [_.Html]: {\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        }\n      }\n    ), this.items.forEach((o) => {\n      !(o instanceof re) && !(o instanceof Se) || o.hasChildren && o.isChildrenOpen && this.showNestedItems(o);\n    });\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetLeft() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetLeft;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nestingLevel === 0 && this.nodes.popover.style.setProperty(\n      fe.InlinePopoverWidth,\n      this.size.width + \"px\"\n    ), super.show();\n  }\n  /**\n   * Disable hover event handling.\n   * Overrides parent's class behavior\n   */\n  handleHover() {\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used to position nested popover right below clicked item\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item – item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = o ? o.offsetLeft : 0, s = this.offsetLeft + i;\n    e.style.setProperty(\n      fe.TriggerItemLeft,\n      s + \"px\"\n    );\n  }\n  /**\n   * Handles displaying nested items for the item.\n   * Overriding in order to add toggling behaviour\n   *\n   * @param item – item to toggle nested popover for\n   */\n  showNestedItems(e) {\n    if (this.nestedPopoverTriggerItem === e) {\n      this.destroyNestedPopoverIfExists(), this.nestedPopoverTriggerItem = null;\n      return;\n    }\n    super.showNestedItems(e);\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    const t = super.showNestedPopoverForItem(e);\n    return t.getElement().classList.add(P.getPopoverNestedClass(t.nestingLevel)), t;\n  }\n  /**\n   * Overrides default item click handling.\n   * Helps to close nested popover once other item is clicked.\n   *\n   * @param item - clicked item\n   */\n  handleItemClick(e) {\n    var t;\n    e !== this.nestedPopoverTriggerItem && ((t = this.nestedPopoverTriggerItem) == null || t.handleClick(), super.destroyNestedPopoverIfExists()), super.handleItemClick(e);\n  }\n}\nconst on = class xe {\n  constructor() {\n    this.scrollPosition = null;\n  }\n  /**\n   * Locks body element scroll\n   */\n  lock() {\n    pt ? this.lockHard() : document.body.classList.add(xe.CSS.scrollLocked);\n  }\n  /**\n   * Unlocks body element scroll\n   */\n  unlock() {\n    pt ? this.unlockHard() : document.body.classList.remove(xe.CSS.scrollLocked);\n  }\n  /**\n   * Locks scroll in a hard way (via setting fixed position to body element)\n   */\n  lockHard() {\n    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(\n      \"--window-scroll-offset\",\n      `${this.scrollPosition}px`\n    ), document.body.classList.add(xe.CSS.scrollLockedHard);\n  }\n  /**\n   * Unlocks hard scroll lock\n   */\n  unlockHard() {\n    document.body.classList.remove(xe.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;\n  }\n};\non.CSS = {\n  scrollLocked: \"ce-scroll-locked\",\n  scrollLockedHard: \"ce-scroll-locked--hard\"\n};\nlet ps = on;\nconst at = ne(\"ce-popover-header\"), lt = {\n  root: at(),\n  text: at(\"text\"),\n  backButton: at(\"back-button\")\n};\nclass fs {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover header params\n   */\n  constructor({ text: e, onBackButtonClick: t }) {\n    this.listeners = new _e(), this.text = e, this.onBackButtonClick = t, this.nodes = {\n      root: d.make(\"div\", [lt.root]),\n      backButton: d.make(\"button\", [lt.backButton]),\n      text: d.make(\"div\", [lt.text])\n    }, this.nodes.backButton.innerHTML = Vi, this.nodes.root.appendChild(this.nodes.backButton), this.listeners.on(this.nodes.backButton, \"click\", this.onBackButtonClick), this.nodes.text.innerText = this.text, this.nodes.root.appendChild(this.nodes.text);\n  }\n  /**\n   * Returns popover header root html element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    this.nodes.root.remove(), this.listeners.destroy();\n  }\n}\nclass gs {\n  constructor() {\n    this.history = [];\n  }\n  /**\n   * Push new popover state\n   *\n   * @param state - new state\n   */\n  push(e) {\n    this.history.push(e);\n  }\n  /**\n   * Pop last popover state\n   */\n  pop() {\n    return this.history.pop();\n  }\n  /**\n   * Title retrieved from the current state\n   */\n  get currentTitle() {\n    return this.history.length === 0 ? \"\" : this.history[this.history.length - 1].title;\n  }\n  /**\n   * Items list retrieved from the current state\n   */\n  get currentItems() {\n    return this.history.length === 0 ? [] : this.history[this.history.length - 1].items;\n  }\n  /**\n   * Returns history to initial popover state\n   */\n  reset() {\n    for (; this.history.length > 1; )\n      this.pop();\n  }\n}\nclass nn extends Jo {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   */\n  constructor(e) {\n    super(e, {\n      [_.Default]: {\n        hint: {\n          enabled: !1\n        }\n      },\n      [_.Html]: {\n        hint: {\n          enabled: !1\n        }\n      }\n    }), this.scrollLocker = new ps(), this.history = new gs(), this.isHidden = !0, this.nodes.overlay = d.make(\"div\", [P.overlay, P.overlayHidden]), this.nodes.popover.insertBefore(this.nodes.overlay, this.nodes.popover.firstChild), this.listeners.on(this.nodes.overlay, \"click\", () => {\n      this.hide();\n    }), this.history.push({ items: e.items });\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.overlay.classList.remove(P.overlayHidden), super.show(), this.scrollLocker.lock(), this.isHidden = !1;\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.isHidden || (super.hide(), this.nodes.overlay.classList.add(P.overlayHidden), this.scrollLocker.unlock(), this.history.reset(), this.isHidden = !0);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    super.destroy(), this.scrollLocker.unlock();\n  }\n  /**\n   * Handles displaying nested items for the item\n   *\n   * @param item – item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.updateItemsAndHeader(e.children, e.title), this.history.push({\n      title: e.title,\n      items: e.children\n    });\n  }\n  /**\n   * Removes rendered popover items and header and displays new ones\n   *\n   * @param items - new popover items\n   * @param title - new popover header text\n   */\n  updateItemsAndHeader(e, t) {\n    if (this.header !== null && this.header !== void 0 && (this.header.destroy(), this.header = null), t !== void 0) {\n      this.header = new fs({\n        text: t,\n        onBackButtonClick: () => {\n          this.history.pop(), this.updateItemsAndHeader(this.history.currentItems, this.history.currentTitle);\n        }\n      });\n      const o = this.header.getElement();\n      o !== null && this.nodes.popoverContainer.insertBefore(o, this.nodes.popoverContainer.firstChild);\n    }\n    this.items.forEach((o) => {\n      var i;\n      return (i = o.getElement()) == null ? void 0 : i.remove();\n    }), this.items = this.buildItems(e), this.items.forEach((o) => {\n      var s;\n      const i = o.getElement();\n      i !== null && ((s = this.nodes.items) == null || s.appendChild(i));\n    });\n  }\n}\nclass ms extends E {\n  constructor() {\n    super(...arguments), this.opened = !1, this.selection = new b(), this.popover = null, this.close = () => {\n      this.opened && (this.opened = !1, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));\n    }, this.onPopoverClose = () => {\n      this.close();\n    };\n  }\n  /**\n   * Module Events\n   */\n  get events() {\n    return {\n      opened: \"block-settings-opened\",\n      closed: \"block-settings-closed\"\n    };\n  }\n  /**\n   * Block Settings CSS\n   */\n  get CSS() {\n    return {\n      settings: \"ce-settings\"\n    };\n  }\n  /**\n   * Getter for inner popover's flipper instance\n   *\n   * @todo remove once BlockSettings becomes standalone non-module class\n   */\n  get flipper() {\n    var e;\n    if (this.popover !== null)\n      return \"flipper\" in this.popover ? (e = this.popover) == null ? void 0 : e.flipper : void 0;\n  }\n  /**\n   * Panel with block settings with 2 sections:\n   *  - Tool's Settings\n   *  - Default Settings [Move, Remove, etc]\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [this.CSS.settings]), this.nodes.wrapper.setAttribute(\"data-cy\", \"block-tunes\"), this.eventsDispatcher.on(Te, this.close);\n  }\n  /**\n   * Destroys module\n   */\n  destroy() {\n    this.removeAllNodes(), this.listeners.destroy(), this.eventsDispatcher.off(Te, this.close);\n  }\n  /**\n   * Open Block Settings pane\n   *\n   * @param targetBlock - near which Block we should open BlockSettings\n   */\n  async open(e = this.Editor.BlockManager.currentBlock) {\n    var s;\n    this.opened = !0, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();\n    const { toolTunes: t, commonTunes: o } = e.getTunes();\n    this.eventsDispatcher.emit(this.events.opened);\n    const i = be() ? nn : Bt;\n    this.popover = new i({\n      searchable: !0,\n      items: await this.getTunesItems(e, o, t),\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\"),\n        search: z.ui(K.ui.popover, \"Filter\")\n      }\n    }), this.popover.on(G.Closed, this.onPopoverClose), (s = this.nodes.wrapper) == null || s.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Returns list of items to be displayed in block tunes menu.\n   * Merges tool specific tunes, conversion menu and common tunes in one list in predefined order\n   *\n   * @param currentBlock –  block we are about to open block tunes for\n   * @param commonTunes – common tunes\n   * @param toolTunes - tool specific tunes\n   */\n  async getTunesItems(e, t, o) {\n    const i = [];\n    o !== void 0 && o.length > 0 && (i.push(...o), i.push({\n      type: _.Separator\n    }));\n    const s = Array.from(this.Editor.Tools.blockTools.values()), a = (await Yo(e, s)).reduce((l, c) => (c.toolbox.forEach((u) => {\n      l.push({\n        icon: u.icon,\n        title: z.t(K.toolNames, u.title),\n        name: c.name,\n        closeOnActivate: !0,\n        onActivate: async () => {\n          const { BlockManager: h, Caret: p, Toolbar: g } = this.Editor, f = await h.convert(e, c.name, u.data);\n          g.close(), p.setToBlock(f, p.positions.END);\n        }\n      });\n    }), l), []);\n    return a.length > 0 && (i.push({\n      icon: Go,\n      name: \"convert-to\",\n      title: z.ui(K.ui.popover, \"Convert to\"),\n      children: {\n        searchable: !0,\n        items: a\n      }\n    }), i.push({\n      type: _.Separator\n    })), i.push(...t), i.map((l) => this.resolveTuneAliases(l));\n  }\n  /**\n   * Resolves aliases in tunes menu items\n   *\n   * @param item - item with resolved aliases\n   */\n  resolveTuneAliases(e) {\n    if (e.type === _.Separator || e.type === _.Html)\n      return e;\n    const t = Yi(e, { label: \"title\" });\n    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;\n  }\n}\nvar sn = { exports: {} };\n/*!\n * Library for handling keyboard shortcuts\n * @copyright CodeX (https://codex.so)\n * @license MIT\n * @author CodeX (https://codex.so)\n * @version 1.2.0\n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      function s(l, c) {\n        for (var u = 0; u < c.length; u++) {\n          var h = c[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);\n        }\n      }\n      function r(l, c, u) {\n        return c && s(l.prototype, c), u && s(l, u), l;\n      }\n      i.r(o);\n      var a = function() {\n        function l(c) {\n          var u = this;\n          (function(h, p) {\n            if (!(h instanceof p))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, l), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {\n            u.execute(h);\n          }, this.element.addEventListener(\"keydown\", this.executeShortcut, !1);\n        }\n        return r(l, null, [{ key: \"supportedCommands\", get: function() {\n          return { SHIFT: [\"SHIFT\"], CMD: [\"CMD\", \"CONTROL\", \"COMMAND\", \"WINDOWS\", \"CTRL\"], ALT: [\"ALT\", \"OPTION\"] };\n        } }, { key: \"keyCodes\", get: function() {\n          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, \".\": 190 };\n        } }]), r(l, [{ key: \"parseShortcutName\", value: function(c) {\n          c = c.split(\"+\");\n          for (var u = 0; u < c.length; u++) {\n            c[u] = c[u].toUpperCase();\n            var h = !1;\n            for (var p in l.supportedCommands)\n              if (l.supportedCommands[p].includes(c[u])) {\n                h = this.commands[p] = !0;\n                break;\n              }\n            h || (this.keys[c[u]] = !0);\n          }\n          for (var g in l.supportedCommands)\n            this.commands[g] || (this.commands[g] = !1);\n        } }, { key: \"execute\", value: function(c) {\n          var u, h = { CMD: c.ctrlKey || c.metaKey, SHIFT: c.shiftKey, ALT: c.altKey }, p = !0;\n          for (u in this.commands)\n            this.commands[u] !== h[u] && (p = !1);\n          var g, f = !0;\n          for (g in this.keys)\n            f = f && c.keyCode === l.keyCodes[g];\n          p && f && this.callback(c);\n        } }, { key: \"remove\", value: function() {\n          this.element.removeEventListener(\"keydown\", this.executeShortcut);\n        } }]), l;\n      }();\n      o.default = a;\n    }]).default;\n  });\n})(sn);\nvar bs = sn.exports;\nconst vs = /* @__PURE__ */ Ke(bs);\nclass ks {\n  constructor() {\n    this.registeredShortcuts = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register shortcut\n   *\n   * @param shortcut - shortcut options\n   */\n  add(e) {\n    if (this.findShortcut(e.on, e.name))\n      throw Error(\n        `Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`\n      );\n    const o = new vs({\n      name: e.name,\n      on: e.on,\n      callback: e.handler\n    }), i = this.registeredShortcuts.get(e.on) || [];\n    this.registeredShortcuts.set(e.on, [...i, o]);\n  }\n  /**\n   * Remove shortcut\n   *\n   * @param element - Element shortcut is set for\n   * @param name - shortcut name\n   */\n  remove(e, t) {\n    const o = this.findShortcut(e, t);\n    if (!o)\n      return;\n    o.remove();\n    const i = this.registeredShortcuts.get(e);\n    this.registeredShortcuts.set(e, i.filter((s) => s !== o));\n  }\n  /**\n   * Get Shortcut instance if exist\n   *\n   * @param element - Element shorcut is set for\n   * @param shortcut - shortcut name\n   * @returns {number} index - shortcut index if exist\n   */\n  findShortcut(e, t) {\n    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);\n  }\n}\nconst ge = new ks();\nvar ys = Object.defineProperty, ws = Object.getOwnPropertyDescriptor, rn = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ws(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ys(e, t, i), i;\n}, Le = /* @__PURE__ */ ((n) => (n.Opened = \"toolbox-opened\", n.Closed = \"toolbox-closed\", n.BlockAdded = \"toolbox-block-added\", n))(Le || {});\nconst Ct = class an extends Oe {\n  /**\n   * Toolbox constructor\n   *\n   * @param options - available parameters\n   * @param options.api - Editor API methods\n   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not\n   */\n  constructor({ api: e, tools: t, i18nLabels: o }) {\n    super(), this.opened = !1, this.listeners = new _e(), this.popover = null, this.handleMobileLayoutToggle = () => {\n      this.destroyPopover(), this.initPopover();\n    }, this.onPopoverClose = () => {\n      this.opened = !1, this.emit(\n        \"toolbox-closed\"\n        /* Closed */\n      );\n    }, this.api = e, this.tools = t, this.i18nLabels = o, this.enableShortcuts(), this.nodes = {\n      toolbox: d.make(\"div\", an.CSS.toolbox)\n    }, this.initPopover(), this.nodes.toolbox.setAttribute(\"data-cy\", \"toolbox\"), this.api.events.on(Te, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Returns True if Toolbox is Empty and nothing to show\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    return this.toolsToBeDisplayed.length === 0;\n  }\n  /**\n   * CSS styles\n   */\n  static get CSS() {\n    return {\n      toolbox: \"ce-toolbox\"\n    };\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.toolbox;\n  }\n  /**\n   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button\n   */\n  hasFocus() {\n    if (this.popover !== null)\n      return \"hasFocus\" in this.popover ? this.popover.hasFocus() : void 0;\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    var e;\n    super.destroy(), this.nodes && this.nodes.toolbox && this.nodes.toolbox.remove(), this.removeAllShortcuts(), (e = this.popover) == null || e.off(G.Closed, this.onPopoverClose), this.listeners.destroy(), this.api.events.off(Te, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Toolbox Tool's button click handler\n   *\n   * @param toolName - tool type to be activated\n   * @param blockDataOverrides - Block data predefined by the activated Toolbox item\n   */\n  toolButtonActivated(e, t) {\n    this.insertNewBlock(e, t);\n  }\n  /**\n   * Open Toolbox with Tools\n   */\n  open() {\n    var e;\n    this.isEmpty || ((e = this.popover) == null || e.show(), this.opened = !0, this.emit(\n      \"toolbox-opened\"\n      /* Opened */\n    ));\n  }\n  /**\n   * Close Toolbox\n   */\n  close() {\n    var e;\n    (e = this.popover) == null || e.hide(), this.opened = !1, this.emit(\n      \"toolbox-closed\"\n      /* Closed */\n    );\n  }\n  /**\n   * Close Toolbox\n   */\n  toggle() {\n    this.opened ? this.close() : this.open();\n  }\n  /**\n   * Creates toolbox popover and appends it inside wrapper element\n   */\n  initPopover() {\n    var t;\n    const e = be() ? nn : Bt;\n    this.popover = new e({\n      scopeElement: this.api.ui.nodes.redactor,\n      searchable: !0,\n      messages: {\n        nothingFound: this.i18nLabels.nothingFound,\n        search: this.i18nLabels.filter\n      },\n      items: this.toolboxItemsToBeDisplayed\n    }), this.popover.on(G.Closed, this.onPopoverClose), (t = this.nodes.toolbox) == null || t.append(this.popover.getElement());\n  }\n  /**\n   * Destroys popover instance and removes it from DOM\n   */\n  destroyPopover() {\n    this.popover !== null && (this.popover.hide(), this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover = null), this.nodes.toolbox !== null && (this.nodes.toolbox.innerHTML = \"\");\n  }\n  get toolsToBeDisplayed() {\n    const e = [];\n    return this.tools.forEach((t) => {\n      t.toolbox && e.push(t);\n    }), e;\n  }\n  get toolboxItemsToBeDisplayed() {\n    const e = (t, o, i = !0) => ({\n      icon: t.icon,\n      title: z.t(K.toolNames, t.title || je(o.name)),\n      name: o.name,\n      onActivate: () => {\n        this.toolButtonActivated(o.name, t.data);\n      },\n      secondaryLabel: o.shortcut && i ? vt(o.shortcut) : \"\"\n    });\n    return this.toolsToBeDisplayed.reduce((t, o) => (Array.isArray(o.toolbox) ? o.toolbox.forEach((i, s) => {\n      t.push(e(i, o, s === 0));\n    }) : o.toolbox !== void 0 && t.push(e(o.toolbox, o)), t), []);\n  }\n  /**\n   * Iterate all tools and enable theirs shortcuts if specified\n   */\n  enableShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && this.enableShortcutForTool(e.name, t);\n    });\n  }\n  /**\n   * Enable shortcut Block Tool implemented shortcut\n   *\n   * @param {string} toolName - Tool name\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcutForTool(e, t) {\n    ge.add({\n      name: t,\n      on: this.api.ui.nodes.redactor,\n      handler: async (o) => {\n        o.preventDefault();\n        const i = this.api.blocks.getCurrentBlockIndex(), s = this.api.blocks.getBlockByIndex(i);\n        if (s)\n          try {\n            const r = await this.api.blocks.convert(s.id, e);\n            this.api.caret.setToBlock(r, \"end\");\n            return;\n          } catch {\n          }\n        this.insertNewBlock(e);\n      }\n    });\n  }\n  /**\n   * Removes all added shortcuts\n   * Fired when the Read-Only mode is activated\n   */\n  removeAllShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && ge.remove(this.api.ui.nodes.redactor, t);\n    });\n  }\n  /**\n   * Inserts new block\n   * Can be called when button clicked on Toolbox or by ShortcutData\n   *\n   * @param {string} toolName - Tool name\n   * @param blockDataOverrides - predefined Block data\n   */\n  async insertNewBlock(e, t) {\n    const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);\n    if (!i)\n      return;\n    const s = i.isEmpty ? o : o + 1;\n    let r;\n    if (t) {\n      const l = await this.api.blocks.composeBlockData(e);\n      r = Object.assign(l, t);\n    }\n    const a = this.api.blocks.insert(\n      e,\n      r,\n      void 0,\n      s,\n      void 0,\n      i.isEmpty\n    );\n    a.call(ee.APPEND_CALLBACK), this.api.caret.setToBlock(s), this.emit(\"toolbox-block-added\", {\n      block: a\n    }), this.api.toolbar.close();\n  }\n};\nrn([\n  me\n], Ct.prototype, \"toolsToBeDisplayed\", 1);\nrn([\n  me\n], Ct.prototype, \"toolboxItemsToBeDisplayed\", 1);\nlet Es = Ct;\nconst ln = \"block hovered\";\nasync function xs(n, e) {\n  const t = navigator.keyboard;\n  if (!t)\n    return e;\n  try {\n    return (await t.getLayoutMap()).get(n) || e;\n  } catch (o) {\n    return console.error(o), e;\n  }\n}\nclass Bs extends E {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.toolboxInstance = null;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      toolbar: \"ce-toolbar\",\n      content: \"ce-toolbar__content\",\n      actions: \"ce-toolbar__actions\",\n      actionsOpened: \"ce-toolbar__actions--opened\",\n      toolbarOpened: \"ce-toolbar--opened\",\n      openedToolboxHolderModifier: \"codex-editor--toolbox-opened\",\n      plusButton: \"ce-toolbar__plus\",\n      plusButtonShortcut: \"ce-toolbar__plus-shortcut\",\n      settingsToggler: \"ce-toolbar__settings-btn\",\n      settingsTogglerHidden: \"ce-toolbar__settings-btn--hidden\"\n    };\n  }\n  /**\n   * Returns the Toolbar opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);\n  }\n  /**\n   * Public interface for accessing the Toolbox\n   */\n  get toolbox() {\n    var e;\n    return {\n      opened: (e = this.toolboxInstance) == null ? void 0 : e.opened,\n      close: () => {\n        var t;\n        (t = this.toolboxInstance) == null || t.close();\n      },\n      open: () => {\n        if (this.toolboxInstance === null) {\n          S(\"toolbox.open() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();\n      },\n      toggle: () => {\n        if (this.toolboxInstance === null) {\n          S(\"toolbox.toggle() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.toolboxInstance.toggle();\n      },\n      hasFocus: () => {\n        var t;\n        return (t = this.toolboxInstance) == null ? void 0 : t.hasFocus();\n      }\n    };\n  }\n  /**\n   * Block actions appearance manipulations\n   */\n  get blockActions() {\n    return {\n      hide: () => {\n        this.nodes.actions.classList.remove(this.CSS.actionsOpened);\n      },\n      show: () => {\n        this.nodes.actions.classList.add(this.CSS.actionsOpened);\n      }\n    };\n  }\n  /**\n   * Methods for working with Block Tunes toggler\n   */\n  get blockTunesToggler() {\n    return {\n      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),\n      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)\n    };\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {\n      this.drawUI(), this.enableModuleBindings();\n    }, { timeout: 2e3 });\n  }\n  /**\n   * Move Toolbar to the passed (or current) Block\n   *\n   * @param block - block to move Toolbar near it\n   */\n  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {\n    if (this.toolboxInstance === null) {\n      S(\"Can't open Toolbar since Editor initialization is not finished yet\", \"warn\");\n      return;\n    }\n    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)\n      return;\n    this.hoveredBlock = e;\n    const t = e.holder, { isMobile: o } = this.Editor.UI;\n    let i;\n    const s = 20, r = e.firstInput, a = t.getBoundingClientRect(), l = r !== void 0 ? r.getBoundingClientRect() : null, c = l !== null ? l.top - a.top : null, u = c !== null ? c > s : void 0;\n    if (o)\n      i = t.offsetTop + t.offsetHeight;\n    else if (r === void 0 || u) {\n      const h = parseInt(window.getComputedStyle(e.pluginsContent).paddingTop);\n      i = t.offsetTop + h;\n    } else {\n      const h = li(r), p = parseInt(window.getComputedStyle(this.nodes.plusButton).height, 10), g = 8;\n      i = t.offsetTop + h - p + g + c;\n    }\n    this.nodes.wrapper.style.top = `${Math.floor(i)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();\n  }\n  /**\n   * Close the Toolbar\n   */\n  close() {\n    var e, t;\n    this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t = this.toolboxInstance) == null || t.close(), this.Editor.BlockSettings.close(), this.reset());\n  }\n  /**\n   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion\n   */\n  reset() {\n    this.nodes.wrapper.style.top = \"unset\";\n  }\n  /**\n   * Open Toolbar with Plus Button and Actions\n   *\n   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.\n   *                                     This flag allows to open Toolbar without Actions.\n   */\n  open(e = !0) {\n    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();\n  }\n  /**\n   * Draws Toolbar elements\n   */\n  async make() {\n    this.nodes.wrapper = d.make(\"div\", this.CSS.toolbar), [\"content\", \"actions\"].forEach((s) => {\n      this.nodes[s] = d.make(\"div\", this.CSS[s]);\n    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make(\"div\", this.CSS.plusButton, {\n      innerHTML: ts\n    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, \"click\", () => {\n      $e(!0), this.plusButtonClicked();\n    }, !1);\n    const e = d.make(\"div\");\n    e.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, \"Add\"))), e.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: \"/\"\n    })), ze(this.nodes.plusButton, e, {\n      hidingDelay: 400\n    }), this.nodes.settingsToggler = d.make(\"span\", this.CSS.settingsToggler, {\n      innerHTML: es\n    }), d.append(this.nodes.actions, this.nodes.settingsToggler);\n    const t = d.make(\"div\"), o = d.text(z.ui(K.ui.blockTunes.toggler, \"Click to tune\")), i = await xs(\"Slash\", \"/\");\n    t.appendChild(o), t.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: vt(`CMD + ${i}`)\n    })), ze(this.nodes.settingsToggler, t, {\n      hidingDelay: 400\n    }), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Creates the Toolbox instance and return it's rendered element\n   */\n  makeToolbox() {\n    return this.toolboxInstance = new Es({\n      api: this.Editor.API.methods,\n      tools: this.Editor.Tools.blockTools,\n      i18nLabels: {\n        filter: z.ui(K.ui.popover, \"Filter\"),\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\")\n      }\n    }), this.toolboxInstance.on(Le.Opened, () => {\n      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Le.Closed, () => {\n      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Le.BlockAdded, ({ block: e }) => {\n      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);\n      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));\n    }), this.toolboxInstance.getElement();\n  }\n  /**\n   * Handler for Plus Button\n   */\n  plusButtonClicked() {\n    var e;\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();\n  }\n  /**\n   * Enable bindings\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, \"mousedown\", (e) => {\n      var t;\n      e.stopPropagation(), this.settingsTogglerClicked(), (t = this.toolboxInstance) != null && t.opened && this.toolboxInstance.close(), $e(!0);\n    }, !0), be() || this.eventsDispatcher.on(ln, (e) => {\n      var t;\n      this.Editor.BlockSettings.opened || (t = this.toolboxInstance) != null && t.opened || this.moveAndOpen(e.block);\n    });\n  }\n  /**\n   * Disable bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Clicks on the Block Settings toggler\n   */\n  settingsTogglerClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);\n  }\n  /**\n   * Draws Toolbar UI\n   *\n   * Toolbar contains BlockSettings and Toolbox.\n   * That's why at first we draw its components and then Toolbar itself\n   *\n   * Steps:\n   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on\n   *  - Make itself and append dependent nodes to itself\n   *\n   */\n  drawUI() {\n    this.Editor.BlockSettings.make(), this.make();\n  }\n  /**\n   * Removes all created and saved HTMLElements\n   * It is used in Read-Only mode\n   */\n  destroy() {\n    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();\n  }\n}\nvar ae = /* @__PURE__ */ ((n) => (n[n.Block = 0] = \"Block\", n[n.Inline = 1] = \"Inline\", n[n.Tune = 2] = \"Tune\", n))(ae || {}), Pe = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.Toolbox = \"toolbox\", n.EnabledInlineTools = \"inlineToolbar\", n.EnabledBlockTunes = \"tunes\", n.Config = \"config\", n))(Pe || {}), cn = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.SanitizeConfig = \"sanitize\", n))(cn || {}), pe = /* @__PURE__ */ ((n) => (n.IsEnabledLineBreaks = \"enableLineBreaks\", n.Toolbox = \"toolbox\", n.ConversionConfig = \"conversionConfig\", n.IsReadOnlySupported = \"isReadOnlySupported\", n.PasteConfig = \"pasteConfig\", n))(pe || {}), We = /* @__PURE__ */ ((n) => (n.IsInline = \"isInline\", n.Title = \"title\", n.IsReadOnlySupported = \"isReadOnlySupported\", n))(We || {}), mt = /* @__PURE__ */ ((n) => (n.IsTune = \"isTune\", n))(mt || {});\nclass Tt {\n  /**\n   * @class\n   * @param {ConstructorOptions} options - Constructor options\n   */\n  constructor({\n    name: e,\n    constructable: t,\n    config: o,\n    api: i,\n    isDefault: s,\n    isInternal: r = !1,\n    defaultPlaceholder: a\n  }) {\n    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = s, this.isInternal = r, this.defaultPlaceholder = a;\n  }\n  /**\n   * Returns Tool user configuration\n   */\n  get settings() {\n    const e = this.config.config || {};\n    return this.isDefault && !(\"placeholder\" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;\n  }\n  /**\n   * Calls Tool's reset method\n   */\n  reset() {\n    if (A(this.constructable.reset))\n      return this.constructable.reset();\n  }\n  /**\n   * Calls Tool's prepare method\n   */\n  prepare() {\n    if (A(this.constructable.prepare))\n      return this.constructable.prepare({\n        toolName: this.name,\n        config: this.settings\n      });\n  }\n  /**\n   * Returns shortcut for Tool (internal or specified by user)\n   */\n  get shortcut() {\n    const e = this.constructable.shortcut;\n    return this.config.shortcut || e;\n  }\n  /**\n   * Returns Tool's sanitizer configuration\n   */\n  get sanitizeConfig() {\n    return this.constructable.sanitize || {};\n  }\n  /**\n   * Returns true if Tools is inline\n   */\n  isInline() {\n    return this.type === ae.Inline;\n  }\n  /**\n   * Returns true if Tools is block\n   */\n  isBlock() {\n    return this.type === ae.Block;\n  }\n  /**\n   * Returns true if Tools is tune\n   */\n  isTune() {\n    return this.type === ae.Tune;\n  }\n}\nclass Cs extends E {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.CSS = {\n      inlineToolbar: \"ce-inline-toolbar\"\n    }, this.opened = !1, this.popover = null, this.toolbarVerticalMargin = be() ? 20 : 6, this.tools = /* @__PURE__ */ new Map(), window.requestIdleCallback(() => {\n      this.make();\n    }, { timeout: 2e3 });\n  }\n  /**\n   *  Moving / appearance\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Shows Inline Toolbar if something is selected\n   *\n   * @param [needToClose] - pass true to close toolbar if it is not allowed.\n   *                                  Avoid to use it just for closing IT, better call .close() clearly.\n   */\n  async tryToShow(e = !1) {\n    e && this.close(), this.allowedToShow() && (await this.open(), this.Editor.Toolbar.close());\n  }\n  /**\n   * Hides Inline Toolbar\n   */\n  close() {\n    var e, t;\n    if (this.opened) {\n      for (const [o, i] of this.tools) {\n        const s = this.getToolShortcut(o.name);\n        s !== void 0 && ge.remove(this.Editor.UI.nodes.redactor, s), A(i.clear) && i.clear();\n      }\n      this.tools = /* @__PURE__ */ new Map(), this.reset(), this.opened = !1, (e = this.popover) == null || e.hide(), (t = this.popover) == null || t.destroy(), this.popover = null;\n    }\n  }\n  /**\n   * Check if node is contained by Inline Toolbar\n   *\n   * @param {Node} node — node to check\n   */\n  containsNode(e) {\n    return this.nodes.wrapper === void 0 ? !1 : this.nodes.wrapper.contains(e);\n  }\n  /**\n   * Removes UI and its components\n   */\n  destroy() {\n    var e;\n    this.removeAllNodes(), (e = this.popover) == null || e.destroy(), this.popover = null;\n  }\n  /**\n   * Making DOM\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.inlineToolbar,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.wrapper.setAttribute(\"data-cy\", \"inline-toolbar\"), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Shows Inline Toolbar\n   */\n  async open() {\n    var t;\n    if (this.opened)\n      return;\n    this.opened = !0, this.popover !== null && this.popover.destroy(), this.createToolsInstances();\n    const e = await this.getPopoverItems();\n    this.popover = new hs({\n      items: e,\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\"),\n        search: z.ui(K.ui.popover, \"Filter\")\n      }\n    }), this.move(this.popover.size.width), (t = this.nodes.wrapper) == null || t.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Move Toolbar to the selected text\n   *\n   * @param popoverWidth - width of the toolbar popover\n   */\n  move(e) {\n    const t = b.rect, o = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), i = {\n      x: t.x - o.x,\n      y: t.y + t.height - // + window.scrollY\n      o.top + this.toolbarVerticalMargin\n    };\n    i.x + e + o.x > this.Editor.UI.contentRect.right && (i.x = this.Editor.UI.contentRect.right - e - o.x), this.nodes.wrapper.style.left = Math.floor(i.x) + \"px\", this.nodes.wrapper.style.top = Math.floor(i.y) + \"px\";\n  }\n  /**\n   * Clear orientation classes and reset position\n   */\n  reset() {\n    this.nodes.wrapper.style.left = \"0\", this.nodes.wrapper.style.top = \"0\";\n  }\n  /**\n   * Need to show Inline Toolbar or not\n   */\n  allowedToShow() {\n    const e = [\"IMG\", \"INPUT\"], t = b.get(), o = b.text;\n    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)\n      return !1;\n    const i = d.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;\n    if (i === null || t !== null && e.includes(i.tagName))\n      return !1;\n    const s = this.Editor.BlockManager.getBlock(t.anchorNode);\n    return !s || this.getTools().some((c) => s.tool.inlineTools.has(c.name)) === !1 ? !1 : i.closest(\"[contenteditable]\") !== null;\n  }\n  /**\n   *  Working with Tools\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Returns tools that are available for current block\n   *\n   * Used to check if Inline Toolbar could be shown\n   * and to render tools in the Inline Toolbar\n   */\n  getTools() {\n    const e = this.Editor.BlockManager.currentBlock;\n    return e ? Array.from(e.tool.inlineTools.values()).filter((o) => !(this.Editor.ReadOnly.isEnabled && o.isReadOnlySupported !== !0)) : [];\n  }\n  /**\n   * Constructs tools instances and saves them to this.tools\n   */\n  createToolsInstances() {\n    this.tools = /* @__PURE__ */ new Map(), this.getTools().forEach((t) => {\n      const o = t.create();\n      this.tools.set(t, o);\n    });\n  }\n  /**\n   * Returns Popover Items for tools segregated by their appearance type: regular items and custom html elements.\n   */\n  async getPopoverItems() {\n    const e = [];\n    let t = 0;\n    for (const [o, i] of this.tools) {\n      const s = await i.render(), r = this.getToolShortcut(o.name);\n      if (r !== void 0)\n        try {\n          this.enableShortcuts(o.name, r);\n        } catch {\n        }\n      const a = r !== void 0 ? vt(r) : void 0, l = z.t(\n        K.toolNames,\n        o.title || je(o.name)\n      );\n      [s].flat().forEach((c) => {\n        var h, p;\n        const u = {\n          name: o.name,\n          onActivate: () => {\n            this.toolClicked(i);\n          },\n          hint: {\n            title: l,\n            description: a\n          }\n        };\n        if (d.isElement(c)) {\n          const g = {\n            ...u,\n            element: c,\n            type: _.Html\n          };\n          if (A(i.renderActions)) {\n            const f = i.renderActions();\n            g.children = {\n              isOpen: (h = i.checkState) == null ? void 0 : h.call(i, b.get()),\n              /** Disable keyboard navigation in actions, as it might conflict with enter press handling */\n              isFlippable: !1,\n              items: [\n                {\n                  type: _.Html,\n                  element: f\n                }\n              ]\n            };\n          } else\n            (p = i.checkState) == null || p.call(i, b.get());\n          e.push(g);\n        } else if (c.type === _.Html)\n          e.push({\n            ...u,\n            ...c,\n            type: _.Html\n          });\n        else if (c.type === _.Separator)\n          e.push({\n            type: _.Separator\n          });\n        else {\n          const g = {\n            ...u,\n            ...c,\n            type: _.Default\n          };\n          \"children\" in g && t !== 0 && e.push({\n            type: _.Separator\n          }), e.push(g), \"children\" in g && t < this.tools.size - 1 && e.push({\n            type: _.Separator\n          });\n        }\n      }), t++;\n    }\n    return e;\n  }\n  /**\n   * Get shortcut name for tool\n   *\n   * @param toolName — Tool name\n   */\n  getToolShortcut(e) {\n    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;\n    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][cn.Shortcut] : o == null ? void 0 : o.shortcut;\n  }\n  /**\n   * Enable Tool shortcut with Editor Shortcuts Module\n   *\n   * @param toolName - tool name\n   * @param shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcuts(e, t) {\n    ge.add({\n      name: t,\n      handler: (o) => {\n        var s;\n        const { currentBlock: i } = this.Editor.BlockManager;\n        i && i.tool.enabledInlineTools && (o.preventDefault(), (s = this.popover) == null || s.activateItemByName(e));\n      },\n      /**\n       * We need to bind shortcut to the document to make it work in read-only mode\n       */\n      on: document\n    });\n  }\n  /**\n   * Inline Tool button clicks\n   *\n   * @param tool - Tool's instance\n   */\n  toolClicked(e) {\n    var o;\n    const t = b.range;\n    (o = e.surround) == null || o.call(e, t), this.checkToolsState();\n  }\n  /**\n   * Check Tools` state by selection\n   */\n  checkToolsState() {\n    var e;\n    (e = this.tools) == null || e.forEach((t) => {\n      var o;\n      (o = t.checkState) == null || o.call(t, b.get());\n    });\n  }\n  /**\n   * Get inline tools tools\n   * Tools that has isInline is true\n   */\n  get inlineTools() {\n    const e = {};\n    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {\n      e[t] = o.create();\n    }), e;\n  }\n}\nfunction dn() {\n  const n = window.getSelection();\n  if (n === null)\n    return [null, 0];\n  let e = n.focusNode, t = n.focusOffset;\n  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], t = e.textContent.length)), [e, t]);\n}\nfunction un(n, e, t, o) {\n  const i = document.createRange();\n  o === \"left\" ? (i.setStart(n, 0), i.setEnd(e, t)) : (i.setStart(e, t), i.setEnd(n, n.childNodes.length));\n  const s = i.cloneContents(), r = document.createElement(\"div\");\n  r.appendChild(s);\n  const a = r.textContent || \"\";\n  return ai(a);\n}\nfunction Ne(n) {\n  const e = d.getDeepestNode(n);\n  if (e === null || d.isEmpty(n))\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === 0;\n  if (d.isEmpty(n))\n    return !0;\n  const [t, o] = dn();\n  return t === null ? !1 : un(n, t, o, \"left\");\n}\nfunction Re(n) {\n  const e = d.getDeepestNode(n, !0);\n  if (e === null)\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === e.value.length;\n  const [t, o] = dn();\n  return t === null ? !1 : un(n, t, o, \"right\");\n}\nvar hn = {}, St = {}, Xe = {}, de = {}, It = {}, Ot = {};\nObject.defineProperty(Ot, \"__esModule\", { value: !0 });\nOt.allInputsSelector = Ts;\nfunction Ts() {\n  var n = [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"];\n  return \"[contenteditable=true], textarea, input:not([type]), \" + n.map(function(e) {\n    return 'input[type=\"'.concat(e, '\"]');\n  }).join(\", \");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.allInputsSelector = void 0;\n  var e = Ot;\n  Object.defineProperty(n, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return e.allInputsSelector;\n  } });\n})(It);\nvar ue = {}, _t = {};\nObject.defineProperty(_t, \"__esModule\", { value: !0 });\n_t.isNativeInput = Ss;\nfunction Ss(n) {\n  var e = [\n    \"INPUT\",\n    \"TEXTAREA\"\n  ];\n  return n && n.tagName ? e.includes(n.tagName) : !1;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isNativeInput = void 0;\n  var e = _t;\n  Object.defineProperty(n, \"isNativeInput\", { enumerable: !0, get: function() {\n    return e.isNativeInput;\n  } });\n})(ue);\nvar pn = {}, Mt = {};\nObject.defineProperty(Mt, \"__esModule\", { value: !0 });\nMt.append = Is;\nfunction Is(n, e) {\n  Array.isArray(e) ? e.forEach(function(t) {\n    n.appendChild(t);\n  }) : n.appendChild(e);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.append = void 0;\n  var e = Mt;\n  Object.defineProperty(n, \"append\", { enumerable: !0, get: function() {\n    return e.append;\n  } });\n})(pn);\nvar At = {}, Lt = {};\nObject.defineProperty(Lt, \"__esModule\", { value: !0 });\nLt.blockElements = Os;\nfunction Os() {\n  return [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"canvas\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"noscript\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tr\",\n    \"tfoot\",\n    \"ul\",\n    \"video\"\n  ];\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.blockElements = void 0;\n  var e = Lt;\n  Object.defineProperty(n, \"blockElements\", { enumerable: !0, get: function() {\n    return e.blockElements;\n  } });\n})(At);\nvar fn = {}, Pt = {};\nObject.defineProperty(Pt, \"__esModule\", { value: !0 });\nPt.calculateBaseline = _s;\nfunction _s(n) {\n  var e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2, c = r + s + i + l + a;\n  return c;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.calculateBaseline = void 0;\n  var e = Pt;\n  Object.defineProperty(n, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return e.calculateBaseline;\n  } });\n})(fn);\nvar gn = {}, Nt = {}, Rt = {}, Dt = {};\nObject.defineProperty(Dt, \"__esModule\", { value: !0 });\nDt.isContentEditable = Ms;\nfunction Ms(n) {\n  return n.contentEditable === \"true\";\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isContentEditable = void 0;\n  var e = Dt;\n  Object.defineProperty(n, \"isContentEditable\", { enumerable: !0, get: function() {\n    return e.isContentEditable;\n  } });\n})(Rt);\nObject.defineProperty(Nt, \"__esModule\", { value: !0 });\nNt.canSetCaret = Ps;\nvar As = ue, Ls = Rt;\nfunction Ps(n) {\n  var e = !0;\n  if ((0, As.isNativeInput)(n))\n    switch (n.type) {\n      case \"file\":\n      case \"checkbox\":\n      case \"radio\":\n      case \"hidden\":\n      case \"submit\":\n      case \"button\":\n      case \"image\":\n      case \"reset\":\n        e = !1;\n        break;\n    }\n  else\n    e = (0, Ls.isContentEditable)(n);\n  return e;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.canSetCaret = void 0;\n  var e = Nt;\n  Object.defineProperty(n, \"canSetCaret\", { enumerable: !0, get: function() {\n    return e.canSetCaret;\n  } });\n})(gn);\nvar Ve = {}, Ft = {};\nfunction Ns(n, e, t) {\n  const o = t.value !== void 0 ? \"value\" : \"get\", i = t[o], s = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[s] === void 0 && (this[s] = i.apply(this, r)), this[s];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete n[s], r.apply(this, a);\n    };\n  }\n  return t;\n}\nfunction mn() {\n  const n = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e !== void 0 && (n[e] = !0), n;\n}\nfunction jt(n) {\n  return n != null && n !== \"\" && (typeof n != \"object\" || Object.keys(n).length > 0);\n}\nfunction Rs(n) {\n  return !jt(n);\n}\nconst Ds = () => typeof window < \"u\" && window.navigator !== null && jt(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Fs(n) {\n  const e = mn();\n  return n = n.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \"+\"), e.mac ? n = n.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : n = n.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), n;\n}\nfunction js(n) {\n  return n[0].toUpperCase() + n.slice(1);\n}\nfunction Hs(n) {\n  const e = document.createElement(\"div\");\n  e.style.position = \"absolute\", e.style.left = \"-999px\", e.style.bottom = \"-999px\", e.innerHTML = n, document.body.appendChild(e);\n  const t = window.getSelection(), o = document.createRange();\n  if (o.selectNode(e), t === null)\n    throw new Error(\"Cannot copy text to clipboard\");\n  t.removeAllRanges(), t.addRange(o), document.execCommand(\"copy\"), document.body.removeChild(e);\n}\nfunction $s(n, e, t) {\n  let o;\n  return (...i) => {\n    const s = this, r = () => {\n      o = void 0, t !== !0 && n.apply(s, i);\n    }, a = t === !0 && o !== void 0;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);\n  };\n}\nfunction oe(n) {\n  return Object.prototype.toString.call(n).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction zs(n) {\n  return oe(n) === \"boolean\";\n}\nfunction bn(n) {\n  return oe(n) === \"function\" || oe(n) === \"asyncfunction\";\n}\nfunction Us(n) {\n  return bn(n) && /^\\s*class\\s+/.test(n.toString());\n}\nfunction Ws(n) {\n  return oe(n) === \"number\";\n}\nfunction De(n) {\n  return oe(n) === \"object\";\n}\nfunction Ys(n) {\n  return Promise.resolve(n) === n;\n}\nfunction Ks(n) {\n  return oe(n) === \"string\";\n}\nfunction Xs(n) {\n  return oe(n) === \"undefined\";\n}\nfunction bt(n, ...e) {\n  if (!e.length)\n    return n;\n  const t = e.shift();\n  if (De(n) && De(t))\n    for (const o in t)\n      De(t[o]) ? (n[o] === void 0 && Object.assign(n, { [o]: {} }), bt(n[o], t[o])) : Object.assign(n, { [o]: t[o] });\n  return bt(n, ...e);\n}\nfunction Vs(n, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  n && console.warn(o);\n}\nfunction qs(n) {\n  try {\n    return new URL(n).href;\n  } catch {\n  }\n  return n.substring(0, 2) === \"//\" ? window.location.protocol + n : window.location.origin + n;\n}\nfunction Zs(n) {\n  return n > 47 && n < 58 || n === 32 || n === 13 || n === 229 || n > 64 && n < 91 || n > 95 && n < 112 || n > 185 && n < 193 || n > 218 && n < 223;\n}\nconst Gs = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, Qs = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nlet Js = class {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n};\nfunction er(n, e, t = void 0) {\n  let o, i, s, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r === null && (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !a && t.leading === !1 && (a = c);\n    const u = e - (c - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r === null && (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), s;\n  };\n}\nconst tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  PromiseQueue: Js,\n  beautifyShortcut: Fs,\n  cacheable: Ns,\n  capitalize: js,\n  copyTextToClipboard: Hs,\n  debounce: $s,\n  deepMerge: bt,\n  deprecationAssert: Vs,\n  getUserOS: mn,\n  getValidUrl: qs,\n  isBoolean: zs,\n  isClass: Us,\n  isEmpty: Rs,\n  isFunction: bn,\n  isIosDevice: Ds,\n  isNumber: Ws,\n  isObject: De,\n  isPrintableKey: Zs,\n  isPromise: Ys,\n  isString: Ks,\n  isUndefined: Xs,\n  keyCodes: Gs,\n  mouseButtons: Qs,\n  notEmpty: jt,\n  throttle: er,\n  typeOf: oe\n}, Symbol.toStringTag, { value: \"Module\" })), Ht = /* @__PURE__ */ Xn(tr);\nObject.defineProperty(Ft, \"__esModule\", { value: !0 });\nFt.containsOnlyInlineElements = ir;\nvar or = Ht, nr = At;\nfunction ir(n) {\n  var e;\n  (0, or.isString)(n) ? (e = document.createElement(\"div\"), e.innerHTML = n) : e = n;\n  var t = function(o) {\n    return !(0, nr.blockElements)().includes(o.tagName.toLowerCase()) && Array.from(o.children).every(t);\n  };\n  return Array.from(e.children).every(t);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.containsOnlyInlineElements = void 0;\n  var e = Ft;\n  Object.defineProperty(n, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return e.containsOnlyInlineElements;\n  } });\n})(Ve);\nvar vn = {}, $t = {}, qe = {}, zt = {};\nObject.defineProperty(zt, \"__esModule\", { value: !0 });\nzt.make = sr;\nfunction sr(n, e, t) {\n  var o;\n  e === void 0 && (e = null), t === void 0 && (t = {});\n  var i = document.createElement(n);\n  if (Array.isArray(e)) {\n    var s = e.filter(function(a) {\n      return a !== void 0;\n    });\n    (o = i.classList).add.apply(o, s);\n  } else\n    e !== null && i.classList.add(e);\n  for (var r in t)\n    Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]);\n  return i;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.make = void 0;\n  var e = zt;\n  Object.defineProperty(n, \"make\", { enumerable: !0, get: function() {\n    return e.make;\n  } });\n})(qe);\nObject.defineProperty($t, \"__esModule\", { value: !0 });\n$t.fragmentToString = ar;\nvar rr = qe;\nfunction ar(n) {\n  var e = (0, rr.make)(\"div\");\n  return e.appendChild(n), e.innerHTML;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.fragmentToString = void 0;\n  var e = $t;\n  Object.defineProperty(n, \"fragmentToString\", { enumerable: !0, get: function() {\n    return e.fragmentToString;\n  } });\n})(vn);\nvar kn = {}, Ut = {};\nObject.defineProperty(Ut, \"__esModule\", { value: !0 });\nUt.getContentLength = cr;\nvar lr = ue;\nfunction cr(n) {\n  var e, t;\n  return (0, lr.isNativeInput)(n) ? n.value.length : n.nodeType === Node.TEXT_NODE ? n.length : (t = (e = n.textContent) === null || e === void 0 ? void 0 : e.length) !== null && t !== void 0 ? t : 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getContentLength = void 0;\n  var e = Ut;\n  Object.defineProperty(n, \"getContentLength\", { enumerable: !0, get: function() {\n    return e.getContentLength;\n  } });\n})(kn);\nvar Wt = {}, Yt = {}, Io = Ce && Ce.__spreadArray || function(n, e, t) {\n  if (t || arguments.length === 2)\n    for (var o = 0, i = e.length, s; o < i; o++)\n      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);\n  return n.concat(s || Array.prototype.slice.call(e));\n};\nObject.defineProperty(Yt, \"__esModule\", { value: !0 });\nYt.getDeepestBlockElements = yn;\nvar dr = Ve;\nfunction yn(n) {\n  return (0, dr.containsOnlyInlineElements)(n) ? [n] : Array.from(n.children).reduce(function(e, t) {\n    return Io(Io([], e, !0), yn(t), !0);\n  }, []);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getDeepestBlockElements = void 0;\n  var e = Yt;\n  Object.defineProperty(n, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return e.getDeepestBlockElements;\n  } });\n})(Wt);\nvar wn = {}, Kt = {}, Ze = {}, Xt = {};\nObject.defineProperty(Xt, \"__esModule\", { value: !0 });\nXt.isLineBreakTag = ur;\nfunction ur(n) {\n  return [\n    \"BR\",\n    \"WBR\"\n  ].includes(n.tagName);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isLineBreakTag = void 0;\n  var e = Xt;\n  Object.defineProperty(n, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return e.isLineBreakTag;\n  } });\n})(Ze);\nvar Ge = {}, Vt = {};\nObject.defineProperty(Vt, \"__esModule\", { value: !0 });\nVt.isSingleTag = hr;\nfunction hr(n) {\n  return [\n    \"AREA\",\n    \"BASE\",\n    \"BR\",\n    \"COL\",\n    \"COMMAND\",\n    \"EMBED\",\n    \"HR\",\n    \"IMG\",\n    \"INPUT\",\n    \"KEYGEN\",\n    \"LINK\",\n    \"META\",\n    \"PARAM\",\n    \"SOURCE\",\n    \"TRACK\",\n    \"WBR\"\n  ].includes(n.tagName);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isSingleTag = void 0;\n  var e = Vt;\n  Object.defineProperty(n, \"isSingleTag\", { enumerable: !0, get: function() {\n    return e.isSingleTag;\n  } });\n})(Ge);\nObject.defineProperty(Kt, \"__esModule\", { value: !0 });\nKt.getDeepestNode = En;\nvar pr = ue, fr = Ze, gr = Ge;\nfunction En(n, e) {\n  e === void 0 && (e = !1);\n  var t = e ? \"lastChild\" : \"firstChild\", o = e ? \"previousSibling\" : \"nextSibling\";\n  if (n.nodeType === Node.ELEMENT_NODE && n[t]) {\n    var i = n[t];\n    if ((0, gr.isSingleTag)(i) && !(0, pr.isNativeInput)(i) && !(0, fr.isLineBreakTag)(i))\n      if (i[o])\n        i = i[o];\n      else if (i.parentNode !== null && i.parentNode[o])\n        i = i.parentNode[o];\n      else\n        return i.parentNode;\n    return En(i, e);\n  }\n  return n;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getDeepestNode = void 0;\n  var e = Kt;\n  Object.defineProperty(n, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return e.getDeepestNode;\n  } });\n})(wn);\nvar xn = {}, qt = {}, Me = Ce && Ce.__spreadArray || function(n, e, t) {\n  if (t || arguments.length === 2)\n    for (var o = 0, i = e.length, s; o < i; o++)\n      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);\n  return n.concat(s || Array.prototype.slice.call(e));\n};\nObject.defineProperty(qt, \"__esModule\", { value: !0 });\nqt.findAllInputs = yr;\nvar mr = Ve, br = Wt, vr = It, kr = ue;\nfunction yr(n) {\n  return Array.from(n.querySelectorAll((0, vr.allInputsSelector)())).reduce(function(e, t) {\n    return (0, kr.isNativeInput)(t) || (0, mr.containsOnlyInlineElements)(t) ? Me(Me([], e, !0), [t], !1) : Me(Me([], e, !0), (0, br.getDeepestBlockElements)(t), !0);\n  }, []);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.findAllInputs = void 0;\n  var e = qt;\n  Object.defineProperty(n, \"findAllInputs\", { enumerable: !0, get: function() {\n    return e.findAllInputs;\n  } });\n})(xn);\nvar Bn = {}, Zt = {};\nObject.defineProperty(Zt, \"__esModule\", { value: !0 });\nZt.isCollapsedWhitespaces = wr;\nfunction wr(n) {\n  return !/[^\\t\\n\\r ]/.test(n);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCollapsedWhitespaces = void 0;\n  var e = Zt;\n  Object.defineProperty(n, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return e.isCollapsedWhitespaces;\n  } });\n})(Bn);\nvar Gt = {}, Qt = {};\nObject.defineProperty(Qt, \"__esModule\", { value: !0 });\nQt.isElement = xr;\nvar Er = Ht;\nfunction xr(n) {\n  return (0, Er.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.ELEMENT_NODE;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isElement = void 0;\n  var e = Qt;\n  Object.defineProperty(n, \"isElement\", { enumerable: !0, get: function() {\n    return e.isElement;\n  } });\n})(Gt);\nvar Cn = {}, Jt = {}, eo = {}, to = {};\nObject.defineProperty(to, \"__esModule\", { value: !0 });\nto.isLeaf = Br;\nfunction Br(n) {\n  return n === null ? !1 : n.childNodes.length === 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isLeaf = void 0;\n  var e = to;\n  Object.defineProperty(n, \"isLeaf\", { enumerable: !0, get: function() {\n    return e.isLeaf;\n  } });\n})(eo);\nvar oo = {}, no = {};\nObject.defineProperty(no, \"__esModule\", { value: !0 });\nno.isNodeEmpty = Or;\nvar Cr = Ze, Tr = Gt, Sr = ue, Ir = Ge;\nfunction Or(n, e) {\n  var t = \"\";\n  return (0, Ir.isSingleTag)(n) && !(0, Cr.isLineBreakTag)(n) ? !1 : ((0, Tr.isElement)(n) && (0, Sr.isNativeInput)(n) ? t = n.value : n.textContent !== null && (t = n.textContent.replace(\"​\", \"\")), e !== void 0 && (t = t.replace(new RegExp(e, \"g\"), \"\")), t.trim().length === 0);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isNodeEmpty = void 0;\n  var e = no;\n  Object.defineProperty(n, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return e.isNodeEmpty;\n  } });\n})(oo);\nObject.defineProperty(Jt, \"__esModule\", { value: !0 });\nJt.isEmpty = Ar;\nvar _r = eo, Mr = oo;\nfunction Ar(n, e) {\n  n.normalize();\n  for (var t = [n]; t.length > 0; ) {\n    var o = t.shift();\n    if (o) {\n      if (n = o, (0, _r.isLeaf)(n) && !(0, Mr.isNodeEmpty)(n, e))\n        return !1;\n      t.push.apply(t, Array.from(n.childNodes));\n    }\n  }\n  return !0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isEmpty = void 0;\n  var e = Jt;\n  Object.defineProperty(n, \"isEmpty\", { enumerable: !0, get: function() {\n    return e.isEmpty;\n  } });\n})(Cn);\nvar Tn = {}, io = {};\nObject.defineProperty(io, \"__esModule\", { value: !0 });\nio.isFragment = Pr;\nvar Lr = Ht;\nfunction Pr(n) {\n  return (0, Lr.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isFragment = void 0;\n  var e = io;\n  Object.defineProperty(n, \"isFragment\", { enumerable: !0, get: function() {\n    return e.isFragment;\n  } });\n})(Tn);\nvar Sn = {}, so = {};\nObject.defineProperty(so, \"__esModule\", { value: !0 });\nso.isHTMLString = Rr;\nvar Nr = qe;\nfunction Rr(n) {\n  var e = (0, Nr.make)(\"div\");\n  return e.innerHTML = n, e.childElementCount > 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isHTMLString = void 0;\n  var e = so;\n  Object.defineProperty(n, \"isHTMLString\", { enumerable: !0, get: function() {\n    return e.isHTMLString;\n  } });\n})(Sn);\nvar In = {}, ro = {};\nObject.defineProperty(ro, \"__esModule\", { value: !0 });\nro.offset = Dr;\nfunction Dr(n) {\n  var e = n.getBoundingClientRect(), t = window.pageXOffset || document.documentElement.scrollLeft, o = window.pageYOffset || document.documentElement.scrollTop, i = e.top + o, s = e.left + t;\n  return {\n    top: i,\n    left: s,\n    bottom: i + e.height,\n    right: s + e.width\n  };\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.offset = void 0;\n  var e = ro;\n  Object.defineProperty(n, \"offset\", { enumerable: !0, get: function() {\n    return e.offset;\n  } });\n})(In);\nvar On = {}, ao = {};\nObject.defineProperty(ao, \"__esModule\", { value: !0 });\nao.prepend = Fr;\nfunction Fr(n, e) {\n  Array.isArray(e) ? (e = e.reverse(), e.forEach(function(t) {\n    return n.prepend(t);\n  })) : n.prepend(e);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.prepend = void 0;\n  var e = ao;\n  Object.defineProperty(n, \"prepend\", { enumerable: !0, get: function() {\n    return e.prepend;\n  } });\n})(On);\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.prepend = n.offset = n.make = n.isLineBreakTag = n.isSingleTag = n.isNodeEmpty = n.isLeaf = n.isHTMLString = n.isFragment = n.isEmpty = n.isElement = n.isContentEditable = n.isCollapsedWhitespaces = n.findAllInputs = n.isNativeInput = n.allInputsSelector = n.getDeepestNode = n.getDeepestBlockElements = n.getContentLength = n.fragmentToString = n.containsOnlyInlineElements = n.canSetCaret = n.calculateBaseline = n.blockElements = n.append = void 0;\n  var e = It;\n  Object.defineProperty(n, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return e.allInputsSelector;\n  } });\n  var t = ue;\n  Object.defineProperty(n, \"isNativeInput\", { enumerable: !0, get: function() {\n    return t.isNativeInput;\n  } });\n  var o = pn;\n  Object.defineProperty(n, \"append\", { enumerable: !0, get: function() {\n    return o.append;\n  } });\n  var i = At;\n  Object.defineProperty(n, \"blockElements\", { enumerable: !0, get: function() {\n    return i.blockElements;\n  } });\n  var s = fn;\n  Object.defineProperty(n, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return s.calculateBaseline;\n  } });\n  var r = gn;\n  Object.defineProperty(n, \"canSetCaret\", { enumerable: !0, get: function() {\n    return r.canSetCaret;\n  } });\n  var a = Ve;\n  Object.defineProperty(n, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return a.containsOnlyInlineElements;\n  } });\n  var l = vn;\n  Object.defineProperty(n, \"fragmentToString\", { enumerable: !0, get: function() {\n    return l.fragmentToString;\n  } });\n  var c = kn;\n  Object.defineProperty(n, \"getContentLength\", { enumerable: !0, get: function() {\n    return c.getContentLength;\n  } });\n  var u = Wt;\n  Object.defineProperty(n, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return u.getDeepestBlockElements;\n  } });\n  var h = wn;\n  Object.defineProperty(n, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return h.getDeepestNode;\n  } });\n  var p = xn;\n  Object.defineProperty(n, \"findAllInputs\", { enumerable: !0, get: function() {\n    return p.findAllInputs;\n  } });\n  var g = Bn;\n  Object.defineProperty(n, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return g.isCollapsedWhitespaces;\n  } });\n  var f = Rt;\n  Object.defineProperty(n, \"isContentEditable\", { enumerable: !0, get: function() {\n    return f.isContentEditable;\n  } });\n  var v = Gt;\n  Object.defineProperty(n, \"isElement\", { enumerable: !0, get: function() {\n    return v.isElement;\n  } });\n  var O = Cn;\n  Object.defineProperty(n, \"isEmpty\", { enumerable: !0, get: function() {\n    return O.isEmpty;\n  } });\n  var T = Tn;\n  Object.defineProperty(n, \"isFragment\", { enumerable: !0, get: function() {\n    return T.isFragment;\n  } });\n  var M = Sn;\n  Object.defineProperty(n, \"isHTMLString\", { enumerable: !0, get: function() {\n    return M.isHTMLString;\n  } });\n  var q = eo;\n  Object.defineProperty(n, \"isLeaf\", { enumerable: !0, get: function() {\n    return q.isLeaf;\n  } });\n  var F = oo;\n  Object.defineProperty(n, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return F.isNodeEmpty;\n  } });\n  var H = Ze;\n  Object.defineProperty(n, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return H.isLineBreakTag;\n  } });\n  var Q = Ge;\n  Object.defineProperty(n, \"isSingleTag\", { enumerable: !0, get: function() {\n    return Q.isSingleTag;\n  } });\n  var ie = qe;\n  Object.defineProperty(n, \"make\", { enumerable: !0, get: function() {\n    return ie.make;\n  } });\n  var k = In;\n  Object.defineProperty(n, \"offset\", { enumerable: !0, get: function() {\n    return k.offset;\n  } });\n  var m = On;\n  Object.defineProperty(n, \"prepend\", { enumerable: !0, get: function() {\n    return m.prepend;\n  } });\n})(de);\nvar Qe = {};\nObject.defineProperty(Qe, \"__esModule\", { value: !0 });\nQe.getContenteditableSlice = Hr;\nvar jr = de;\nfunction Hr(n, e, t, o, i) {\n  var s;\n  i === void 0 && (i = !1);\n  var r = document.createRange();\n  if (o === \"left\" ? (r.setStart(n, 0), r.setEnd(e, t)) : (r.setStart(e, t), r.setEnd(n, n.childNodes.length)), i === !0) {\n    var a = r.extractContents();\n    return (0, jr.fragmentToString)(a);\n  }\n  var l = r.cloneContents(), c = document.createElement(\"div\");\n  c.appendChild(l);\n  var u = (s = c.textContent) !== null && s !== void 0 ? s : \"\";\n  return u;\n}\nObject.defineProperty(Xe, \"__esModule\", { value: !0 });\nXe.checkContenteditableSliceForEmptiness = Ur;\nvar $r = de, zr = Qe;\nfunction Ur(n, e, t, o) {\n  var i = (0, zr.getContenteditableSlice)(n, e, t, o);\n  return (0, $r.isCollapsedWhitespaces)(i);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.checkContenteditableSliceForEmptiness = void 0;\n  var e = Xe;\n  Object.defineProperty(n, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return e.checkContenteditableSliceForEmptiness;\n  } });\n})(St);\nvar _n = {};\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getContenteditableSlice = void 0;\n  var e = Qe;\n  Object.defineProperty(n, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return e.getContenteditableSlice;\n  } });\n})(_n);\nvar Mn = {}, lo = {};\nObject.defineProperty(lo, \"__esModule\", { value: !0 });\nlo.focus = Yr;\nvar Wr = de;\nfunction Yr(n, e) {\n  var t, o;\n  if (e === void 0 && (e = !0), (0, Wr.isNativeInput)(n)) {\n    n.focus();\n    var i = e ? 0 : n.value.length;\n    n.setSelectionRange(i, i);\n  } else {\n    var s = document.createRange(), r = window.getSelection();\n    if (!r)\n      return;\n    var a = function(p) {\n      var g = document.createTextNode(\"\");\n      p.appendChild(g), s.setStart(g, 0), s.setEnd(g, 0);\n    }, l = function(p) {\n      return p != null;\n    }, c = n.childNodes, u = e ? c[0] : c[c.length - 1];\n    if (l(u)) {\n      for (; l(u) && u.nodeType !== Node.TEXT_NODE; )\n        u = e ? u.firstChild : u.lastChild;\n      if (l(u) && u.nodeType === Node.TEXT_NODE) {\n        var h = (o = (t = u.textContent) === null || t === void 0 ? void 0 : t.length) !== null && o !== void 0 ? o : 0, i = e ? 0 : h;\n        s.setStart(u, i), s.setEnd(u, i);\n      } else\n        a(n);\n    } else\n      a(n);\n    r.removeAllRanges(), r.addRange(s);\n  }\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.focus = void 0;\n  var e = lo;\n  Object.defineProperty(n, \"focus\", { enumerable: !0, get: function() {\n    return e.focus;\n  } });\n})(Mn);\nvar co = {}, Je = {};\nObject.defineProperty(Je, \"__esModule\", { value: !0 });\nJe.getCaretNodeAndOffset = Kr;\nfunction Kr() {\n  var n = window.getSelection();\n  if (n === null)\n    return [null, 0];\n  var e = n.focusNode, t = n.focusOffset;\n  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] !== void 0 ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], e.textContent !== null && (t = e.textContent.length))), [e, t]);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getCaretNodeAndOffset = void 0;\n  var e = Je;\n  Object.defineProperty(n, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return e.getCaretNodeAndOffset;\n  } });\n})(co);\nvar An = {}, et = {};\nObject.defineProperty(et, \"__esModule\", { value: !0 });\net.getRange = Xr;\nfunction Xr() {\n  var n = window.getSelection();\n  return n && n.rangeCount ? n.getRangeAt(0) : null;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getRange = void 0;\n  var e = et;\n  Object.defineProperty(n, \"getRange\", { enumerable: !0, get: function() {\n    return e.getRange;\n  } });\n})(An);\nvar Ln = {}, uo = {};\nObject.defineProperty(uo, \"__esModule\", { value: !0 });\nuo.isCaretAtEndOfInput = Zr;\nvar Oo = de, Vr = co, qr = St;\nfunction Zr(n) {\n  var e = (0, Oo.getDeepestNode)(n, !0);\n  if (e === null)\n    return !0;\n  if ((0, Oo.isNativeInput)(e))\n    return e.selectionEnd === e.value.length;\n  var t = (0, Vr.getCaretNodeAndOffset)(), o = t[0], i = t[1];\n  return o === null ? !1 : (0, qr.checkContenteditableSliceForEmptiness)(n, o, i, \"right\");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCaretAtEndOfInput = void 0;\n  var e = uo;\n  Object.defineProperty(n, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return e.isCaretAtEndOfInput;\n  } });\n})(Ln);\nvar Pn = {}, ho = {};\nObject.defineProperty(ho, \"__esModule\", { value: !0 });\nho.isCaretAtStartOfInput = Jr;\nvar Ae = de, Gr = Je, Qr = Xe;\nfunction Jr(n) {\n  var e = (0, Ae.getDeepestNode)(n);\n  if (e === null || (0, Ae.isEmpty)(n))\n    return !0;\n  if ((0, Ae.isNativeInput)(e))\n    return e.selectionEnd === 0;\n  if ((0, Ae.isEmpty)(n))\n    return !0;\n  var t = (0, Gr.getCaretNodeAndOffset)(), o = t[0], i = t[1];\n  return o === null ? !1 : (0, Qr.checkContenteditableSliceForEmptiness)(n, o, i, \"left\");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCaretAtStartOfInput = void 0;\n  var e = ho;\n  Object.defineProperty(n, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return e.isCaretAtStartOfInput;\n  } });\n})(Pn);\nvar Nn = {}, po = {};\nObject.defineProperty(po, \"__esModule\", { value: !0 });\npo.save = oa;\nvar ea = de, ta = et;\nfunction oa() {\n  var n = (0, ta.getRange)(), e = (0, ea.make)(\"span\");\n  if (e.id = \"cursor\", e.hidden = !0, !!n)\n    return n.insertNode(e), function() {\n      var o = window.getSelection();\n      o && (n.setStartAfter(e), n.setEndAfter(e), o.removeAllRanges(), o.addRange(n), setTimeout(function() {\n        e.remove();\n      }, 150));\n    };\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.save = void 0;\n  var e = po;\n  Object.defineProperty(n, \"save\", { enumerable: !0, get: function() {\n    return e.save;\n  } });\n})(Nn);\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.save = n.isCaretAtStartOfInput = n.isCaretAtEndOfInput = n.getRange = n.getCaretNodeAndOffset = n.focus = n.getContenteditableSlice = n.checkContenteditableSliceForEmptiness = void 0;\n  var e = St;\n  Object.defineProperty(n, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return e.checkContenteditableSliceForEmptiness;\n  } });\n  var t = _n;\n  Object.defineProperty(n, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return t.getContenteditableSlice;\n  } });\n  var o = Mn;\n  Object.defineProperty(n, \"focus\", { enumerable: !0, get: function() {\n    return o.focus;\n  } });\n  var i = co;\n  Object.defineProperty(n, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return i.getCaretNodeAndOffset;\n  } });\n  var s = An;\n  Object.defineProperty(n, \"getRange\", { enumerable: !0, get: function() {\n    return s.getRange;\n  } });\n  var r = Ln;\n  Object.defineProperty(n, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return r.isCaretAtEndOfInput;\n  } });\n  var a = Pn;\n  Object.defineProperty(n, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return a.isCaretAtStartOfInput;\n  } });\n  var l = Nn;\n  Object.defineProperty(n, \"save\", { enumerable: !0, get: function() {\n    return l.save;\n  } });\n})(hn);\nclass na extends E {\n  /**\n   * All keydowns on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  keydown(e) {\n    switch (this.beforeKeydownProcessing(e), e.keyCode) {\n      case y.BACKSPACE:\n        this.backspace(e);\n        break;\n      case y.DELETE:\n        this.delete(e);\n        break;\n      case y.ENTER:\n        this.enter(e);\n        break;\n      case y.DOWN:\n      case y.RIGHT:\n        this.arrowRightAndDown(e);\n        break;\n      case y.UP:\n      case y.LEFT:\n        this.arrowLeftAndUp(e);\n        break;\n      case y.TAB:\n        this.tabPressed(e);\n        break;\n    }\n    e.key === \"/\" && !e.ctrlKey && !e.metaKey && this.slashPressed(e), e.code === \"Slash\" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());\n  }\n  /**\n   * Fires on keydown before event processing\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  beforeKeydownProcessing(e) {\n    this.needToolbarClosing(e) && Po(e.keyCode) && (this.Editor.Toolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));\n  }\n  /**\n   * Key up on Block:\n   * - shows Inline Toolbar if something selected\n   * - shows conversion toolbar with 85% of block selection\n   *\n   * @param {KeyboardEvent} event - keyup event\n   */\n  keyup(e) {\n    e.shiftKey || this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Add drop target styles\n   *\n   * @param {DragEvent} event - drag over event\n   */\n  dragOver(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !0;\n  }\n  /**\n   * Remove drop target style\n   *\n   * @param {DragEvent} event - drag leave event\n   */\n  dragLeave(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !1;\n  }\n  /**\n   * Copying selected blocks\n   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandC(e) {\n    const { BlockSelection: t } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e);\n  }\n  /**\n   * Copy and Delete selected Blocks\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandX(e) {\n    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {\n      const s = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), t.clearSelection(e);\n    });\n  }\n  /**\n   * Tab pressed inside a Block.\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  tabPressed(e) {\n    const { InlineToolbar: t, Caret: o } = this.Editor;\n    if (t.opened)\n      return;\n    (e.shiftKey ? o.navigatePrevious(!0) : o.navigateNext(!0)) && e.preventDefault();\n  }\n  /**\n   * '/' + 'command' keydown inside a Block\n   */\n  commandSlashPressed() {\n    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();\n  }\n  /**\n   * '/' keydown inside a Block\n   *\n   * @param event - keydown\n   */\n  slashPressed(e) {\n    this.Editor.BlockManager.currentBlock.isEmpty && (e.preventDefault(), this.Editor.Caret.insertContentAtCaretPosition(\"/\"), this.activateToolbox());\n  }\n  /**\n   * ENTER pressed on block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  enter(e) {\n    const { BlockManager: t, UI: o } = this.Editor, i = t.currentBlock;\n    if (i === void 0 || i.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey && !pt)\n      return;\n    let s = i;\n    i.currentInput !== void 0 && Ne(i.currentInput) && !i.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : i.currentInput && Re(i.currentInput) ? s = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : s = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s), e.preventDefault();\n  }\n  /**\n   * Handle backspace keydown on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, previousBlock: s } = t;\n    if (i === void 0 || !b.isCollapsed || !i.currentInput || !Ne(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {\n      o.navigatePrevious();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i);\n      const l = t.currentBlock;\n      o.setToBlock(l, o.positions.END);\n      return;\n    }\n    xo(s, i) ? this.mergeBlocks(s, i) : o.setToBlock(s, o.positions.END);\n  }\n  /**\n   * Handles delete keydown on Block\n   * Removes char after the caret.\n   * If caret is at the end of the block, merge next block with current\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  delete(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, nextBlock: s } = t;\n    if (!b.isCollapsed || !Re(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {\n      o.navigateNext();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i), o.setToBlock(s, o.positions.START);\n      return;\n    }\n    xo(i, s) ? this.mergeBlocks(i, s) : o.setToBlock(s, o.positions.START);\n  }\n  /**\n   * Merge passed Blocks\n   *\n   * @param targetBlock - to which Block we want to merge\n   * @param blockToMerge - what Block we want to merge\n   */\n  mergeBlocks(e, t) {\n    const { BlockManager: o, Toolbar: i } = this.Editor;\n    e.lastInput !== void 0 && (hn.focus(e.lastInput, !1), o.mergeBlocks(e, t).then(() => {\n      i.close();\n    }));\n  }\n  /**\n   * Handle right and down keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowRightAndDown(e) {\n    const t = ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB);\n    if (this.Editor.UI.someToolbarOpened && t)\n      return;\n    this.Editor.Toolbar.close();\n    const { currentBlock: o } = this.Editor.BlockManager, s = ((o == null ? void 0 : o.currentInput) !== void 0 ? Re(o.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === y.DOWN && s) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState();\n      return;\n    }\n    if (e.keyCode === y.DOWN || e.keyCode === y.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {\n      e.preventDefault();\n      return;\n    }\n    Fe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Handle left and up keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowLeftAndUp(e) {\n    if (this.Editor.UI.someToolbarOpened) {\n      if (ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB))\n        return;\n      this.Editor.UI.closeAllToolbars();\n    }\n    this.Editor.Toolbar.close();\n    const { currentBlock: t } = this.Editor.BlockManager, i = ((t == null ? void 0 : t.currentInput) !== void 0 ? Ne(t.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === y.UP && i) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);\n      return;\n    }\n    if (e.keyCode === y.UP || e.keyCode === y.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {\n      e.preventDefault();\n      return;\n    }\n    Fe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Cases when we need to close Toolbar\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  needToolbarClosing(e) {\n    const t = e.keyCode === y.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === y.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === y.ENTER && this.Editor.InlineToolbar.opened, s = e.keyCode === y.TAB;\n    return !(e.shiftKey || s || t || o || i);\n  }\n  /**\n   * If Toolbox is not open, then just open it and show plus button\n   */\n  activateToolbox() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();\n  }\n  /**\n   * Open Toolbar and show BlockSettings before flipping Tools\n   */\n  activateBlockSettings() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();\n  }\n}\nclass ct {\n  /**\n   * @class\n   * @param {HTMLElement} workingArea — editor`s working node\n   */\n  constructor(e) {\n    this.blocks = [], this.workingArea = e;\n  }\n  /**\n   * Get length of Block instances array\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.blocks.length;\n  }\n  /**\n   * Get Block instances array\n   *\n   * @returns {Block[]}\n   */\n  get array() {\n    return this.blocks;\n  }\n  /**\n   * Get blocks html elements array\n   *\n   * @returns {HTMLElement[]}\n   */\n  get nodes() {\n    return No(this.workingArea.children);\n  }\n  /**\n   * Proxy trap to implement array-like setter\n   *\n   * @example\n   * blocks[0] = new Block(...)\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — block index or any Blocks class property key to set\n   * @param {Block} value — value to set\n   * @returns {boolean}\n   */\n  static set(e, t, o) {\n    return isNaN(Number(t)) ? (Reflect.set(e, t, o), !0) : (e.insert(+t, o), !0);\n  }\n  /**\n   * Proxy trap to implement array-like getter\n   *\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — Blocks class property key\n   * @returns {Block|*}\n   */\n  static get(e, t) {\n    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);\n  }\n  /**\n   * Push new Block to the blocks array and append it to working area\n   *\n   * @param {Block} block - Block to add\n   */\n  push(e) {\n    this.blocks.push(e), this.insertToDOM(e);\n  }\n  /**\n   * Swaps blocks with indexes first and second\n   *\n   * @param {number} first - first block index\n   * @param {number} second - second block index\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    const o = this.blocks[t];\n    d.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;\n  }\n  /**\n   * Move a block from one to another index\n   *\n   * @param {number} toIndex - new index of the block\n   * @param {number} fromIndex - block to move\n   */\n  move(e, t) {\n    const o = this.blocks.splice(t, 1)[0], i = e - 1, s = Math.max(0, i), r = this.blocks[s];\n    e > 0 ? this.insertToDOM(o, \"afterend\", r) : this.insertToDOM(o, \"beforebegin\", r), this.blocks.splice(e, 0, o);\n    const a = this.composeBlockEvent(\"move\", {\n      fromIndex: t,\n      toIndex: e\n    });\n    o.call(ee.MOVED, a);\n  }\n  /**\n   * Insert new Block at passed index\n   *\n   * @param {number} index — index to insert Block\n   * @param {Block} block — Block to insert\n   * @param {boolean} replace — it true, replace block on given index\n   */\n  insert(e, t, o = !1) {\n    if (!this.length) {\n      this.push(t);\n      return;\n    }\n    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED));\n    const i = o ? 1 : 0;\n    if (this.blocks.splice(e, i, t), e > 0) {\n      const s = this.blocks[e - 1];\n      this.insertToDOM(t, \"afterend\", s);\n    } else {\n      const s = this.blocks[e + 1];\n      s ? this.insertToDOM(t, \"beforebegin\", s) : this.insertToDOM(t);\n    }\n  }\n  /**\n   * Replaces block under passed index with passed block\n   *\n   * @param index - index of existed block\n   * @param block - new block\n   */\n  replace(e, t) {\n    if (this.blocks[e] === void 0)\n      throw Error(\"Incorrect index\");\n    this.blocks[e].holder.replaceWith(t.holder), this.blocks[e] = t;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index to insert blocks at\n   */\n  insertMany(e, t) {\n    const o = new DocumentFragment();\n    for (const i of e)\n      o.appendChild(i.holder);\n    if (this.length > 0) {\n      if (t > 0) {\n        const i = Math.min(t - 1, this.length - 1);\n        this.blocks[i].holder.after(o);\n      } else\n        t === 0 && this.workingArea.prepend(o);\n      this.blocks.splice(t, 0, ...e);\n    } else\n      this.blocks.push(...e), this.workingArea.appendChild(o);\n    e.forEach((i) => i.call(ee.RENDERED));\n  }\n  /**\n   * Remove block\n   *\n   * @param {number} index - index of Block to remove\n   */\n  remove(e) {\n    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED), this.blocks.splice(e, 1);\n  }\n  /**\n   * Remove all blocks\n   */\n  removeAll() {\n    this.workingArea.innerHTML = \"\", this.blocks.forEach((e) => e.call(ee.REMOVED)), this.blocks.length = 0;\n  }\n  /**\n   * Insert Block after passed target\n   *\n   * @todo decide if this method is necessary\n   * @param {Block} targetBlock — target after which Block should be inserted\n   * @param {Block} newBlock — Block to insert\n   */\n  insertAfter(e, t) {\n    const o = this.blocks.indexOf(e);\n    this.insert(o + 1, t);\n  }\n  /**\n   * Get Block by index\n   *\n   * @param {number} index — Block index\n   * @returns {Block}\n   */\n  get(e) {\n    return this.blocks[e];\n  }\n  /**\n   * Return index of passed Block\n   *\n   * @param {Block} block - Block to find\n   * @returns {number}\n   */\n  indexOf(e) {\n    return this.blocks.indexOf(e);\n  }\n  /**\n   * Insert new Block into DOM\n   *\n   * @param {Block} block - Block to insert\n   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)\n   * @param {Block} target — Block related to position\n   */\n  insertToDOM(e, t, o) {\n    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(ee.RENDERED);\n  }\n  /**\n   * Composes Block event with passed type and details\n   *\n   * @param {string} type - event type\n   * @param {object} detail - event detail\n   */\n  composeBlockEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n}\nconst _o = \"block-removed\", Mo = \"block-added\", ia = \"block-moved\", Ao = \"block-changed\";\nclass sa {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   *\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n}\nclass ra extends E {\n  constructor() {\n    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;\n  }\n  /**\n   * Returns current Block index\n   *\n   * @returns {number}\n   */\n  get currentBlockIndex() {\n    return this._currentBlockIndex;\n  }\n  /**\n   * Set current Block index and fire Block lifecycle callbacks\n   *\n   * @param {number} newIndex - index of Block to set as current\n   */\n  set currentBlockIndex(e) {\n    this._currentBlockIndex = e;\n  }\n  /**\n   * returns first Block\n   *\n   * @returns {Block}\n   */\n  get firstBlock() {\n    return this._blocks[0];\n  }\n  /**\n   * returns last Block\n   *\n   * @returns {Block}\n   */\n  get lastBlock() {\n    return this._blocks[this._blocks.length - 1];\n  }\n  /**\n   * Get current Block instance\n   *\n   * @returns {Block}\n   */\n  get currentBlock() {\n    return this._blocks[this.currentBlockIndex];\n  }\n  /**\n   * Set passed Block as a current\n   *\n   * @param block - block to set as a current\n   */\n  set currentBlock(e) {\n    this.currentBlockIndex = this.getBlockIndex(e);\n  }\n  /**\n   * Returns next Block instance\n   *\n   * @returns {Block|null}\n   */\n  get nextBlock() {\n    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];\n  }\n  /**\n   * Return first Block with inputs after current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get nextContentfulBlock() {\n    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);\n  }\n  /**\n   * Return first Block with inputs before current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get previousContentfulBlock() {\n    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);\n  }\n  /**\n   * Returns previous Block instance\n   *\n   * @returns {Block|null}\n   */\n  get previousBlock() {\n    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];\n  }\n  /**\n   * Get array of Block instances\n   *\n   * @returns {Block[]} {@link Blocks#array}\n   */\n  get blocks() {\n    return this._blocks.array;\n  }\n  /**\n   * Check if each Block is empty\n   *\n   * @returns {boolean}\n   */\n  get isEditorEmpty() {\n    return this.blocks.every((e) => e.isEmpty);\n  }\n  /**\n   * Should be called after Editor.UI preparation\n   * Define this._blocks property\n   */\n  prepare() {\n    const e = new ct(this.Editor.UI.nodes.redactor);\n    this._blocks = new Proxy(e, {\n      set: ct.set,\n      get: ct.get\n    }), this.listeners.on(\n      document,\n      \"copy\",\n      (t) => this.Editor.BlockEvents.handleCommandC(t)\n    );\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - Unbind event handlers from created Blocks\n   *\n   * if readOnly is false:\n   *  - Bind event handlers to all existing Blocks\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Creates Block instance by tool name\n   *\n   * @param {object} options - block creation options\n   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}\n   * @param {string} [options.id] - unique id for this block\n   * @param {BlockToolData} [options.data] - constructor params\n   * @returns {Block}\n   */\n  composeBlock({\n    tool: e,\n    data: t = {},\n    id: o = void 0,\n    tunes: i = {}\n  }) {\n    const s = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new R({\n      id: o,\n      data: t,\n      tool: r,\n      api: this.Editor.API,\n      readOnly: s,\n      tunesData: i\n    }, this.eventsDispatcher);\n    return s || window.requestIdleCallback(() => {\n      this.bindBlockEvents(a);\n    }, { timeout: 2e3 }), a;\n  }\n  /**\n   * Insert new block into _blocks\n   *\n   * @param {object} options - insert options\n   * @param {string} [options.id] - block's unique id\n   * @param {string} [options.tool] - plugin name, by default method inserts the default block type\n   * @param {object} [options.data] - plugin data\n   * @param {number} [options.index] - index where to insert new Block\n   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index\n   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one\n   * @returns {Block}\n   */\n  insert({\n    id: e = void 0,\n    tool: t = this.config.defaultBlock,\n    data: o = {},\n    index: i,\n    needToFocus: s = !0,\n    replace: r = !1,\n    tunes: a = {}\n  } = {}) {\n    let l = i;\n    l === void 0 && (l = this.currentBlockIndex + (r ? 0 : 1));\n    const c = this.composeBlock({\n      id: e,\n      tool: t,\n      data: o,\n      tunes: a\n    });\n    return r && this.blockDidMutated(_o, this.getBlockByIndex(l), {\n      index: l\n    }), this._blocks.insert(l, c, r), this.blockDidMutated(Mo, c, {\n      index: l\n    }), s ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, c;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index where to insert\n   */\n  insertMany(e, t = 0) {\n    this._blocks.insertMany(e, t);\n  }\n  /**\n   * Update Block data.\n   *\n   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type\n   * Should not trigger 'block-removed' or 'block-added' events.\n   *\n   * If neither data nor tunes is provided, return the provided block instead.\n   *\n   * @param block - block to update\n   * @param data - (optional) new data\n   * @param tunes - (optional) tune data\n   */\n  async update(e, t, o) {\n    if (!t && !o)\n      return e;\n    const i = await e.data, s = this.composeBlock({\n      id: e.id,\n      tool: e.name,\n      data: Object.assign({}, i, t ?? {}),\n      tunes: o ?? e.tunes\n    }), r = this.getBlockIndex(e);\n    return this._blocks.replace(r, s), this.blockDidMutated(Ao, s, {\n      index: r\n    }), s;\n  }\n  /**\n   * Replace passed Block with the new one with specified Tool and data\n   *\n   * @param block - block to replace\n   * @param newTool - new Tool name\n   * @param data - new Tool data\n   */\n  replace(e, t, o) {\n    const i = this.getBlockIndex(e);\n    return this.insert({\n      tool: t,\n      data: o,\n      index: i,\n      replace: !0\n    });\n  }\n  /**\n   * Insert pasted content. Call onPaste callback after insert.\n   *\n   * @param {string} toolName - name of Tool to insert\n   * @param {PasteEvent} pasteEvent - pasted data\n   * @param {boolean} replace - should replace current block\n   */\n  paste(e, t, o = !1) {\n    const i = this.insert({\n      tool: e,\n      replace: o\n    });\n    try {\n      window.requestIdleCallback(() => {\n        i.call(ee.ON_PASTE, t);\n      });\n    } catch (s) {\n      S(`${e}: onPaste callback call is failed`, \"error\", s);\n    }\n    return i;\n  }\n  /**\n   * Insert new default block at passed index\n   *\n   * @param {number} index - index where Block should be inserted\n   * @param {boolean} needToFocus - if true, updates current Block index\n   *\n   * TODO: Remove method and use insert() with index instead (?)\n   * @returns {Block} inserted Block\n   */\n  insertDefaultBlockAtIndex(e, t = !1) {\n    const o = this.composeBlock({ tool: this.config.defaultBlock });\n    return this._blocks[e] = o, this.blockDidMutated(Mo, o, {\n      index: e\n    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;\n  }\n  /**\n   * Always inserts at the end\n   *\n   * @returns {Block}\n   */\n  insertAtEnd() {\n    return this.currentBlockIndex = this.blocks.length - 1, this.insert();\n  }\n  /**\n   * Merge two blocks\n   *\n   * @param {Block} targetBlock - previous block will be append to this block\n   * @param {Block} blockToMerge - block that will be merged with target block\n   * @returns {Promise} - the sequence that can be continued\n   */\n  async mergeBlocks(e, t) {\n    let o;\n    if (e.name === t.name && e.mergeable) {\n      const i = await t.data;\n      if (V(i)) {\n        console.error(\"Could not merge Block. Failed to extract original Block data.\");\n        return;\n      }\n      const [s] = yt([i], e.tool.sanitizeConfig);\n      o = s;\n    } else if (e.mergeable && He(t, \"export\") && He(e, \"import\")) {\n      const i = await t.exportDataAsString(), s = Z(i, e.tool.sanitizeConfig);\n      o = Bo(s, e.tool.conversionConfig);\n    }\n    o !== void 0 && (await e.mergeWith(o), this.removeBlock(t), this.currentBlockIndex = this._blocks.indexOf(e));\n  }\n  /**\n   * Remove passed Block\n   *\n   * @param block - Block to remove\n   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead\n   */\n  removeBlock(e, t = !0) {\n    return new Promise((o) => {\n      const i = this._blocks.indexOf(e);\n      if (!this.validateIndex(i))\n        throw new Error(\"Can't find a Block to remove\");\n      e.destroy(), this._blocks.remove(i), this.blockDidMutated(_o, e, {\n        index: i\n      }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.unsetCurrentBlock(), t && this.insert()), o();\n    });\n  }\n  /**\n   * Remove only selected Blocks\n   * and returns first Block index where started removing...\n   *\n   * @returns {number|undefined}\n   */\n  removeSelectedBlocks() {\n    let e;\n    for (let t = this.blocks.length - 1; t >= 0; t--)\n      this.blocks[t].selected && (this.removeBlock(this.blocks[t]), e = t);\n    return e;\n  }\n  /**\n   * Attention!\n   * After removing insert the new default typed Block and focus on it\n   * Removes all blocks\n   */\n  removeAllBlocks() {\n    for (let e = this.blocks.length - 1; e >= 0; e--)\n      this._blocks.remove(e);\n    this.unsetCurrentBlock(), this.insert(), this.currentBlock.firstInput.focus();\n  }\n  /**\n   * Split current Block\n   * 1. Extract content from Caret position to the Block`s end\n   * 2. Insert a new Block below current one with extracted content\n   *\n   * @returns {Block}\n   */\n  split() {\n    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = d.make(\"div\");\n    t.appendChild(e);\n    const o = {\n      text: d.isEmpty(t) ? \"\" : t.innerHTML\n    };\n    return this.insert({ data: o });\n  }\n  /**\n   * Returns Block by passed index\n   *\n   * @param {number} index - index to get. -1 to get last\n   * @returns {Block}\n   */\n  getBlockByIndex(e) {\n    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];\n  }\n  /**\n   * Returns an index for passed Block\n   *\n   * @param block - block to find index\n   */\n  getBlockIndex(e) {\n    return this._blocks.indexOf(e);\n  }\n  /**\n   * Returns the Block by passed id\n   *\n   * @param id - id of block to get\n   * @returns {Block}\n   */\n  getBlockById(e) {\n    return this._blocks.array.find((t) => t.id === e);\n  }\n  /**\n   * Get Block instance by html element\n   *\n   * @param {Node} element - html element to get Block by\n   */\n  getBlock(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = this._blocks.nodes, o = e.closest(`.${R.CSS.wrapper}`), i = t.indexOf(o);\n    if (i >= 0)\n      return this._blocks[i];\n  }\n  /**\n   * 1) Find first-level Block from passed child Node\n   * 2) Mark it as current\n   *\n   * @param {Node} childNode - look ahead from this node.\n   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance\n   */\n  setCurrentBlockByChildNode(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    if (!t)\n      return;\n    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);\n    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))\n      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;\n  }\n  /**\n   * Return block which contents passed node\n   *\n   * @param {Node} childNode - node to get Block by\n   * @returns {Block}\n   */\n  getBlockByChildNode(e) {\n    if (!e || !(e instanceof Node))\n      return;\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    return this.blocks.find((o) => o.holder === t);\n  }\n  /**\n   * Swap Blocks Position\n   *\n   * @param {number} fromIndex - index of first block\n   * @param {number} toIndex - index of second block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    this._blocks.swap(e, t), this.currentBlockIndex = t;\n  }\n  /**\n   * Move a block to a new index\n   *\n   * @param {number} toIndex - index where to move Block\n   * @param {number} fromIndex - index of Block to move\n   */\n  move(e, t = this.currentBlockIndex) {\n    if (isNaN(e) || isNaN(t)) {\n      S(\"Warning during 'move' call: incorrect indices provided.\", \"warn\");\n      return;\n    }\n    if (!this.validateIndex(e) || !this.validateIndex(t)) {\n      S(\"Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.\", \"warn\");\n      return;\n    }\n    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(ia, this.currentBlock, {\n      fromIndex: t,\n      toIndex: e\n    });\n  }\n  /**\n   * Converts passed Block to the new Tool\n   * Uses Conversion Config\n   *\n   * @param blockToConvert - Block that should be converted\n   * @param targetToolName - name of the Tool to convert to\n   * @param blockDataOverrides - optional new Block data overrides\n   */\n  async convert(e, t, o) {\n    if (!await e.save())\n      throw new Error(\"Could not convert Block. Failed to extract original Block data.\");\n    const s = this.Editor.Tools.blockTools.get(t);\n    if (!s)\n      throw new Error(`Could not convert Block. Tool «${t}» not found.`);\n    const r = await e.exportDataAsString(), a = Z(\n      r,\n      s.sanitizeConfig\n    );\n    let l = Bo(a, s.conversionConfig, s.settings);\n    return o && (l = Object.assign(l, o)), this.replace(e, s.name, l);\n  }\n  /**\n   * Sets current Block Index -1 which means unknown\n   * and clear highlights\n   */\n  unsetCurrentBlock() {\n    this.currentBlockIndex = -1;\n  }\n  /**\n   * Clears Editor\n   *\n   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)\n   *                                             we don't need to add an empty default block\n   *                                        2) in api.blocks.clear we should add empty block\n   */\n  async clear(e = !1) {\n    const t = new sa();\n    this.blocks.forEach((o) => {\n      t.add(async () => {\n        await this.removeBlock(o, !1);\n      });\n    }), await t.completed, this.unsetCurrentBlock(), e && this.insert(), this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Cleans up all the block tools' resources\n   * This is called when editor is destroyed\n   */\n  async destroy() {\n    await Promise.all(this.blocks.map((e) => e.destroy()));\n  }\n  /**\n   * Bind Block events\n   *\n   * @param {Block} block - Block to which event should be bound\n   */\n  bindBlockEvents(e) {\n    const { BlockEvents: t } = this.Editor;\n    this.readOnlyMutableListeners.on(e.holder, \"keydown\", (o) => {\n      t.keydown(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"keyup\", (o) => {\n      t.keyup(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragover\", (o) => {\n      t.dragOver(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragleave\", (o) => {\n      t.dragLeave(o);\n    }), e.on(\"didMutated\", (o) => this.blockDidMutated(Ao, o, {\n      index: this.getBlockIndex(o)\n    }));\n  }\n  /**\n   * Disable mutable handlers and bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Enables all module handlers and bindings for all Blocks\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(\n      document,\n      \"cut\",\n      (e) => this.Editor.BlockEvents.handleCommandX(e)\n    ), this.blocks.forEach((e) => {\n      this.bindBlockEvents(e);\n    });\n  }\n  /**\n   * Validates that the given index is not lower than 0 or higher than the amount of blocks\n   *\n   * @param {number} index - index of blocks array to validate\n   * @returns {boolean}\n   */\n  validateIndex(e) {\n    return !(e < 0 || e >= this._blocks.length);\n  }\n  /**\n   * Block mutation callback\n   *\n   * @param mutationType - what happened with block\n   * @param block - mutated block\n   * @param detailData - additional data to pass with change event\n   */\n  blockDidMutated(e, t, o) {\n    const i = new CustomEvent(e, {\n      detail: {\n        target: new J(t),\n        ...o\n      }\n    });\n    return this.eventsDispatcher.emit($o, {\n      event: i\n    }), t;\n  }\n}\nclass aa extends E {\n  constructor() {\n    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n  }\n  /**\n   * Sanitizer Config\n   *\n   * @returns {SanitizerConfig}\n   */\n  get sanitizerConfig() {\n    return {\n      p: {},\n      h1: {},\n      h2: {},\n      h3: {},\n      h4: {},\n      h5: {},\n      h6: {},\n      ol: {},\n      ul: {},\n      li: {},\n      br: !0,\n      img: {\n        src: !0,\n        width: !0,\n        height: !0\n      },\n      a: {\n        href: !0\n      },\n      b: {},\n      i: {},\n      u: {}\n    };\n  }\n  /**\n   * Flag that identifies all Blocks selection\n   *\n   * @returns {boolean}\n   */\n  get allBlocksSelected() {\n    const { BlockManager: e } = this.Editor;\n    return e.blocks.every((t) => t.selected === !0);\n  }\n  /**\n   * Set selected all blocks\n   *\n   * @param {boolean} state - state to set\n   */\n  set allBlocksSelected(e) {\n    const { BlockManager: t } = this.Editor;\n    t.blocks.forEach((o) => {\n      o.selected = e;\n    }), this.clearCache();\n  }\n  /**\n   * Flag that identifies any Block selection\n   *\n   * @returns {boolean}\n   */\n  get anyBlockSelected() {\n    const { BlockManager: e } = this.Editor;\n    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === !0)), this.anyBlockSelectedCache;\n  }\n  /**\n   * Return selected Blocks array\n   *\n   * @returns {Block[]}\n   */\n  get selectedBlocks() {\n    return this.Editor.BlockManager.blocks.filter((e) => e.selected);\n  }\n  /**\n   * Module Preparation\n   * Registers Shortcuts CMD+A and CMD+C\n   * to select all and copy them\n   */\n  prepare() {\n    this.selection = new b(), ge.add({\n      name: \"CMD+A\",\n      handler: (e) => {\n        const { BlockManager: t, ReadOnly: o } = this.Editor;\n        if (o.isEnabled) {\n          e.preventDefault(), this.selectAllBlocks();\n          return;\n        }\n        t.currentBlock && this.handleCommandA(e);\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Toggle read-only state\n   *\n   *  - Remove all ranges\n   *  - Unselect all Blocks\n   */\n  toggleReadOnly() {\n    b.get().removeAllRanges(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Remove selection of Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  unSelectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear selection from Blocks\n   *\n   * @param {Event} reason - event caused clear of selection\n   * @param {boolean} restoreSelection - if true, restore saved selection\n   */\n  clearSelection(e, t = !1) {\n    const { BlockManager: o, Caret: i, RectangleSelection: s } = this.Editor;\n    this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n    const r = e && e instanceof KeyboardEvent, a = r && Po(e.keyCode);\n    if (this.anyBlockSelected && r && a && !b.isSelectionExists) {\n      const l = o.removeSelectedBlocks();\n      o.insertDefaultBlockAtIndex(l, !0), i.setToBlock(o.currentBlock), Fe(() => {\n        const c = e.key;\n        i.insertContentAtCaretPosition(c.length > 1 ? \"\" : c);\n      }, 20)();\n    }\n    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || s.isRectActivated()) {\n      this.Editor.RectangleSelection.clearSelection();\n      return;\n    }\n    t && this.selection.restore(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Reduce each Block and copy its content\n   *\n   * @param {ClipboardEvent} e - copy/cut event\n   * @returns {Promise<void>}\n   */\n  copySelectedBlocks(e) {\n    e.preventDefault();\n    const t = d.make(\"div\");\n    this.selectedBlocks.forEach((s) => {\n      const r = Z(s.holder.innerHTML, this.sanitizerConfig), a = d.make(\"p\");\n      a.innerHTML = r, t.appendChild(a);\n    });\n    const o = Array.from(t.childNodes).map((s) => s.textContent).join(`\n\n`), i = t.innerHTML;\n    return e.clipboardData.setData(\"text/plain\", o), e.clipboardData.setData(\"text/html\", i), Promise.all(this.selectedBlocks.map((s) => s.save())).then((s) => {\n      try {\n        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(s));\n      } catch {\n      }\n    });\n  }\n  /**\n   * Select Block by its index\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  selectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor, o = t.getBlockByIndex(e);\n    o !== void 0 && this.selectBlock(o);\n  }\n  /**\n   * Select passed Block\n   *\n   * @param {Block} block - Block to select\n   */\n  selectBlock(e) {\n    this.selection.save(), b.get().removeAllRanges(), e.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Remove selection from passed Block\n   *\n   * @param {Block} block - Block to unselect\n   */\n  unselectBlock(e) {\n    e.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear anyBlockSelected cache\n   */\n  clearCache() {\n    this.anyBlockSelectedCache = null;\n  }\n  /**\n   * Module destruction\n   * De-registers Shortcut CMD+A\n   */\n  destroy() {\n    ge.remove(this.Editor.UI.nodes.redactor, \"CMD+A\");\n  }\n  /**\n   * First CMD+A selects all input content by native behaviour,\n   * next CMD+A keypress selects all blocks\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  handleCommandA(e) {\n    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    const t = this.Editor.BlockManager.getBlock(e.target), o = t.inputs;\n    if (o.length > 1 && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    if (o.length === 1 && !this.needToSelectAll) {\n      this.needToSelectAll = !0;\n      return;\n    }\n    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t), this.needToSelectAll = !0);\n  }\n  /**\n   * Select All Blocks\n   * Each Block has selected setter that makes Block copyable\n   */\n  selectAllBlocks() {\n    this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();\n  }\n}\nclass Ye extends E {\n  /**\n   * Allowed caret positions in input\n   *\n   * @static\n   * @returns {{START: string, END: string, DEFAULT: string}}\n   */\n  get positions() {\n    return {\n      START: \"start\",\n      END: \"end\",\n      DEFAULT: \"default\"\n    };\n  }\n  /**\n   * Elements styles that can be useful for Caret Module\n   */\n  static get CSS() {\n    return {\n      shadowCaret: \"cdx-shadow-caret\"\n    };\n  }\n  /**\n   * Method gets Block instance and puts caret to the text node with offset\n   * There two ways that method applies caret position:\n   *   - first found text node: sets at the beginning, but you can pass an offset\n   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour\n   *\n   * @param {Block} block - Block class\n   * @param {string} position - position where to set caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToBlock(e, t = this.positions.DEFAULT, o = 0) {\n    var c;\n    const { BlockManager: i, BlockSelection: s } = this.Editor;\n    if (s.clearSelection(), !e.focusable) {\n      (c = window.getSelection()) == null || c.removeAllRanges(), s.selectBlock(e), i.currentBlock = e;\n      return;\n    }\n    let r;\n    switch (t) {\n      case this.positions.START:\n        r = e.firstInput;\n        break;\n      case this.positions.END:\n        r = e.lastInput;\n        break;\n      default:\n        r = e.currentInput;\n    }\n    if (!r)\n      return;\n    const a = d.getDeepestNode(r, t === this.positions.END), l = d.getContentLength(a);\n    switch (!0) {\n      case t === this.positions.START:\n        o = 0;\n        break;\n      case t === this.positions.END:\n      case o > l:\n        o = l;\n        break;\n    }\n    this.set(a, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;\n  }\n  /**\n   * Set caret to the current input of current Block.\n   *\n   * @param {HTMLElement} input - input where caret should be set\n   * @param {string} position - position of the caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToInput(e, t = this.positions.DEFAULT, o = 0) {\n    const { currentBlock: i } = this.Editor.BlockManager, s = d.getDeepestNode(e);\n    switch (t) {\n      case this.positions.START:\n        this.set(s, 0);\n        break;\n      case this.positions.END:\n        this.set(s, d.getContentLength(s));\n        break;\n      default:\n        o && this.set(s, o);\n    }\n    i.currentInput = e;\n  }\n  /**\n   * Creates Document Range and sets caret to the element with offset\n   *\n   * @param {HTMLElement} element - target node.\n   * @param {number} offset - offset\n   */\n  set(e, t = 0) {\n    const { top: i, bottom: s } = b.setCursor(e, t), { innerHeight: r } = window;\n    i < 0 ? window.scrollBy(0, i - 30) : s > r && window.scrollBy(0, s - r + 30);\n  }\n  /**\n   * Set Caret to the last Block\n   * If last block is not empty, append another empty block\n   */\n  setToTheLastBlock() {\n    const e = this.Editor.BlockManager.lastBlock;\n    if (e)\n      if (e.tool.isDefault && e.isEmpty)\n        this.setToBlock(e);\n      else {\n        const t = this.Editor.BlockManager.insertAtEnd();\n        this.setToBlock(t);\n      }\n  }\n  /**\n   * Extract content fragment of current Block from Caret position to the end of the Block\n   */\n  extractFragmentFromCaretPosition() {\n    const e = b.get();\n    if (e.rangeCount) {\n      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;\n      if (t.deleteContents(), o)\n        if (d.isNativeInput(o)) {\n          const i = o, s = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);\n          return s.textContent = a, i.value = r, s;\n        } else {\n          const i = t.cloneRange();\n          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();\n        }\n    }\n  }\n  /**\n   * Set's caret to the next Block or Tool`s input\n   * Before moving caret, we should check if caret position is at the end of Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigateNext(e = !1) {\n    const { BlockManager: t } = this.Editor, { currentBlock: o, nextBlock: i } = t;\n    if (o === void 0)\n      return !1;\n    const { nextInput: s, currentInput: r } = o, a = r !== void 0 ? Re(r) : void 0;\n    let l = i;\n    const c = e || a || !o.focusable;\n    if (s && c)\n      return this.setToInput(s, this.positions.START), !0;\n    if (l === null) {\n      if (o.tool.isDefault || !c)\n        return !1;\n      l = t.insertAtEnd();\n    }\n    return c ? (this.setToBlock(l, this.positions.START), !0) : !1;\n  }\n  /**\n   * Set's caret to the previous Tool`s input or Block\n   * Before moving caret, we should check if caret position is start of the Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigatePrevious(e = !1) {\n    const { currentBlock: t, previousBlock: o } = this.Editor.BlockManager;\n    if (!t)\n      return !1;\n    const { previousInput: i, currentInput: s } = t, r = s !== void 0 ? Ne(s) : void 0, a = e || r || !t.focusable;\n    return i && a ? (this.setToInput(i, this.positions.END), !0) : o !== null && a ? (this.setToBlock(o, this.positions.END), !0) : !1;\n  }\n  /**\n   * Inserts shadow element after passed element where caret can be placed\n   *\n   * @param {Element} element - element after which shadow caret should be inserted\n   */\n  createShadow(e) {\n    const t = document.createElement(\"span\");\n    t.classList.add(Ye.CSS.shadowCaret), e.insertAdjacentElement(\"beforeend\", t);\n  }\n  /**\n   * Restores caret position\n   *\n   * @param {HTMLElement} element - element where caret should be restored\n   */\n  restoreCaret(e) {\n    const t = e.querySelector(`.${Ye.CSS.shadowCaret}`);\n    if (!t)\n      return;\n    new b().expandToTag(t);\n    const i = document.createRange();\n    i.selectNode(t), i.extractContents();\n  }\n  /**\n   * Inserts passed content at caret position\n   *\n   * @param {string} content - content to insert\n   */\n  insertContentAtCaretPosition(e) {\n    const t = document.createDocumentFragment(), o = document.createElement(\"div\"), i = b.get(), s = b.range;\n    o.innerHTML = e, Array.from(o.childNodes).forEach((c) => t.appendChild(c)), t.childNodes.length === 0 && t.appendChild(new Text());\n    const r = t.lastChild;\n    s.deleteContents(), s.insertNode(t);\n    const a = document.createRange(), l = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;\n    l !== null && l.textContent !== null && a.setStart(l, l.textContent.length), i.removeAllRanges(), i.addRange(a);\n  }\n}\nclass la extends E {\n  constructor() {\n    super(...arguments), this.onMouseUp = () => {\n      this.listeners.off(document, \"mouseover\", this.onMouseOver), this.listeners.off(document, \"mouseup\", this.onMouseUp);\n    }, this.onMouseOver = (e) => {\n      const { BlockManager: t, BlockSelection: o } = this.Editor;\n      if (e.relatedTarget === null && e.target === null)\n        return;\n      const i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, s = t.getBlockByChildNode(e.target);\n      if (!(!i || !s) && s !== i) {\n        if (i === this.firstSelectedBlock) {\n          b.get().removeAllRanges(), i.selected = !0, s.selected = !0, o.clearCache();\n          return;\n        }\n        if (s === this.firstSelectedBlock) {\n          i.selected = !1, s.selected = !1, o.clearCache();\n          return;\n        }\n        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, s), this.lastSelectedBlock = s;\n      }\n    };\n  }\n  /**\n   * Module preparation\n   *\n   * @returns {Promise}\n   */\n  async prepare() {\n    this.listeners.on(document, \"mousedown\", (e) => {\n      this.enableCrossBlockSelection(e);\n    });\n  }\n  /**\n   * Sets up listeners\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  watchSelection(e) {\n    if (e.button !== qn.LEFT)\n      return;\n    const { BlockManager: t } = this.Editor;\n    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, \"mouseover\", this.onMouseOver), this.listeners.on(document, \"mouseup\", this.onMouseUp);\n  }\n  /**\n   * Return boolean is cross block selection started:\n   * there should be at least 2 selected blocks\n   */\n  get isCrossBlockSelectionStarted() {\n    return !!this.firstSelectedBlock && !!this.lastSelectedBlock && this.firstSelectedBlock !== this.lastSelectedBlock;\n  }\n  /**\n   * Change selection state of the next Block\n   * Used for CBS via Shift + arrow keys\n   *\n   * @param {boolean} next - if true, toggle next block. Previous otherwise\n   */\n  toggleBlockSelectedState(e = !0) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), b.get().removeAllRanges());\n    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), s = t.blocks[i];\n    s && (this.lastSelectedBlock.selected !== s.selected ? (s.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = s, this.Editor.InlineToolbar.close(), s.holder.scrollIntoView({\n      block: \"nearest\"\n    }));\n  }\n  /**\n   * Clear saved state\n   *\n   * @param {Event} reason - event caused clear of selection\n   */\n  clear(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, s = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);\n    if (o.anyBlockSelected && s > -1 && r > -1 && e && e instanceof KeyboardEvent)\n      switch (e.keyCode) {\n        case y.DOWN:\n        case y.RIGHT:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n          break;\n        case y.UP:\n        case y.LEFT:\n          i.setToBlock(t.blocks[Math.min(s, r)], i.positions.START);\n          break;\n        default:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n      }\n    this.firstSelectedBlock = this.lastSelectedBlock = null;\n  }\n  /**\n   * Enables Cross Block Selection\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  enableCrossBlockSelection(e) {\n    const { UI: t } = this.Editor;\n    b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Change blocks selection state between passed two blocks.\n   *\n   * @param {Block} firstBlock - first block in range\n   * @param {Block} lastBlock - last block in range\n   */\n  toggleBlocksSelectedState(e, t) {\n    const { BlockManager: o, BlockSelection: i } = this.Editor, s = o.blocks.indexOf(e), r = o.blocks.indexOf(t), a = e.selected !== t.selected;\n    for (let l = Math.min(s, r); l <= Math.max(s, r); l++) {\n      const c = o.blocks[l];\n      c !== this.firstSelectedBlock && c !== (a ? e : t) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());\n    }\n  }\n}\nclass ca extends E {\n  constructor() {\n    super(...arguments), this.isStartedAtEditor = !1;\n  }\n  /**\n   * Toggle read-only state\n   *\n   * if state is true:\n   *  - disable all drag-n-drop event handlers\n   *\n   * if state is false:\n   *  - restore drag-n-drop event handlers\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Add drag events listeners to editor zone\n   */\n  enableModuleBindings() {\n    const { UI: e } = this.Editor;\n    this.readOnlyMutableListeners.on(e.nodes.holder, \"drop\", async (t) => {\n      await this.processDrop(t);\n    }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragstart\", () => {\n      this.processDragStart();\n    }), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragover\", (t) => {\n      this.processDragOver(t);\n    }, !0);\n  }\n  /**\n   * Unbind drag-n-drop event handlers\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Handle drop event\n   *\n   * @param {DragEvent} dropEvent - drop event\n   */\n  async processDrop(e) {\n    const {\n      BlockManager: t,\n      Paste: o,\n      Caret: i\n    } = this.Editor;\n    e.preventDefault(), t.blocks.forEach((r) => {\n      r.dropTarget = !1;\n    }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand(\"delete\"), this.isStartedAtEditor = !1;\n    const s = t.setCurrentBlockByChildNode(e.target);\n    if (s)\n      this.Editor.Caret.setToBlock(s, i.positions.END);\n    else {\n      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);\n      this.Editor.Caret.setToBlock(r, i.positions.END);\n    }\n    await o.processDataTransfer(e.dataTransfer, !0);\n  }\n  /**\n   * Handle drag start event\n   */\n  processDragStart() {\n    b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * @param {DragEvent} dragEvent - drag event\n   */\n  processDragOver(e) {\n    e.preventDefault();\n  }\n}\nconst da = 180, ua = 400;\nclass ha extends E {\n  /**\n   * Prepare the module\n   *\n   * @param options - options used by the modification observer module\n   * @param options.config - Editor configuration object\n   * @param options.eventsDispatcher - common Editor event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = ua, this.mutationObserver = new MutationObserver((o) => {\n      this.redactorChanged(o);\n    }), this.eventsDispatcher.on($o, (o) => {\n      this.particularBlockChanged(o.event);\n    }), this.eventsDispatcher.on(zo, () => {\n      this.disable();\n    }), this.eventsDispatcher.on(Uo, () => {\n      this.enable();\n    });\n  }\n  /**\n   * Enables onChange event\n   */\n  enable() {\n    this.mutationObserver.observe(\n      this.Editor.UI.nodes.redactor,\n      {\n        childList: !0,\n        subtree: !0,\n        characterData: !0,\n        attributes: !0\n      }\n    ), this.disabled = !1;\n  }\n  /**\n   * Disables onChange event\n   */\n  disable() {\n    this.mutationObserver.disconnect(), this.disabled = !0;\n  }\n  /**\n   * Call onChange event passed to Editor.js configuration\n   *\n   * @param event - some of our custom change events\n   */\n  particularBlockChanged(e) {\n    this.disabled || !A(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {\n      let t;\n      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();\n    }, this.batchTime));\n  }\n  /**\n   * Fired on every blocks wrapper dom change\n   *\n   * @param mutations - mutations happened\n   */\n  redactorChanged(e) {\n    this.eventsDispatcher.emit(ft, {\n      mutations: e\n    });\n  }\n}\nconst Rn = class Dn extends E {\n  constructor() {\n    super(...arguments), this.MIME_TYPE = \"application/x-editor-js\", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (e) => {\n      try {\n        const t = e.create({}, {}, !1);\n        if (e.pasteConfig === !1) {\n          this.exceptionList.push(e.name);\n          return;\n        }\n        if (!A(t.onPaste))\n          return;\n        this.getTagsConfig(e), this.getFilesConfig(e), this.getPatternsConfig(e);\n      } catch (t) {\n        S(\n          `Paste handling for «${e.name}» Tool hasn't been set up because of the error`,\n          \"warn\",\n          t\n        );\n      }\n    }, this.handlePasteEvent = async (e) => {\n      const { BlockManager: t, Toolbar: o } = this.Editor, i = t.setCurrentBlockByChildNode(e.target);\n      !i || this.isNativeBehaviour(e.target) && !e.clipboardData.types.includes(\"Files\") || i && this.exceptionList.includes(i.name) || (e.preventDefault(), this.processDataTransfer(e.clipboardData), o.close());\n    };\n  }\n  /**\n   * Set onPaste callback and collect tools` paste configurations\n   */\n  async prepare() {\n    this.processTools();\n  }\n  /**\n   * Set read-only state\n   *\n   * @param {boolean} readOnlyEnabled - read only flag value\n   */\n  toggleReadOnly(e) {\n    e ? this.unsetCallback() : this.setCallback();\n  }\n  /**\n   * Handle pasted or dropped data transfer object\n   *\n   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object\n   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events\n   */\n  async processDataTransfer(e, t = !1) {\n    const { Tools: o } = this.Editor, i = e.types;\n    if ((i.includes ? i.includes(\"Files\") : i.contains(\"Files\")) && !V(this.toolsFiles)) {\n      await this.processFiles(e.files);\n      return;\n    }\n    const r = e.getData(this.MIME_TYPE), a = e.getData(\"text/plain\");\n    let l = e.getData(\"text/html\");\n    if (r)\n      try {\n        this.insertEditorJSData(JSON.parse(r));\n        return;\n      } catch {\n      }\n    t && a.trim() && l.trim() && (l = \"<p>\" + (l.trim() ? l : a) + \"</p>\");\n    const c = Object.keys(this.toolsTags).reduce((p, g) => (p[g.toLowerCase()] = this.toolsTags[g].sanitizationConfig ?? {}, p), {}), u = Object.assign({}, c, o.getAllInlineToolsSanitizeConfig(), { br: {} }), h = Z(l, u);\n    !h.trim() || h.trim() === a || !d.isHTMLString(h) ? await this.processText(a) : await this.processText(h, !0);\n  }\n  /**\n   * Process pasted text and divide them into Blocks\n   *\n   * @param {string} data - text to process. Can be HTML or plain.\n   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true\n   */\n  async processText(e, t = !1) {\n    const { Caret: o, BlockManager: i } = this.Editor, s = t ? this.processHTML(e) : this.processPlain(e);\n    if (!s.length)\n      return;\n    if (s.length === 1) {\n      s[0].isBlock ? this.processSingleBlock(s.pop()) : this.processInlinePaste(s.pop());\n      return;\n    }\n    const a = i.currentBlock && i.currentBlock.tool.isDefault && i.currentBlock.isEmpty;\n    s.map(\n      async (l, c) => this.insertBlock(l, c === 0 && a)\n    ), i.currentBlock && o.setToBlock(i.currentBlock, o.positions.END);\n  }\n  /**\n   * Set onPaste callback handler\n   */\n  setCallback() {\n    this.listeners.on(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Unset onPaste callback handler\n   */\n  unsetCallback() {\n    this.listeners.off(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Get and process tool`s paste configs\n   */\n  processTools() {\n    const e = this.Editor.Tools.blockTools;\n    Array.from(e.values()).forEach(this.processTool);\n  }\n  /**\n   * Get tags name list from either tag name or sanitization config.\n   *\n   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.\n   * @returns {string[]} array of tags.\n   */\n  collectTagNames(e) {\n    return te(e) ? [e] : D(e) ? Object.keys(e) : [];\n  }\n  /**\n   * Get tags to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getTagsConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const t = e.pasteConfig.tags || [], o = [];\n    t.forEach((i) => {\n      const s = this.collectTagNames(i);\n      o.push(...s), s.forEach((r) => {\n        if (Object.prototype.hasOwnProperty.call(this.toolsTags, r)) {\n          S(\n            `Paste handler for «${e.name}» Tool on «${r}» tag is skipped because it is already used by «${this.toolsTags[r].tool.name}» Tool.`,\n            \"warn\"\n          );\n          return;\n        }\n        const a = D(i) ? i[r] : null;\n        this.toolsTags[r.toUpperCase()] = {\n          tool: e,\n          sanitizationConfig: a\n        };\n      });\n    }), this.tagsByTool[e.name] = o.map((i) => i.toUpperCase());\n  }\n  /**\n   * Get files` types and extensions to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getFilesConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const { files: t = {} } = e.pasteConfig;\n    let { extensions: o, mimeTypes: i } = t;\n    !o && !i || (o && !Array.isArray(o) && (S(`«extensions» property of the onDrop config for «${e.name}» Tool should be an array`), o = []), i && !Array.isArray(i) && (S(`«mimeTypes» property of the onDrop config for «${e.name}» Tool should be an array`), i = []), i && (i = i.filter((s) => ei(s) ? !0 : (S(`MIME type value «${s}» for the «${e.name}» Tool is not a valid MIME type`, \"warn\"), !1))), this.toolsFiles[e.name] = {\n      extensions: o || [],\n      mimeTypes: i || []\n    });\n  }\n  /**\n   * Get RegExp patterns to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getPatternsConfig(e) {\n    e.pasteConfig === !1 || !e.pasteConfig.patterns || V(e.pasteConfig.patterns) || Object.entries(e.pasteConfig.patterns).forEach(([t, o]) => {\n      o instanceof RegExp || S(\n        `Pattern ${o} for «${e.name}» Tool is skipped because it should be a Regexp instance.`,\n        \"warn\"\n      ), this.toolsPatterns.push({\n        key: t,\n        pattern: o,\n        tool: e\n      });\n    });\n  }\n  /**\n   * Check if browser behavior suits better\n   *\n   * @param {EventTarget} element - element where content has been pasted\n   * @returns {boolean}\n   */\n  isNativeBehaviour(e) {\n    return d.isNativeInput(e);\n  }\n  /**\n   * Get files from data transfer object and insert related Tools\n   *\n   * @param {FileList} items - pasted or dropped items\n   */\n  async processFiles(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    o = await Promise.all(\n      Array.from(e).map((r) => this.processFile(r))\n    ), o = o.filter((r) => !!r);\n    const s = t.currentBlock.tool.isDefault && t.currentBlock.isEmpty;\n    o.forEach(\n      (r, a) => {\n        t.paste(r.type, r.event, a === 0 && s);\n      }\n    );\n  }\n  /**\n   * Get information about file and find Tool to handle it\n   *\n   * @param {File} file - file to process\n   */\n  async processFile(e) {\n    const t = Jn(e), o = Object.entries(this.toolsFiles).find(([r, { mimeTypes: a, extensions: l }]) => {\n      const [c, u] = e.type.split(\"/\"), h = l.find((g) => g.toLowerCase() === t.toLowerCase()), p = a.find((g) => {\n        const [f, v] = g.split(\"/\");\n        return f === c && (v === u || v === \"*\");\n      });\n      return !!h || !!p;\n    });\n    if (!o)\n      return;\n    const [i] = o;\n    return {\n      event: this.composePasteEvent(\"file\", {\n        file: e\n      }),\n      type: i\n    };\n  }\n  /**\n   * Split HTML string to blocks and return it as array of Block data\n   *\n   * @param {string} innerHTML - html string to process\n   * @returns {PasteData[]}\n   */\n  processHTML(e) {\n    const { Tools: t } = this.Editor, o = d.make(\"DIV\");\n    return o.innerHTML = e, this.getNodes(o).map((s) => {\n      let r, a = t.defaultTool, l = !1;\n      switch (s.nodeType) {\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          r = d.make(\"div\"), r.appendChild(s);\n          break;\n        case Node.ELEMENT_NODE:\n          r = s, l = !0, this.toolsTags[r.tagName] && (a = this.toolsTags[r.tagName].tool);\n          break;\n      }\n      const { tags: c } = a.pasteConfig || { tags: [] }, u = c.reduce((g, f) => (this.collectTagNames(f).forEach((O) => {\n        const T = D(f) ? f[O] : null;\n        g[O.toLowerCase()] = T || {};\n      }), g), {}), h = Object.assign({}, u, a.baseSanitizeConfig);\n      if (r.tagName.toLowerCase() === \"table\") {\n        const g = Z(r.outerHTML, h);\n        r = d.make(\"div\", void 0, {\n          innerHTML: g\n        }).firstChild;\n      } else\n        r.innerHTML = Z(r.innerHTML, h);\n      const p = this.composePasteEvent(\"tag\", {\n        data: r\n      });\n      return {\n        content: r,\n        isBlock: l,\n        tool: a.name,\n        event: p\n      };\n    }).filter((s) => {\n      const r = d.isEmpty(s.content), a = d.isSingleTag(s.content);\n      return !r || a;\n    });\n  }\n  /**\n   * Split plain text by new line symbols and return it as array of Block data\n   *\n   * @param {string} plain - string to process\n   * @returns {PasteData[]}\n   */\n  processPlain(e) {\n    const { defaultBlock: t } = this.config;\n    if (!e)\n      return [];\n    const o = t;\n    return e.split(/\\r?\\n/).filter((i) => i.trim()).map((i) => {\n      const s = d.make(\"div\");\n      s.textContent = i;\n      const r = this.composePasteEvent(\"tag\", {\n        data: s\n      });\n      return {\n        content: s,\n        tool: o,\n        isBlock: !1,\n        event: r\n      };\n    });\n  }\n  /**\n   * Process paste of single Block tool content\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processSingleBlock(e) {\n    const { Caret: t, BlockManager: o } = this.Editor, { currentBlock: i } = o;\n    if (!i || e.tool !== i.name || !d.containsOnlyInlineElements(e.content.innerHTML)) {\n      this.insertBlock(e, (i == null ? void 0 : i.tool.isDefault) && i.isEmpty);\n      return;\n    }\n    t.insertContentAtCaretPosition(e.content.innerHTML);\n  }\n  /**\n   * Process paste to single Block:\n   * 1. Find patterns` matches\n   * 2. Insert new block if it is not the same type as current one\n   * 3. Just insert text if there is no substitutions\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processInlinePaste(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { content: i } = e;\n    if (t.currentBlock && t.currentBlock.tool.isDefault && i.textContent.length < Dn.PATTERN_PROCESSING_MAX_LENGTH) {\n      const r = await this.processPattern(i.textContent);\n      if (r) {\n        const a = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty, l = t.paste(r.tool, r.event, a);\n        o.setToBlock(l, o.positions.END);\n        return;\n      }\n    }\n    if (t.currentBlock && t.currentBlock.currentInput) {\n      const r = t.currentBlock.tool.baseSanitizeConfig;\n      document.execCommand(\n        \"insertHTML\",\n        !1,\n        Z(i.innerHTML, r)\n      );\n    } else\n      this.insertBlock(e);\n  }\n  /**\n   * Get patterns` matches\n   *\n   * @param {string} text - text to process\n   * @returns {Promise<{event: PasteEvent, tool: string}>}\n   */\n  async processPattern(e) {\n    const t = this.toolsPatterns.find((i) => {\n      const s = i.pattern.exec(e);\n      return s ? e === s.shift() : !1;\n    });\n    return t ? {\n      event: this.composePasteEvent(\"pattern\", {\n        key: t.key,\n        data: e\n      }),\n      tool: t.tool.name\n    } : void 0;\n  }\n  /**\n   * Insert pasted Block content to Editor\n   *\n   * @param {PasteData} data - data to insert\n   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block\n   * @returns {void}\n   */\n  insertBlock(e, t = !1) {\n    const { BlockManager: o, Caret: i } = this.Editor, { currentBlock: s } = o;\n    let r;\n    if (t && s && s.isEmpty) {\n      r = o.paste(e.tool, e.event, !0), i.setToBlock(r, i.positions.END);\n      return;\n    }\n    r = o.paste(e.tool, e.event), i.setToBlock(r, i.positions.END);\n  }\n  /**\n   * Insert data passed as application/x-editor-js JSON\n   *\n   * @param {Array} blocks — Blocks' data to insert\n   * @returns {void}\n   */\n  insertEditorJSData(e) {\n    const { BlockManager: t, Caret: o, Tools: i } = this.Editor;\n    yt(\n      e,\n      (r) => i.blockTools.get(r).sanitizeConfig\n    ).forEach(({ tool: r, data: a }, l) => {\n      let c = !1;\n      l === 0 && (c = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty);\n      const u = t.insert({\n        tool: r,\n        data: a,\n        replace: c\n      });\n      o.setToBlock(u, o.positions.END);\n    });\n  }\n  /**\n   * Fetch nodes from Element node\n   *\n   * @param {Node} node - current node\n   * @param {Node[]} nodes - processed nodes\n   * @param {Node} destNode - destination node\n   */\n  processElementNode(e, t, o) {\n    const i = Object.keys(this.toolsTags), s = e, { tool: r } = this.toolsTags[s.tagName] || {}, a = this.tagsByTool[r == null ? void 0 : r.name] || [], l = i.includes(s.tagName), c = d.blockElements.includes(s.tagName.toLowerCase()), u = Array.from(s.children).some(\n      ({ tagName: p }) => i.includes(p) && !a.includes(p)\n    ), h = Array.from(s.children).some(\n      ({ tagName: p }) => d.blockElements.includes(p.toLowerCase())\n    );\n    if (!c && !l && !u)\n      return o.appendChild(s), [...t, o];\n    if (l && !u || c && !h && !u)\n      return [...t, o, s];\n  }\n  /**\n   * Recursively divide HTML string to two types of nodes:\n   * 1. Block element\n   * 2. Document Fragments contained text and markup tags like a, b, i etc.\n   *\n   * @param {Node} wrapper - wrapper of paster HTML content\n   * @returns {Node[]}\n   */\n  getNodes(e) {\n    const t = Array.from(e.childNodes);\n    let o;\n    const i = (s, r) => {\n      if (d.isEmpty(r) && !d.isSingleTag(r))\n        return s;\n      const a = s[s.length - 1];\n      let l = new DocumentFragment();\n      switch (a && d.isFragment(a) && (l = s.pop()), r.nodeType) {\n        case Node.ELEMENT_NODE:\n          if (o = this.processElementNode(r, s, l), o)\n            return o;\n          break;\n        case Node.TEXT_NODE:\n          return l.appendChild(r), [...s, l];\n        default:\n          return [...s, l];\n      }\n      return [...s, ...Array.from(r.childNodes).reduce(i, [])];\n    };\n    return t.reduce(i, []);\n  }\n  /**\n   * Compose paste event with passed type and detail\n   *\n   * @param {string} type - event type\n   * @param {PasteEventDetail} detail - event detail\n   */\n  composePasteEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n};\nRn.PATTERN_PROCESSING_MAX_LENGTH = 450;\nlet pa = Rn;\nclass fa extends E {\n  constructor() {\n    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;\n  }\n  /**\n   * Returns state of read only mode\n   */\n  get isEnabled() {\n    return this.readOnlyEnabled;\n  }\n  /**\n   * Set initial state\n   */\n  async prepare() {\n    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];\n    Array.from(t.entries()).forEach(([i, s]) => {\n      s.isReadOnlySupported || o.push(i);\n    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly, !0);\n  }\n  /**\n   * Set read-only mode or toggle current state\n   * Call all Modules `toggleReadOnly` method and re-render Editor\n   *\n   * @param state - (optional) read-only state or toggle\n   * @param isInitial - (optional) true when editor is initializing\n   */\n  async toggle(e = !this.readOnlyEnabled, t = !1) {\n    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();\n    const o = this.readOnlyEnabled;\n    this.readOnlyEnabled = e;\n    for (const s in this.Editor)\n      this.Editor[s].toggleReadOnly && this.Editor[s].toggleReadOnly(e);\n    if (o === e)\n      return this.readOnlyEnabled;\n    if (t)\n      return this.readOnlyEnabled;\n    this.Editor.ModificationsObserver.disable();\n    const i = await this.Editor.Saver.save();\n    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(i.blocks), this.Editor.ModificationsObserver.enable(), this.readOnlyEnabled;\n  }\n  /**\n   * Throws an error about tools which don't support read-only mode\n   */\n  throwCriticalError() {\n    throw new Ho(\n      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(\", \")} don't support read-only mode.`\n    );\n  }\n}\nclass Be extends E {\n  constructor() {\n    super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      overlay: \"codex-editor-overlay\",\n      overlayContainer: \"codex-editor-overlay__container\",\n      rect: \"codex-editor-overlay__rectangle\",\n      topScrollZone: \"codex-editor-overlay__scroll-zone--top\",\n      bottomScrollZone: \"codex-editor-overlay__scroll-zone--bottom\"\n    };\n  }\n  /**\n   * Module Preparation\n   * Creating rect and hang handlers\n   */\n  prepare() {\n    this.enableModuleBindings();\n  }\n  /**\n   * Init rect params\n   *\n   * @param {number} pageX - X coord of mouse\n   * @param {number} pageY - Y coord of mouse\n   */\n  startSelection(e, t) {\n    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);\n    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);\n    const s = [\n      `.${R.CSS.content}`,\n      `.${this.Editor.Toolbar.CSS.toolbar}`,\n      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`\n    ], r = o.closest(\".\" + this.Editor.UI.CSS.editorWrapper), a = s.some((l) => !!o.closest(l));\n    !r || a || (this.mousedown = !0, this.startX = e, this.startY = t);\n  }\n  /**\n   * Clear all params to end selection\n   */\n  endSelection() {\n    this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = \"none\";\n  }\n  /**\n   * is RectSelection Activated\n   */\n  isRectActivated() {\n    return this.isRectSelectionActivated;\n  }\n  /**\n   * Mark that selection is end\n   */\n  clearSelection() {\n    this.isRectSelectionActivated = !1;\n  }\n  /**\n   * Sets Module necessary event handlers\n   */\n  enableModuleBindings() {\n    const { container: e } = this.genHTML();\n    this.listeners.on(e, \"mousedown\", (t) => {\n      this.processMouseDown(t);\n    }, !1), this.listeners.on(document.body, \"mousemove\", dt((t) => {\n      this.processMouseMove(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseleave\", () => {\n      this.processMouseLeave();\n    }), this.listeners.on(window, \"scroll\", dt((t) => {\n      this.processScroll(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseup\", () => {\n      this.processMouseUp();\n    }, !1);\n  }\n  /**\n   * Handle mouse down events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseDown(e) {\n    if (e.button !== this.MAIN_MOUSE_BUTTON)\n      return;\n    e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);\n  }\n  /**\n   * Handle mouse move events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseMove(e) {\n    this.changingRectangle(e), this.scrollByZones(e.clientY);\n  }\n  /**\n   * Handle mouse leave\n   */\n  processMouseLeave() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processScroll(e) {\n    this.changingRectangle(e);\n  }\n  /**\n   * Handle mouse up\n   */\n  processMouseUp() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * Scroll If mouse in scroll zone\n   *\n   * @param {number} clientY - Y coord of mouse\n   */\n  scrollByZones(e) {\n    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {\n      this.isScrolling = !1;\n      return;\n    }\n    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);\n  }\n  /**\n   * Generates required HTML elements\n   *\n   * @returns {Object<string, Element>}\n   */\n  genHTML() {\n    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector(\".\" + e.CSS.editorWrapper), o = d.make(\"div\", Be.CSS.overlay, {}), i = d.make(\"div\", Be.CSS.overlayContainer, {}), s = d.make(\"div\", Be.CSS.rect, {});\n    return i.appendChild(s), o.appendChild(i), t.appendChild(o), this.overlayRectangle = s, {\n      container: t,\n      overlay: o\n    };\n  }\n  /**\n   * Activates scrolling if blockSelection is active and mouse is in scroll zone\n   *\n   * @param {number} speed - speed of scrolling\n   */\n  scrollVertical(e) {\n    if (!(this.inScrollZone && this.mousedown))\n      return;\n    const t = window.pageYOffset;\n    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {\n      this.scrollVertical(e);\n    }, 0);\n  }\n  /**\n   * Handles the change in the rectangle and its effect\n   *\n   * @param {MouseEvent} event - mouse event\n   */\n  changingRectangle(e) {\n    if (!this.mousedown)\n      return;\n    e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);\n    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), s = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;\n    this.rectCrossesBlocks = !(s || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = \"block\"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());\n  }\n  /**\n   * Shrink rect to singular point\n   */\n  shrinkRectangleToPoint() {\n    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;\n  }\n  /**\n   * Select or unselect all of blocks in array if rect is out or in selectable area\n   */\n  inverseSelection() {\n    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;\n    if (this.rectCrossesBlocks && !t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.selectBlockByIndex(o);\n    if (!this.rectCrossesBlocks && t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.unSelectBlockByIndex(o);\n  }\n  /**\n   * Updates size of rectangle\n   */\n  updateRectangleSize() {\n    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);\n  }\n  /**\n   * Collects information needed to determine the behavior of the rectangle\n   *\n   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border\n   */\n  genInfoForMouseSelection() {\n    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), s = this.Editor.BlockManager.getBlockByChildNode(i);\n    let r;\n    s !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === s.holder));\n    const a = this.Editor.BlockManager.lastBlock.holder.querySelector(\".\" + R.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, c = t - l, u = t + l;\n    return {\n      index: r,\n      leftPos: c,\n      rightPos: u\n    };\n  }\n  /**\n   * Select block with index index\n   *\n   * @param index - index of block in redactor\n   */\n  addBlockInSelection(e) {\n    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);\n  }\n  /**\n   * Adds a block to the selection and determines which blocks should be selected\n   *\n   * @param {object} index - index of new block in the reactor\n   */\n  trySelectNextBlock(e) {\n    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, s = -1, r = 0;\n    if (t)\n      return;\n    const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;\n    let l = r;\n    o > 1 && (l = a ? i : s);\n    const c = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === s, p = !(c || u || l === r);\n    if (!p && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {\n      let v = this.stackOfSelected[o - 1] + 1 || e;\n      for (v; v <= e; v++)\n        this.addBlockInSelection(v);\n      return;\n    }\n    if (!p && e < this.stackOfSelected[o - 1]) {\n      for (let v = this.stackOfSelected[o - 1] - 1; v >= e; v--)\n        this.addBlockInSelection(v);\n      return;\n    }\n    if (!p)\n      return;\n    let g = o - 1, f;\n    for (e > this.stackOfSelected[o - 1] ? f = () => e > this.stackOfSelected[g] : f = () => e < this.stackOfSelected[g]; f(); )\n      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[g]), this.stackOfSelected.pop(), g--;\n  }\n}\nclass ga extends E {\n  /**\n   * Renders passed blocks as one batch\n   *\n   * @param blocksData - blocks to render\n   */\n  async render(e) {\n    return new Promise((t) => {\n      const { Tools: o, BlockManager: i } = this.Editor;\n      if (e.length === 0)\n        i.insert();\n      else {\n        const s = e.map(({ type: r, data: a, tunes: l, id: c }) => {\n          o.available.has(r) === !1 && (X(`Tool «${r}» is not found. Check 'tools' property at the Editor.js config.`, \"warn\"), a = this.composeStubDataForTool(r, a, c), r = o.stubTool);\n          let u;\n          try {\n            u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          } catch (h) {\n            S(`Block «${r}» skipped because of plugins error`, \"error\", {\n              data: a,\n              error: h\n            }), a = this.composeStubDataForTool(r, a, c), r = o.stubTool, u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          }\n          return u;\n        });\n        i.insertMany(s);\n      }\n      window.requestIdleCallback(() => {\n        t();\n      }, { timeout: 2e3 });\n    });\n  }\n  /**\n   * Create data for the Stub Tool that will be used instead of unavailable tool\n   *\n   * @param tool - unavailable tool name to stub\n   * @param data - data of unavailable block\n   * @param [id] - id of unavailable block\n   */\n  composeStubDataForTool(e, t, o) {\n    const { Tools: i } = this.Editor;\n    let s = e;\n    if (i.unavailable.has(e)) {\n      const r = i.unavailable.get(e).toolbox;\n      r !== void 0 && r[0].title !== void 0 && (s = r[0].title);\n    }\n    return {\n      savedData: {\n        id: o,\n        type: e,\n        data: t\n      },\n      title: s\n    };\n  }\n}\nclass ma extends E {\n  /**\n   * Composes new chain of Promises to fire them alternatelly\n   *\n   * @returns {OutputData}\n   */\n  async save() {\n    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];\n    try {\n      o.forEach((a) => {\n        i.push(this.getSavedData(a));\n      });\n      const s = await Promise.all(i), r = await yt(s, (a) => t.blockTools.get(a).sanitizeConfig);\n      return this.makeOutput(r);\n    } catch (s) {\n      X(\"Saving failed due to the Error %o\", \"error\", s);\n    }\n  }\n  /**\n   * Saves and validates\n   *\n   * @param {Block} block - Editor's Tool\n   * @returns {ValidatedData} - Tool's validated data\n   */\n  async getSavedData(e) {\n    const t = await e.save(), o = t && await e.validate(t.data);\n    return {\n      ...t,\n      isValid: o\n    };\n  }\n  /**\n   * Creates output object with saved data, time and version of editor\n   *\n   * @param {ValidatedData} allExtractedData - data extracted from Blocks\n   * @returns {OutputData}\n   */\n  makeOutput(e) {\n    const t = [];\n    return e.forEach(({ id: o, tool: i, data: s, tunes: r, isValid: a }) => {\n      if (!a) {\n        S(`Block «${i}» skipped because saved data is invalid`);\n        return;\n      }\n      if (i === this.Editor.Tools.stubTool) {\n        t.push(s);\n        return;\n      }\n      const l = {\n        id: o,\n        type: i,\n        data: s,\n        ...!V(r) && {\n          tunes: r\n        }\n      };\n      t.push(l);\n    }), {\n      time: +/* @__PURE__ */ new Date(),\n      blocks: t,\n      version: \"2.31.0-rc.7\"\n    };\n  }\n}\n(function() {\n  try {\n    if (typeof document < \"u\") {\n      var n = document.createElement(\"style\");\n      n.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(n);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nconst ba = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction va(n) {\n  const e = document.createElement(\"div\");\n  e.innerHTML = n.trim();\n  const t = document.createDocumentFragment();\n  return t.append(...Array.from(e.childNodes)), t;\n}\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass fo {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : fo.DEFAULT_PLACEHOLDER, this._data = e ?? {}, this._element = null, this._preserveBlank = t.preserveBlank ?? !1;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(e) {\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\" || !this._element)\n      return;\n    const { textContent: t } = this._element;\n    t === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    const e = document.createElement(\"DIV\");\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = \"false\", e.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = \"true\", e.addEventListener(\"keyup\", this.onKeyUp)), e;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(e) {\n    if (!this._element)\n      return;\n    this._data.text += e.text;\n    const t = va(e.text);\n    this._element.appendChild(t), this._element.normalize();\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {HTMLPasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = {\n      text: e.detail.data.innerHTML\n    };\n    this._data = t, window.requestAnimationFrame(() => {\n      this._element && (this._element.innerHTML = this._data.text || \"\");\n    });\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   * @returns {ConversionConfig}\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   * @returns {SanitizerConfig} - Edtior.js sanitizer config\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {PasteConfig} - Paragraph Paste Setting\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {ToolboxConfig} - Paragraph Toolbox Setting\n   */\n  static get toolbox() {\n    return {\n      icon: ba,\n      title: \"Text\"\n    };\n  }\n}\nclass go {\n  constructor() {\n    this.commandName = \"bold\";\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <b> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      b: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return {\n      icon: Ki,\n      name: \"bold\",\n      onActivate: () => {\n        document.execCommand(this.commandName);\n      },\n      isActive: () => document.queryCommandState(this.commandName)\n    };\n  }\n  /**\n   * Set a shortcut\n   *\n   * @returns {boolean}\n   */\n  get shortcut() {\n    return \"CMD+B\";\n  }\n}\ngo.isInline = !0;\ngo.title = \"Bold\";\nclass mo {\n  constructor() {\n    this.commandName = \"italic\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--italic\"\n    }, this.nodes = {\n      button: null\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <i> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      i: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Ji, this.nodes.button;\n  }\n  /**\n   * Wrap range with <i> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <i> tag\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+I\";\n  }\n}\nmo.isInline = !0;\nmo.title = \"Italic\";\nclass bo {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.commandLink = \"createLink\", this.commandUnlink = \"unlink\", this.ENTER_KEY = 13, this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--link\",\n      buttonUnlink: \"ce-inline-tool--unlink\",\n      input: \"ce-inline-tool-input\",\n      inputShowed: \"ce-inline-tool-input--showed\"\n    }, this.nodes = {\n      button: null,\n      input: null\n    }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b();\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <a> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      a: {\n        href: !0,\n        target: \"_blank\",\n        rel: \"nofollow\"\n      }\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Co, this.nodes.button;\n  }\n  /**\n   * Input for the link\n   */\n  renderActions() {\n    return this.nodes.input = document.createElement(\"input\"), this.nodes.input.placeholder = this.i18n.t(\"Add a link\"), this.nodes.input.enterKeyHint = \"done\", this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener(\"keydown\", (e) => {\n      e.keyCode === this.ENTER_KEY && this.enterPressed(e);\n    }), this.nodes.input;\n  }\n  /**\n   * Handle clicks on the Inline Toolbar icon\n   *\n   * @param {Range} range - range to wrap with link\n   */\n  surround(e) {\n    if (e) {\n      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());\n      const t = this.selection.findParentTag(\"A\");\n      if (t) {\n        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();\n        return;\n      }\n    }\n    this.toggleActions();\n  }\n  /**\n   * Check selection and set activated state to button if there are <a> tag\n   */\n  checkState() {\n    const e = this.selection.findParentTag(\"A\");\n    if (e) {\n      this.nodes.button.innerHTML = ns, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();\n      const t = e.getAttribute(\"href\");\n      this.nodes.input.value = t !== \"null\" ? t : \"\", this.selection.save();\n    } else\n      this.nodes.button.innerHTML = Co, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);\n    return !!e;\n  }\n  /**\n   * Function called with Inline Toolbar closing\n   */\n  clear() {\n    this.closeActions();\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+K\";\n  }\n  /**\n   * Show/close link input\n   */\n  toggleActions() {\n    this.inputOpened ? this.closeActions(!1) : this.openActions(!0);\n  }\n  /**\n   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.\n   */\n  openActions(e = !1) {\n    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;\n  }\n  /**\n   * Close input\n   *\n   * @param {boolean} clearSavedSelection — we don't need to clear saved selection\n   *                                        on toggle-clicks on the icon of opened Toolbar\n   */\n  closeActions(e = !0) {\n    if (this.selection.isFakeBackgroundEnabled) {\n      const t = new b();\n      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();\n    }\n    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = \"\", e && this.selection.clearSaved(), this.inputOpened = !1;\n  }\n  /**\n   * Enter pressed on input\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  enterPressed(e) {\n    let t = this.nodes.input.value || \"\";\n    if (!t.trim()) {\n      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();\n      return;\n    }\n    if (!this.validateURL(t)) {\n      this.notifier.show({\n        message: \"Pasted link is not valid.\",\n        style: \"error\"\n      }), S(\"Incorrect Link pasted\", \"warn\", t);\n      return;\n    }\n    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();\n  }\n  /**\n   * Detects if passed string is URL\n   *\n   * @param {string} str - string to validate\n   * @returns {boolean}\n   */\n  validateURL(e) {\n    return !/\\s/.test(e);\n  }\n  /**\n   * Process link before injection\n   * - sanitize\n   * - add protocol for links like 'google.com'\n   *\n   * @param {string} link - raw user input\n   */\n  prepareLink(e) {\n    return e = e.trim(), e = this.addProtocol(e), e;\n  }\n  /**\n   * Add 'http' protocol to the links like 'vc.ru', 'google.com'\n   *\n   * @param {string} link - string to process\n   */\n  addProtocol(e) {\n    if (/^(\\w+):(\\/\\/)?/.test(e))\n      return e;\n    const t = /^\\/[^/\\s]/.test(e), o = e.substring(0, 1) === \"#\", i = /^\\/\\/[^/\\s]/.test(e);\n    return !t && !o && !i && (e = \"http://\" + e), e;\n  }\n  /**\n   * Inserts <a> tag with \"href\"\n   *\n   * @param {string} link - \"href\" value\n   */\n  insertLink(e) {\n    const t = this.selection.findParentTag(\"A\");\n    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, !1, e);\n  }\n  /**\n   * Removes <a> tag\n   */\n  unlink() {\n    document.execCommand(this.commandUnlink);\n  }\n}\nbo.isInline = !0;\nbo.title = \"Link\";\nclass Fn {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.i18nAPI = e.i18n, this.blocksAPI = e.blocks, this.selectionAPI = e.selection, this.toolsAPI = e.tools, this.caretAPI = e.caret;\n  }\n  /**\n   * Returns tool's UI config\n   */\n  async render() {\n    const e = b.get(), t = this.blocksAPI.getBlockByElement(e.anchorNode);\n    if (t === void 0)\n      return [];\n    const o = this.toolsAPI.getBlockTools(), i = await Yo(t, o);\n    if (i.length === 0)\n      return [];\n    const s = i.reduce((c, u) => {\n      var h;\n      return (h = u.toolbox) == null || h.forEach((p) => {\n        c.push({\n          icon: p.icon,\n          title: z.t(K.toolNames, p.title),\n          name: u.name,\n          closeOnActivate: !0,\n          onActivate: async () => {\n            const g = await this.blocksAPI.convert(t.id, u.name, p.data);\n            this.caretAPI.setToBlock(g, \"end\");\n          }\n        });\n      }), c;\n    }, []), r = await t.getActiveToolboxEntry(), a = r !== void 0 ? r.icon : Go, l = !be();\n    return {\n      icon: a,\n      name: \"convert-to\",\n      hint: {\n        title: this.i18nAPI.t(\"Convert to\")\n      },\n      children: {\n        searchable: l,\n        items: s,\n        onOpen: () => {\n          l && (this.selectionAPI.setFakeBackground(), this.selectionAPI.save());\n        },\n        onClose: () => {\n          l && (this.selectionAPI.restore(), this.selectionAPI.removeFakeBackground());\n        }\n      }\n    };\n  }\n}\nFn.isInline = !0;\nclass jn {\n  /**\n   * @param options - constructor options\n   * @param options.data - stub tool data\n   * @param options.api - Editor.js API\n   */\n  constructor({ data: e, api: t }) {\n    this.CSS = {\n      wrapper: \"ce-stub\",\n      info: \"ce-stub__info\",\n      title: \"ce-stub__title\",\n      subtitle: \"ce-stub__subtitle\"\n    }, this.api = t, this.title = e.title || this.api.i18n.t(\"Error\"), this.subtitle = this.api.i18n.t(\"The block can not be displayed correctly.\"), this.savedData = e.savedData, this.wrapper = this.make();\n  }\n  /**\n   * Returns stub holder\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.wrapper;\n  }\n  /**\n   * Return original Tool data\n   *\n   * @returns {BlockToolData}\n   */\n  save() {\n    return this.savedData;\n  }\n  /**\n   * Create Tool html markup\n   *\n   * @returns {HTMLElement}\n   */\n  make() {\n    const e = d.make(\"div\", this.CSS.wrapper), t = is, o = d.make(\"div\", this.CSS.info), i = d.make(\"div\", this.CSS.title, {\n      textContent: this.title\n    }), s = d.make(\"div\", this.CSS.subtitle, {\n      textContent: this.subtitle\n    });\n    return e.innerHTML = t, o.appendChild(i), o.appendChild(s), e.appendChild(o), e;\n  }\n}\njn.isReadOnlySupported = !0;\nclass ka extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Inline;\n  }\n  /**\n   * Returns title for Inline Tool if specified by user\n   */\n  get title() {\n    return this.constructable[We.Title];\n  }\n  /**\n   * Constructs new InlineTool instance from constructable\n   */\n  create() {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings\n    });\n  }\n  /**\n   * Allows inline tool to be available in read-only mode\n   * Can be used, for example, by comments tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[We.IsReadOnlySupported] ?? !1;\n  }\n}\nclass ya extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Tune;\n  }\n  /**\n   * Constructs new BlockTune instance from constructable\n   *\n   * @param data - Tune data\n   * @param block - Block API object\n   */\n  create(e, t) {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings,\n      block: t,\n      data: e\n    });\n  }\n}\nclass j extends Map {\n  /**\n   * Returns Block Tools collection\n   */\n  get blockTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());\n    return new j(e);\n  }\n  /**\n   * Returns Inline Tools collection\n   */\n  get inlineTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());\n    return new j(e);\n  }\n  /**\n   * Returns Block Tunes collection\n   */\n  get blockTunes() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());\n    return new j(e);\n  }\n  /**\n   * Returns internal Tools collection\n   */\n  get internalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);\n    return new j(e);\n  }\n  /**\n   * Returns Tools collection provided by user\n   */\n  get externalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);\n    return new j(e);\n  }\n}\nvar wa = Object.defineProperty, Ea = Object.getOwnPropertyDescriptor, Hn = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ea(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && wa(e, t, i), i;\n};\nclass vo extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Block, this.inlineTools = new j(), this.tunes = new j();\n  }\n  /**\n   * Creates new Tool instance\n   *\n   * @param data - Tool data\n   * @param block - BlockAPI for current Block\n   * @param readOnly - True if Editor is in read-only mode\n   */\n  create(e, t, o) {\n    return new this.constructable({\n      data: e,\n      block: t,\n      readOnly: o,\n      api: this.api,\n      config: this.settings\n    });\n  }\n  /**\n   * Returns true if read-only mode is supported by Tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[pe.IsReadOnlySupported] === !0;\n  }\n  /**\n   * Returns true if Tool supports linebreaks\n   */\n  get isLineBreaksEnabled() {\n    return this.constructable[pe.IsEnabledLineBreaks];\n  }\n  /**\n   * Returns Tool toolbox configuration (internal or user-specified).\n   *\n   * Merges internal and user-defined toolbox configs based on the following rules:\n   *\n   * - If both internal and user-defined toolbox configs are arrays their items are merged.\n   * Length of the second one is kept.\n   *\n   * - If both are objects their properties are merged.\n   *\n   * - If one is an object and another is an array than internal config is replaced with user-defined\n   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)\n   */\n  get toolbox() {\n    const e = this.constructable[pe.Toolbox], t = this.config[Pe.Toolbox];\n    if (!V(e) && t !== !1)\n      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {\n        const s = e[i];\n        return s ? {\n          ...s,\n          ...o\n        } : o;\n      }) : [t] : Array.isArray(t) ? t : [\n        {\n          ...e,\n          ...t\n        }\n      ] : Array.isArray(e) ? e : [e];\n  }\n  /**\n   * Returns Tool conversion configuration\n   */\n  get conversionConfig() {\n    return this.constructable[pe.ConversionConfig];\n  }\n  /**\n   * Returns enabled inline tools for Tool\n   */\n  get enabledInlineTools() {\n    return this.config[Pe.EnabledInlineTools] || !1;\n  }\n  /**\n   * Returns enabled tunes for Tool\n   */\n  get enabledBlockTunes() {\n    return this.config[Pe.EnabledBlockTunes];\n  }\n  /**\n   * Returns Tool paste configuration\n   */\n  get pasteConfig() {\n    return this.constructable[pe.PasteConfig] ?? {};\n  }\n  get sanitizeConfig() {\n    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;\n    if (V(e))\n      return t;\n    const o = {};\n    for (const i in e)\n      if (Object.prototype.hasOwnProperty.call(e, i)) {\n        const s = e[i];\n        D(s) ? o[i] = Object.assign({}, t, s) : o[i] = s;\n      }\n    return o;\n  }\n  get baseSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;\n  }\n}\nHn([\n  me\n], vo.prototype, \"sanitizeConfig\", 1);\nHn([\n  me\n], vo.prototype, \"baseSanitizeConfig\", 1);\nclass xa {\n  /**\n   * @class\n   * @param config - tools config\n   * @param editorConfig - EditorJS config\n   * @param api - EditorJS API module\n   */\n  constructor(e, t, o) {\n    this.api = o, this.config = e, this.editorConfig = t;\n  }\n  /**\n   * Returns Tool object based on it's type\n   *\n   * @param name - tool name\n   */\n  get(e) {\n    const { class: t, isInternal: o = !1, ...i } = this.config[e], s = this.getConstructor(t), r = t[mt.IsTune];\n    return new s({\n      name: e,\n      constructable: t,\n      config: i,\n      api: this.api.getMethodsForTool(e, r),\n      isDefault: e === this.editorConfig.defaultBlock,\n      defaultPlaceholder: this.editorConfig.placeholder,\n      isInternal: o\n    });\n  }\n  /**\n   * Find appropriate Tool object constructor for Tool constructable\n   *\n   * @param constructable - Tools constructable\n   */\n  getConstructor(e) {\n    switch (!0) {\n      case e[We.IsInline]:\n        return ka;\n      case e[mt.IsTune]:\n        return ya;\n      default:\n        return vo;\n    }\n  }\n}\nclass $n {\n  /**\n   * MoveDownTune constructor\n   *\n   * @param {API} api — Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Xi,\n      title: this.api.i18n.t(\"Move down\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-down\"\n    };\n  }\n  /**\n   * Handle clicks on 'move down' button\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);\n    if (!t)\n      throw new Error(\"Unable to move Block down since it is already the last\");\n    const o = t.holder, i = o.getBoundingClientRect();\n    let s = Math.abs(window.innerHeight - o.offsetHeight);\n    i.top < window.innerHeight && (s = window.scrollY + o.offsetHeight), window.scrollTo(0, s), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\n$n.isTune = !0;\nclass zn {\n  /**\n   * DeleteTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Gi,\n      title: this.api.i18n.t(\"Delete\"),\n      name: \"delete\",\n      confirmation: {\n        title: this.api.i18n.t(\"Click to delete\"),\n        onActivate: () => this.handleClick()\n      }\n    };\n  }\n  /**\n   * Delete block conditions passed\n   */\n  handleClick() {\n    this.api.blocks.delete();\n  }\n}\nzn.isTune = !0;\nclass Un {\n  /**\n   * MoveUpTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Zi,\n      title: this.api.i18n.t(\"Move up\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-up\"\n    };\n  }\n  /**\n   * Move current block up\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);\n    if (e === 0 || !t || !o)\n      throw new Error(\"Unable to move Block up since it is already the first\");\n    const i = t.holder, s = o.holder, r = i.getBoundingClientRect(), a = s.getBoundingClientRect();\n    let l;\n    a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nUn.isTune = !0;\nvar Ba = Object.defineProperty, Ca = Object.getOwnPropertyDescriptor, Ta = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ca(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && Ba(e, t, i), i;\n};\nclass Wn extends E {\n  constructor() {\n    super(...arguments), this.stubTool = \"stub\", this.toolsAvailable = new j(), this.toolsUnavailable = new j();\n  }\n  /**\n   * Returns available Tools\n   */\n  get available() {\n    return this.toolsAvailable;\n  }\n  /**\n   * Returns unavailable Tools\n   */\n  get unavailable() {\n    return this.toolsUnavailable;\n  }\n  /**\n   * Return Tools for the Inline Toolbar\n   */\n  get inlineTools() {\n    return this.available.inlineTools;\n  }\n  /**\n   * Return editor block tools\n   */\n  get blockTools() {\n    return this.available.blockTools;\n  }\n  /**\n   * Return available Block Tunes\n   *\n   * @returns {object} - object of Inline Tool's classes\n   */\n  get blockTunes() {\n    return this.available.blockTunes;\n  }\n  /**\n   * Returns default Tool object\n   */\n  get defaultTool() {\n    return this.blockTools.get(this.config.defaultBlock);\n  }\n  /**\n   * Returns internal tools\n   */\n  get internal() {\n    return this.available.internalTools;\n  }\n  /**\n   * Creates instances via passed or default configuration\n   *\n   * @returns {Promise<void>}\n   */\n  async prepare() {\n    if (this.validateTools(), this.config.tools = ut({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, \"tools\") || Object.keys(this.config.tools).length === 0)\n      throw Error(\"Can't start without tools\");\n    const e = this.prepareConfig();\n    this.factory = new xa(e, this.config, this.Editor.API);\n    const t = this.getListOfPrepareFunctions(e);\n    if (t.length === 0)\n      return Promise.resolve();\n    await Qn(t, (o) => {\n      this.toolPrepareMethodSuccess(o);\n    }, (o) => {\n      this.toolPrepareMethodFallback(o);\n    }), this.prepareBlockTools();\n  }\n  getAllInlineToolsSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => {\n      Object.assign(e, t.sanitizeConfig);\n    }), e;\n  }\n  /**\n   * Calls each Tool reset method to clean up anything set by Tool\n   */\n  destroy() {\n    Object.values(this.available).forEach(async (e) => {\n      A(e.reset) && await e.reset();\n    });\n  }\n  /**\n   * Returns internal tools\n   * Includes Bold, Italic, Link and Paragraph\n   */\n  get internalTools() {\n    return {\n      convertTo: {\n        class: Fn,\n        isInternal: !0\n      },\n      link: {\n        class: bo,\n        isInternal: !0\n      },\n      bold: {\n        class: go,\n        isInternal: !0\n      },\n      italic: {\n        class: mo,\n        isInternal: !0\n      },\n      paragraph: {\n        class: fo,\n        inlineToolbar: !0,\n        isInternal: !0\n      },\n      stub: {\n        class: jn,\n        isInternal: !0\n      },\n      moveUp: {\n        class: Un,\n        isInternal: !0\n      },\n      delete: {\n        class: zn,\n        isInternal: !0\n      },\n      moveDown: {\n        class: $n,\n        isInternal: !0\n      }\n    };\n  }\n  /**\n   * Tool prepare method success callback\n   *\n   * @param {object} data - append tool to available list\n   */\n  toolPrepareMethodSuccess(e) {\n    const t = this.factory.get(e.toolName);\n    if (t.isInline()) {\n      const i = [\"render\"].filter((s) => !t.create()[s]);\n      if (i.length) {\n        S(\n          `Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`,\n          \"warn\",\n          i\n        ), this.toolsUnavailable.set(t.name, t);\n        return;\n      }\n    }\n    this.toolsAvailable.set(t.name, t);\n  }\n  /**\n   * Tool prepare method fail callback\n   *\n   * @param {object} data - append tool to unavailable list\n   */\n  toolPrepareMethodFallback(e) {\n    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));\n  }\n  /**\n   * Binds prepare function of plugins with user or default config\n   *\n   * @returns {Array} list of functions that needs to be fired sequentially\n   * @param config - tools config\n   */\n  getListOfPrepareFunctions(e) {\n    const t = [];\n    return Object.entries(e).forEach(([o, i]) => {\n      t.push({\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function: A(i.class.prepare) ? i.class.prepare : () => {\n        },\n        data: {\n          toolName: o,\n          config: i.config\n        }\n      });\n    }), t;\n  }\n  /**\n   * Assign enabled Inline Tools and Block Tunes for Block Tool\n   */\n  prepareBlockTools() {\n    Array.from(this.blockTools.values()).forEach((e) => {\n      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);\n    });\n  }\n  /**\n   * Assign enabled Inline Tools for Block Tool\n   *\n   * @param tool - Block Tool\n   */\n  assignInlineToolsToBlockTool(e) {\n    if (this.config.inlineToolbar !== !1) {\n      if (e.enabledInlineTools === !0) {\n        e.inlineTools = new j(\n          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries())\n        );\n        return;\n      }\n      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new j(\n        /** Prepend ConvertTo Inline Tool */\n        [\"convertTo\", ...e.enabledInlineTools].map((t) => [t, this.inlineTools.get(t)])\n      ));\n    }\n  }\n  /**\n   * Assign enabled Block Tunes for Block Tool\n   *\n   * @param tool — Block Tool\n   */\n  assignBlockTunesToBlockTool(e) {\n    if (e.enabledBlockTunes !== !1) {\n      if (Array.isArray(e.enabledBlockTunes)) {\n        const t = new j(\n          e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new j([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      if (Array.isArray(this.config.tunes)) {\n        const t = new j(\n          this.config.tunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new j([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      e.tunes = this.blockTunes.internalTools;\n    }\n  }\n  /**\n   * Validate Tools configuration objects and throw Error for user if it is invalid\n   */\n  validateTools() {\n    for (const e in this.config.tools)\n      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {\n        if (e in this.internalTools)\n          return;\n        const t = this.config.tools[e];\n        if (!A(t) && !A(t.class))\n          throw Error(\n            `Tool «${e}» must be a constructor function or an object with function in the «class» property`\n          );\n      }\n  }\n  /**\n   * Unify tools config\n   */\n  prepareConfig() {\n    const e = {};\n    for (const t in this.config.tools)\n      D(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };\n    return e;\n  }\n}\nTa([\n  me\n], Wn.prototype, \"getAllInlineToolsSanitizeConfig\", 1);\nconst Sa = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:\"\\\\feff\"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;--color-background-icon-active: rgba(56, 138, 229, .1);--color-text-icon-active: #388AE5;--color-text-primary: black;position:absolute;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3;opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{color:var(--color-text-primary);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:0;border-radius:4px;line-height:normal;height:100%;padding:0;width:28px;background-color:transparent;cursor:pointer}@media (max-width: 650px){.ce-inline-tool{width:36px;height:36px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#f8f8f8}}.ce-inline-tool svg{display:block;width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:4px 8px;font-size:14px;line-height:22px;outline:none;margin:0;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-inline-tool--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:\"\";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:\"\";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:\"\";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #EFF0F1;--color-shadow: rgba(13, 20, 33, .1);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #F8F8F8;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;--popover-top: calc(100% + var(--offset-from-target));--popover-left: 0;--nested-popover-overlap: 4px;--icon-size: 20px;--item-padding: 3px;--item-height: calc(var(--icon-size) + 2 * var(--item-padding))}.ce-popover__container{min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0px 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:var(--popover-left);top:var(--popover-top);background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened>.ce-popover__container{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened>.ce-popover__container{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover--open-top .ce-popover__container{--popover-top: calc(-1 * (var(--offset-from-target) + var(--popover-height)))}.ce-popover--open-left .ce-popover__container{--popover-left: calc(-1 * var(--width) + 100%)}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}@media (max-width: 650px){.ce-popover .ce-popover__container{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__search{margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover--nested .ce-popover__container{--popover-left: calc(var(--nesting-level) * (var(--width) - var(--nested-popover-overlap)));top:calc(var(--trigger-item-top) - var(--nested-popover-overlap));position:absolute}.ce-popover--open-top.ce-popover--nested .ce-popover__container{top:calc(var(--trigger-item-top) - var(--popover-height) + var(--item-height) + var(--offset-from-target) + var(--nested-popover-overlap))}.ce-popover--open-left .ce-popover--nested .ce-popover__container{--popover-left: calc(-1 * (var(--nesting-level) + 1) * var(--width) + 100%)}.ce-popover-item-separator{padding:4px 3px}.ce-popover-item-separator--hidden{display:none}.ce-popover-item-separator__line{height:1px;background:var(--color-border);width:100%}.ce-popover-item-html--hidden{display:none}.ce-popover-item{--border-radius: 6px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--item-padding);color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:none;background:transparent}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover-item__icon--tool{margin-right:4px}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:auto}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title,.ce-popover-item--confirmation .ce-popover-item__icon{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}.ce-popover-header{margin-bottom:8px;margin-top:4px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover-header__text{font-size:18px;font-weight:600}.ce-popover-header__back-button{border:0;background:transparent;width:36px;height:36px;color:var(--color-text-primary)}.ce-popover-header__back-button svg{display:block;width:28px;height:28px}.ce-popover--inline{--height: 38px;--height-mobile: 46px;--container-padding: 4px;position:relative}.ce-popover--inline .ce-popover__custom-content{margin-bottom:0}.ce-popover--inline .ce-popover__items{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-popover--inline .ce-popover__container{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:var(--container-padding);height:var(--height);top:0;min-width:-webkit-max-content;min-width:-moz-max-content;min-width:max-content;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-animation:none;animation:none}@media (max-width: 650px){.ce-popover--inline .ce-popover__container{height:var(--height-mobile);position:absolute}}.ce-popover--inline .ce-popover-item-separator{padding:0 4px}.ce-popover--inline .ce-popover-item-separator__line{height:100%;width:1px}.ce-popover--inline .ce-popover-item{border-radius:4px;padding:4px}.ce-popover--inline .ce-popover-item__icon--tool{-webkit-box-shadow:none;box-shadow:none;background:transparent;margin-right:0}.ce-popover--inline .ce-popover-item__icon{width:auto;width:initial;height:auto;height:initial}.ce-popover--inline .ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover--inline .ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover--inline .ce-popover-item:not(:last-of-type){margin-bottom:0;margin-bottom:initial}.ce-popover--inline .ce-popover-item-html{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover--inline .ce-popover-item__icon--chevron-right{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{--offset: 3px;left:0;top:calc(var(--height) + var(--offset))}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{top:calc(var(--height-mobile) + var(--offset))}}.ce-popover--inline .ce-popover--nested .ce-popover__container{min-width:var(--width);width:var(--width);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:6px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.ce-popover--inline .ce-popover--nested .ce-popover__items{display:block;width:100%}.ce-popover--inline .ce-popover--nested .ce-popover-item{border-radius:6px;padding:3px}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested .ce-popover-item{padding:4px}}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon--tool{margin-right:4px}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon{width:26px;height:26px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator{padding:4px 3px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator__line{width:100%;height:1px}.codex-editor [data-placeholder]:empty:before,.codex-editor [data-placeholder][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text;content:attr(data-placeholder)}.codex-editor [data-placeholder-active]:empty:before,.codex-editor [data-placeholder-active][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text}.codex-editor [data-placeholder-active]:empty:focus:before,.codex-editor [data-placeholder-active][data-empty=true]:focus:before{content:attr(data-placeholder-active)}\n`;\nclass Ia extends E {\n  constructor() {\n    super(...arguments), this.isMobile = !1, this.contentRectCache = null, this.resizeDebouncer = Eo(() => {\n      this.windowResize();\n    }, 200), this.selectionChangeDebounced = Eo(() => {\n      this.selectionChanged();\n    }, da), this.documentTouchedListener = (e) => {\n      this.documentTouched(e);\n    };\n  }\n  /**\n   * Editor.js UI CSS class names\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorWrapperNarrow: \"codex-editor--narrow\",\n      editorZone: \"codex-editor__redactor\",\n      editorZoneHidden: \"codex-editor__redactor--hidden\",\n      editorEmpty: \"codex-editor--empty\",\n      editorRtlFix: \"codex-editor--rtl\"\n    };\n  }\n  /**\n   * Return Width of center column of Editor\n   *\n   * @returns {DOMRect}\n   */\n  get contentRect() {\n    if (this.contentRectCache !== null)\n      return this.contentRectCache;\n    const e = this.nodes.wrapper.querySelector(`.${R.CSS.content}`);\n    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {\n      width: 650,\n      left: 0,\n      right: 0\n    };\n  }\n  /**\n   * Making main interface\n   */\n  async prepare() {\n    this.setIsMobile(), this.make(), this.loadStyles();\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - removes all listeners from main UI module elements\n   *\n   * if readOnly is false:\n   *  - enables all listeners to UI module elements\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.unbindReadOnlySensitiveListeners() : window.requestIdleCallback(() => {\n      this.bindReadOnlySensitiveListeners();\n    }, {\n      timeout: 2e3\n    });\n  }\n  /**\n   * Check if Editor is empty and set CSS class to wrapper\n   */\n  checkEmptiness() {\n    const { BlockManager: e } = this.Editor;\n    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);\n  }\n  /**\n   * Check if one of Toolbar is opened\n   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar\n   *\n   * @returns {boolean}\n   */\n  get someToolbarOpened() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    return !!(t.opened || o.opened || e.toolbox.opened);\n  }\n  /**\n   * Check for some Flipper-buttons is under focus\n   */\n  get someFlipperButtonFocused() {\n    return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof ce).some(([e, t]) => t.flipper.hasFocus());\n  }\n  /**\n   * Clean editor`s UI\n   */\n  destroy() {\n    this.nodes.holder.innerHTML = \"\", this.unbindReadOnlyInsensitiveListeners();\n  }\n  /**\n   * Close all Editor's toolbars\n   */\n  closeAllToolbars() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    t.close(), o.close(), e.toolbox.close();\n  }\n  /**\n   * Check for mobile mode and save the result\n   */\n  setIsMobile() {\n    const e = window.innerWidth < Ro;\n    e !== this.isMobile && this.eventsDispatcher.emit(Te, {\n      isEnabled: this.isMobile\n    }), this.isMobile = e;\n  }\n  /**\n   * Makes Editor.js interface\n   */\n  make() {\n    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.editorWrapper,\n      ...this.isRtl ? [this.CSS.editorRtlFix] : []\n    ]), this.nodes.redactor = d.make(\"div\", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + \"px\", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper), this.bindReadOnlyInsensitiveListeners();\n  }\n  /**\n   * Appends CSS\n   */\n  loadStyles() {\n    const e = \"editor-js-styles\";\n    if (d.get(e))\n      return;\n    const t = d.make(\"style\", null, {\n      id: e,\n      textContent: Sa.toString()\n    });\n    this.config.style && !V(this.config.style) && this.config.style.nonce && t.setAttribute(\"nonce\", this.config.style.nonce), d.prepend(document.head, t);\n  }\n  /**\n   * Adds listeners that should work both in read-only and read-write modes\n   */\n  bindReadOnlyInsensitiveListeners() {\n    this.listeners.on(document, \"selectionchange\", this.selectionChangeDebounced), this.listeners.on(window, \"resize\", this.resizeDebouncer, {\n      passive: !0\n    }), this.listeners.on(this.nodes.redactor, \"mousedown\", this.documentTouchedListener, {\n      capture: !0,\n      passive: !0\n    }), this.listeners.on(this.nodes.redactor, \"touchstart\", this.documentTouchedListener, {\n      capture: !0,\n      passive: !0\n    });\n  }\n  /**\n   * Removes listeners that should work both in read-only and read-write modes\n   */\n  unbindReadOnlyInsensitiveListeners() {\n    this.listeners.off(document, \"selectionchange\", this.selectionChangeDebounced), this.listeners.off(window, \"resize\", this.resizeDebouncer), this.listeners.off(this.nodes.redactor, \"mousedown\", this.documentTouchedListener), this.listeners.off(this.nodes.redactor, \"touchstart\", this.documentTouchedListener);\n  }\n  /**\n   * Adds listeners that should work only in read-only mode\n   */\n  bindReadOnlySensitiveListeners() {\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"click\", (e) => {\n      this.redactorClicked(e);\n    }, !1), this.readOnlyMutableListeners.on(document, \"keydown\", (e) => {\n      this.documentKeydown(e);\n    }, !0), this.readOnlyMutableListeners.on(document, \"mousedown\", (e) => {\n      this.documentClicked(e);\n    }, !0), this.watchBlockHoveredEvents(), this.enableInputsEmptyMark();\n  }\n  /**\n   * Listen redactor mousemove to emit 'block-hovered' event\n   */\n  watchBlockHoveredEvents() {\n    let e;\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousemove\", dt((t) => {\n      const o = t.target.closest(\".ce-block\");\n      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(ln, {\n        block: this.Editor.BlockManager.getBlockByChildNode(o)\n      }));\n    }, 20), {\n      passive: !0\n    });\n  }\n  /**\n   * Unbind events that should work only in read-only mode\n   */\n  unbindReadOnlySensitiveListeners() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Resize window handler\n   */\n  windowResize() {\n    this.contentRectCache = null, this.setIsMobile();\n  }\n  /**\n   * All keydowns on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  documentKeydown(e) {\n    switch (e.keyCode) {\n      case y.ENTER:\n        this.enterPressed(e);\n        break;\n      case y.BACKSPACE:\n      case y.DELETE:\n        this.backspacePressed(e);\n        break;\n      case y.ESC:\n        this.escapePressed(e);\n        break;\n      default:\n        this.defaultBehaviour(e);\n        break;\n    }\n  }\n  /**\n   * Ignore all other document's keydown events\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  defaultBehaviour(e) {\n    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n    if (t !== void 0 && o === null) {\n      this.Editor.BlockEvents.keydown(e);\n      return;\n    }\n    o || t && i || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n  }\n  /**\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  backspacePressed(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      const s = t.removeSelectedBlocks(), r = t.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();\n    }\n  }\n  /**\n   * Escape pressed\n   * If some of Toolbar components are opened, then close it otherwise close Toolbar\n   *\n   * @param {Event} event - escape keydown event\n   */\n  escapePressed(e) {\n    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();\n  }\n  /**\n   * Enter pressed on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  enterPressed(e) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    if (this.someToolbarOpened)\n      return;\n    const i = t.currentBlockIndex >= 0;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();\n      return;\n    }\n    if (!this.someToolbarOpened && i && e.target.tagName === \"BODY\") {\n      const s = this.Editor.BlockManager.insert();\n      e.preventDefault(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * All clicks on document\n   *\n   * @param {MouseEvent} event - Click event\n   */\n  documentClicked(e) {\n    var a, l;\n    if (!e.isTrusted)\n      return;\n    const t = e.target;\n    this.nodes.holder.contains(t) || b.isAtEditor || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n    const i = (a = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : a.contains(t), s = (l = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : l.contains(t), r = i || s;\n    if (this.Editor.BlockSettings.opened && !r) {\n      this.Editor.BlockSettings.close();\n      const c = this.Editor.BlockManager.getBlockByChildNode(t);\n      this.Editor.Toolbar.moveAndOpen(c);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * First touch on editor\n   * Fired before click\n   *\n   * Used to change current block — we need to do it before 'selectionChange' event.\n   * Also:\n   * - Move and show the Toolbar\n   * - Set a Caret\n   *\n   * @param event - touch or mouse event\n   */\n  documentTouched(e) {\n    let t = e.target;\n    if (t === this.nodes.redactor) {\n      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;\n      t = document.elementFromPoint(o, i);\n    }\n    try {\n      this.Editor.BlockManager.setCurrentBlockByChildNode(t);\n    } catch {\n      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();\n    }\n    this.Editor.ReadOnly.isEnabled || this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * All clicks on the redactor zone\n   *\n   * @param {MouseEvent} event - click event\n   * @description\n   * - By clicks on the Editor's bottom zone:\n   *      - if last Block is empty, set a Caret to this\n   *      - otherwise, add a new empty Block and set a Caret to that\n   */\n  redactorClicked(e) {\n    if (!b.isCollapsed)\n      return;\n    const t = e.target, o = e.metaKey || e.ctrlKey;\n    if (d.isAnchor(t) && o) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const i = t.getAttribute(\"href\"), s = oi(i);\n      ii(s);\n      return;\n    }\n    this.processBottomZoneClick(e);\n  }\n  /**\n   * Check if user clicks on the Editor's bottom zone:\n   *  - set caret to the last block\n   *  - or add new empty block\n   *\n   * @param event - click event\n   */\n  processBottomZoneClick(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(-1), o = d.offset(t.holder).bottom, i = e.pageY, { BlockSelection: s } = this.Editor;\n    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**\n    * If there is cross block selection started, target will be equal to redactor so we need additional check\n    */\n    !s.anyBlockSelected && /**\n    * Prevent caret jumping (to last block) when clicking between blocks\n    */\n    o < i) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const { BlockManager: a, Caret: l, Toolbar: c } = this.Editor;\n      (!a.lastBlock.tool.isDefault || !a.lastBlock.isEmpty) && a.insertAtEnd(), l.setToTheLastBlock(), c.moveAndOpen(a.lastBlock);\n    }\n  }\n  /**\n   * Handle selection changes on mobile devices\n   * Uses for showing the Inline Toolbar\n   */\n  selectionChanged() {\n    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = b.anchorElement;\n    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && b.get().removeAllRanges(), !o) {\n      b.range || this.Editor.InlineToolbar.close();\n      return;\n    }\n    const i = o.closest(`.${R.CSS.content}`);\n    (i === null || i.closest(`.${b.CSS.editorWrapper}`) !== this.nodes.wrapper) && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === \"true\")) || (this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o), this.Editor.InlineToolbar.tryToShow(!0));\n  }\n  /**\n   * Editor.js provides and ability to show placeholders for empty contenteditable elements\n   *\n   * This method watches for input and focus events and toggles 'data-empty' attribute\n   * to workaroud the case, when inputs contains only <br>s and has no visible content\n   * Then, CSS could rely on this attribute to show placeholders\n   */\n  enableInputsEmptyMark() {\n    function e(t) {\n      const o = t.target;\n      Do(o);\n    }\n    this.readOnlyMutableListeners.on(this.nodes.wrapper, \"input\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusin\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusout\", e);\n  }\n}\nconst Oa = {\n  // API Modules\n  BlocksAPI: gi,\n  CaretAPI: bi,\n  EventsAPI: vi,\n  I18nAPI: kt,\n  API: ki,\n  InlineToolbarAPI: yi,\n  ListenersAPI: wi,\n  NotifierAPI: Ci,\n  ReadOnlyAPI: Ti,\n  SanitizerAPI: Li,\n  SaverAPI: Pi,\n  SelectionAPI: Ni,\n  ToolsAPI: Ri,\n  StylesAPI: Di,\n  ToolbarAPI: Fi,\n  TooltipAPI: Ui,\n  UiAPI: Wi,\n  // Toolbar Modules\n  BlockSettings: ms,\n  Toolbar: Bs,\n  InlineToolbar: Cs,\n  // Modules\n  BlockEvents: na,\n  BlockManager: ra,\n  BlockSelection: aa,\n  Caret: Ye,\n  CrossBlockSelection: la,\n  DragNDrop: ca,\n  ModificationsObserver: ha,\n  Paste: pa,\n  ReadOnly: fa,\n  RectangleSelection: Be,\n  Renderer: ga,\n  Saver: ma,\n  Tools: Wn,\n  UI: Ia\n};\nclass _a {\n  /**\n   * @param {EditorConfig} config - user configuration\n   */\n  constructor(e) {\n    this.moduleInstances = {}, this.eventsDispatcher = new Oe();\n    let t, o;\n    this.isReady = new Promise((i, s) => {\n      t = i, o = s;\n    }), Promise.resolve().then(async () => {\n      this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();\n      const { BlockManager: i, Caret: s, UI: r, ModificationsObserver: a } = this.moduleInstances;\n      r.checkEmptiness(), a.enable(), this.configuration.autofocus === !0 && this.configuration.readOnly !== !0 && s.setToBlock(i.blocks[0], s.positions.START), t();\n    }).catch((i) => {\n      S(`Editor.js is not ready because of ${i}`, \"error\"), o(i);\n    });\n  }\n  /**\n   * Setting for configuration\n   *\n   * @param {EditorConfig|string} config - Editor's config to set\n   */\n  set configuration(e) {\n    var o, i;\n    D(e) ? this.config = {\n      ...e\n    } : this.config = {\n      holder: e\n    }, ht(!!this.config.holderId, \"config.holderId\", \"config.holder\"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = \"editorjs\"), this.config.logLevel || (this.config.logLevel = Lo.VERBOSE), Zn(this.config.logLevel), ht(!!this.config.initialBlock, \"config.initialBlock\", \"config.defaultBlock\"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || \"paragraph\", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;\n    const t = {\n      type: this.config.defaultBlock,\n      data: {}\n    };\n    this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {\n      p: !0,\n      b: !0,\n      a: !0\n    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {\n    }), this.config.onChange = this.config.onChange || (() => {\n    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || \"ltr\";\n  }\n  /**\n   * Returns private property\n   *\n   * @returns {EditorConfig}\n   */\n  get configuration() {\n    return this.config;\n  }\n  /**\n   * Checks for required fields in Editor's config\n   */\n  validate() {\n    const { holderId: e, holder: t } = this.config;\n    if (e && t)\n      throw Error(\"«holderId» and «holder» param can't assign at the same time.\");\n    if (te(t) && !d.get(t))\n      throw Error(`element with ID «${t}» is missing. Pass correct holder's ID.`);\n    if (t && D(t) && !d.isElement(t))\n      throw Error(\"«holder» value must be an Element node\");\n  }\n  /**\n   * Initializes modules:\n   *  - make and save instances\n   *  - configure\n   */\n  init() {\n    this.constructModules(), this.configureModules();\n  }\n  /**\n   * Start Editor!\n   *\n   * Get list of modules that needs to be prepared and return a sequence (Promise)\n   *\n   * @returns {Promise<void>}\n   */\n  async start() {\n    await [\n      \"Tools\",\n      \"UI\",\n      \"BlockManager\",\n      \"Paste\",\n      \"BlockSelection\",\n      \"RectangleSelection\",\n      \"CrossBlockSelection\",\n      \"ReadOnly\"\n    ].reduce(\n      (t, o) => t.then(async () => {\n        try {\n          await this.moduleInstances[o].prepare();\n        } catch (i) {\n          if (i instanceof Ho)\n            throw new Error(i.message);\n          S(`Module ${o} was skipped because of %o`, \"warn\", i);\n        }\n      }),\n      Promise.resolve()\n    );\n  }\n  /**\n   * Render initial data\n   */\n  render() {\n    return this.moduleInstances.Renderer.render(this.config.data.blocks);\n  }\n  /**\n   * Make modules instances and save it to the @property this.moduleInstances\n   */\n  constructModules() {\n    Object.entries(Oa).forEach(([e, t]) => {\n      try {\n        this.moduleInstances[e] = new t({\n          config: this.configuration,\n          eventsDispatcher: this.eventsDispatcher\n        });\n      } catch (o) {\n        S(\"[constructModules]\", `Module ${e} skipped because`, \"error\", o);\n      }\n    });\n  }\n  /**\n   * Modules instances configuration:\n   *  - pass other modules to the 'state' property\n   *  - ...\n   */\n  configureModules() {\n    for (const e in this.moduleInstances)\n      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));\n  }\n  /**\n   * Return modules without passed name\n   *\n   * @param {string} name - module for witch modules difference should be calculated\n   */\n  getModulesDiff(e) {\n    const t = {};\n    for (const o in this.moduleInstances)\n      o !== e && (t[o] = this.moduleInstances[o]);\n    return t;\n  }\n}\n/**\n * Editor.js\n *\n * @license Apache-2.0\n * @see Editor.js <https://editorjs.io>\n * @author CodeX Team <https://codex.so>\n */\nclass Aa {\n  /** Editor version */\n  static get version() {\n    return \"2.31.0-rc.7\";\n  }\n  /**\n   * @param {EditorConfig|string|undefined} [configuration] - user configuration\n   */\n  constructor(e) {\n    let t = () => {\n    };\n    D(e) && A(e.onReady) && (t = e.onReady);\n    const o = new _a(e);\n    this.isReady = o.isReady.then(() => {\n      this.exportAPI(o), t();\n    });\n  }\n  /**\n   * Export external API methods\n   *\n   * @param {Core} editor — Editor's instance\n   */\n  exportAPI(e) {\n    const t = [\"configuration\"], o = () => {\n      Object.values(e.moduleInstances).forEach((s) => {\n        A(s.destroy) && s.destroy(), s.listeners.removeAll();\n      }), zi(), e = null;\n      for (const s in this)\n        Object.prototype.hasOwnProperty.call(this, s) && delete this[s];\n      Object.setPrototypeOf(this, null);\n    };\n    t.forEach((s) => {\n      this[s] = e[s];\n    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({\n      blocks: {\n        clear: \"clear\",\n        render: \"render\"\n      },\n      caret: {\n        focus: \"focus\"\n      },\n      events: {\n        on: \"on\",\n        off: \"off\",\n        emit: \"emit\"\n      },\n      saver: {\n        save: \"save\"\n      }\n    }).forEach(([s, r]) => {\n      Object.entries(r).forEach(([a, l]) => {\n        this[l] = e.moduleInstances.API.methods[s][a];\n      });\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2VkaXRvcmpzL2Rpc3QvZWRpdG9yanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLDZEQUE2RCxnQkFBZ0IsdUJBQXVCLGtCQUFrQixzQkFBc0IsV0FBVyxlQUFlLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUMvVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUhBQXVIO0FBQ3BJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaU1BQWlNO0FBQ3JNO0FBQ0EsK0dBQStHLHFNQUFxTTtBQUNwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2TUFBNk07QUFDN007QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvR0FBb0c7QUFDekc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVSw4R0FBOEcsVUFBVTtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFD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QTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxhQUFhLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FB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Z0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxLQUFLLHVJQUF1SSw0QkFBNEI7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtT0FBbU8sVUFBVTtBQUM3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNlBBQTZQO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHVCQUF1QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxJQUFJLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVM7QUFDL0MsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTLHdDQUF3QyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFLGlGQUFpRixFQUFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVyxTQUFTLFNBQVM7QUFDN0IsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUztBQUNwQjtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFD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eEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGlJQUFpSTtBQUNyODRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9lZGl0b3Jqcy9kaXN0L2VkaXRvcmpzLm1qcz80NjkyIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLWhpbnQtLWFsaWduLXN0YXJ0e3RleHQtYWxpZ246bGVmdH0uY2UtaGludC0tYWxpZ24tY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS5jZS1oaW50X19kZXNjcmlwdGlvbntvcGFjaXR5Oi42O21hcmdpbi10b3A6M3B4fVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2godCl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLHQpfX0pKCk7XG52YXIgQ2UgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiBLZShuKSB7XG4gIHJldHVybiBuICYmIG4uX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgXCJkZWZhdWx0XCIpID8gbi5kZWZhdWx0IDogbjtcbn1cbmZ1bmN0aW9uIFhuKG4pIHtcbiAgaWYgKG4uX19lc01vZHVsZSlcbiAgICByZXR1cm4gbjtcbiAgdmFyIGUgPSBuLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgdCA9IGZ1bmN0aW9uIG8oKSB7XG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG8gPyBSZWZsZWN0LmNvbnN0cnVjdChlLCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpIDogZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdC5wcm90b3R5cGUgPSBlLnByb3RvdHlwZTtcbiAgfSBlbHNlXG4gICAgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgdmFyIGkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIG8pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBvLCBpLmdldCA/IGkgOiB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuW29dO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIG90KCkge1xufVxuT2JqZWN0LmFzc2lnbihvdCwge1xuICBkZWZhdWx0OiBvdCxcbiAgcmVnaXN0ZXI6IG90LFxuICByZXZlcnQ6IGZ1bmN0aW9uKCkge1xuICB9LFxuICBfX2VzTW9kdWxlOiAhMFxufSk7XG5FbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IChFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbihuKSB7XG4gIGNvbnN0IGUgPSAodGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwobik7XG4gIGxldCB0ID0gZS5sZW5ndGg7XG4gIGZvciAoOyAtLXQgPj0gMCAmJiBlLml0ZW0odCkgIT09IHRoaXM7IClcbiAgICA7XG4gIHJldHVybiB0ID4gLTE7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgfHwgKEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbihuKSB7XG4gIGxldCBlID0gdGhpcztcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGRvIHtcbiAgICBpZiAoZS5tYXRjaGVzKG4pKVxuICAgICAgcmV0dXJuIGU7XG4gICAgZSA9IGUucGFyZW50RWxlbWVudCB8fCBlLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKGUgIT09IG51bGwpO1xuICByZXR1cm4gbnVsbDtcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCB8fCAoRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgQXJyYXkuaXNBcnJheShlKSB8fCAoZSA9IFtlXSksIGUuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IGkgPSBvIGluc3RhbmNlb2YgTm9kZTtcbiAgICB0LmFwcGVuZENoaWxkKGkgPyBvIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobykpO1xuICB9KSwgdGhpcy5pbnNlcnRCZWZvcmUodCwgdGhpcy5maXJzdENoaWxkKTtcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCB8fCAoRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCA9IGZ1bmN0aW9uKG4pIHtcbiAgbiA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyAhMCA6ICEhbjtcbiAgY29uc3QgZSA9IHRoaXMucGFyZW50Tm9kZSwgdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpLCBvID0gcGFyc2VJbnQodC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXRvcC13aWR0aFwiKSksIGkgPSBwYXJzZUludCh0LmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItbGVmdC13aWR0aFwiKSksIHMgPSB0aGlzLm9mZnNldFRvcCAtIGUub2Zmc2V0VG9wIDwgZS5zY3JvbGxUb3AsIHIgPSB0aGlzLm9mZnNldFRvcCAtIGUub2Zmc2V0VG9wICsgdGhpcy5jbGllbnRIZWlnaHQgLSBvID4gZS5zY3JvbGxUb3AgKyBlLmNsaWVudEhlaWdodCwgYSA9IHRoaXMub2Zmc2V0TGVmdCAtIGUub2Zmc2V0TGVmdCA8IGUuc2Nyb2xsTGVmdCwgbCA9IHRoaXMub2Zmc2V0TGVmdCAtIGUub2Zmc2V0TGVmdCArIHRoaXMuY2xpZW50V2lkdGggLSBpID4gZS5zY3JvbGxMZWZ0ICsgZS5jbGllbnRXaWR0aCwgYyA9IHMgJiYgIXI7XG4gIChzIHx8IHIpICYmIG4gJiYgKGUuc2Nyb2xsVG9wID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCAtIGUuY2xpZW50SGVpZ2h0IC8gMiAtIG8gKyB0aGlzLmNsaWVudEhlaWdodCAvIDIpLCAoYSB8fCBsKSAmJiBuICYmIChlLnNjcm9sbExlZnQgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgLSBlLmNsaWVudFdpZHRoIC8gMiAtIGkgKyB0aGlzLmNsaWVudFdpZHRoIC8gMiksIChzIHx8IHIgfHwgYSB8fCBsKSAmJiAhbiAmJiB0aGlzLnNjcm9sbEludG9WaWV3KGMpO1xufSk7XG53aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uKG4pIHtcbiAgY29uc3QgZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIG4oe1xuICAgICAgZGlkVGltZW91dDogITEsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDEpO1xufTtcbndpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uKG4pIHtcbiAgY2xlYXJUaW1lb3V0KG4pO1xufTtcbmxldCBWbiA9IChuID0gMjEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkobikpLnJlZHVjZSgoZSwgdCkgPT4gKHQgJj0gNjMsIHQgPCAzNiA/IGUgKz0gdC50b1N0cmluZygzNikgOiB0IDwgNjIgPyBlICs9ICh0IC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpIDogdCA+IDYyID8gZSArPSBcIi1cIiA6IGUgKz0gXCJfXCIsIGUpLCBcIlwiKTtcbnZhciBMbyA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLlZFUkJPU0UgPSBcIlZFUkJPU0VcIiwgbi5JTkZPID0gXCJJTkZPXCIsIG4uV0FSTiA9IFwiV0FSTlwiLCBuLkVSUk9SID0gXCJFUlJPUlwiLCBuKSkoTG8gfHwge30pO1xuY29uc3QgeSA9IHtcbiAgQkFDS1NQQUNFOiA4LFxuICBUQUI6IDksXG4gIEVOVEVSOiAxMyxcbiAgU0hJRlQ6IDE2LFxuICBDVFJMOiAxNyxcbiAgQUxUOiAxOCxcbiAgRVNDOiAyNyxcbiAgU1BBQ0U6IDMyLFxuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBET1dOOiA0MCxcbiAgUklHSFQ6IDM5LFxuICBERUxFVEU6IDQ2LFxuICBNRVRBOiA5MSxcbiAgU0xBU0g6IDE5MVxufSwgcW4gPSB7XG4gIExFRlQ6IDAsXG4gIFdIRUVMOiAxLFxuICBSSUdIVDogMixcbiAgQkFDS1dBUkQ6IDMsXG4gIEZPUldBUkQ6IDRcbn07XG5mdW5jdGlvbiBJZShuLCBlLCB0ID0gXCJsb2dcIiwgbywgaSA9IFwiY29sb3I6IGluaGVyaXRcIikge1xuICBpZiAoIShcImNvbnNvbGVcIiBpbiB3aW5kb3cpIHx8ICF3aW5kb3cuY29uc29sZVt0XSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSBbXCJpbmZvXCIsIFwibG9nXCIsIFwid2FyblwiLCBcImVycm9yXCJdLmluY2x1ZGVzKHQpLCByID0gW107XG4gIHN3aXRjaCAoSWUubG9nTGV2ZWwpIHtcbiAgICBjYXNlIFwiRVJST1JcIjpcbiAgICAgIGlmICh0ICE9PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJXQVJOXCI6XG4gICAgICBpZiAoIVtcImVycm9yXCIsIFwid2FyblwiXS5pbmNsdWRlcyh0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIklORk9cIjpcbiAgICAgIGlmICghcyB8fCBuKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgfVxuICBvICYmIHIucHVzaChvKTtcbiAgY29uc3QgYSA9IFwiRWRpdG9yLmpzIDIuMzEuMC1yYy43XCIsIGwgPSBgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGNvbG9yOiAjMDA2RkVBO1xuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgICAgICAgICBwYWRkaW5nOiA0cHggOXB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMzBweDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoNTYsIDEzOCwgMjI5LCAwLjE2KTtcbiAgICAgICAgICAgIG1hcmdpbjogNHB4IDVweCA0cHggMDtgO1xuICBuICYmIChzID8gKHIudW5zaGlmdChsLCBpKSwgZSA9IGAlYyR7YX0lYyAke2V9YCkgOiBlID0gYCggJHthfSApJHtlfWApO1xuICB0cnkge1xuICAgIHMgPyBvID8gY29uc29sZVt0XShgJHtlfSAlb2AsIC4uLnIpIDogY29uc29sZVt0XShlLCAuLi5yKSA6IGNvbnNvbGVbdF0oZSk7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5JZS5sb2dMZXZlbCA9IFwiVkVSQk9TRVwiO1xuZnVuY3Rpb24gWm4obikge1xuICBJZS5sb2dMZXZlbCA9IG47XG59XG5jb25zdCBTID0gSWUuYmluZCh3aW5kb3csICExKSwgWCA9IEllLmJpbmQod2luZG93LCAhMCk7XG5mdW5jdGlvbiBsZShuKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobikubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIEEobikge1xuICByZXR1cm4gbGUobikgPT09IFwiZnVuY3Rpb25cIiB8fCBsZShuKSA9PT0gXCJhc3luY2Z1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBEKG4pIHtcbiAgcmV0dXJuIGxlKG4pID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gdGUobikge1xuICByZXR1cm4gbGUobikgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBHbihuKSB7XG4gIHJldHVybiBsZShuKSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiB5byhuKSB7XG4gIHJldHVybiBsZShuKSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIHdvKG4pIHtcbiAgcmV0dXJuIGxlKG4pID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gVihuKSB7XG4gIHJldHVybiBuID8gT2JqZWN0LmtleXMobikubGVuZ3RoID09PSAwICYmIG4uY29uc3RydWN0b3IgPT09IE9iamVjdCA6ICEwO1xufVxuZnVuY3Rpb24gUG8obikge1xuICByZXR1cm4gbiA+IDQ3ICYmIG4gPCA1OCB8fCAvLyBudW1iZXIga2V5c1xuICBuID09PSAzMiB8fCBuID09PSAxMyB8fCAvLyBTcGFjZSBiYXIgJiByZXR1cm4ga2V5KHMpXG4gIG4gPT09IDIyOSB8fCAvLyBwcm9jZXNzaW5nIGtleSBpbnB1dCBmb3IgY2VydGFpbiBsYW5ndWFnZXMg4oCUIENoaW5lc2UsIEphcGFuZXNlLCBldGMuXG4gIG4gPiA2NCAmJiBuIDwgOTEgfHwgLy8gbGV0dGVyIGtleXNcbiAgbiA+IDk1ICYmIG4gPCAxMTIgfHwgLy8gTnVtcGFkIGtleXNcbiAgbiA+IDE4NSAmJiBuIDwgMTkzIHx8IC8vIDs9LC0uL2AgKGluIG9yZGVyKVxuICBuID4gMjE4ICYmIG4gPCAyMjM7XG59XG5hc3luYyBmdW5jdGlvbiBRbihuLCBlID0gKCkgPT4ge1xufSwgdCA9ICgpID0+IHtcbn0pIHtcbiAgYXN5bmMgZnVuY3Rpb24gbyhpLCBzLCByKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGkuZnVuY3Rpb24oaS5kYXRhKSwgYXdhaXQgcyh3byhpLmRhdGEpID8ge30gOiBpLmRhdGEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcih3byhpLmRhdGEpID8ge30gOiBpLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbi5yZWR1Y2UoYXN5bmMgKGksIHMpID0+IChhd2FpdCBpLCBvKHMsIGUsIHQpKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xufVxuZnVuY3Rpb24gTm8obikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobik7XG59XG5mdW5jdGlvbiBGZShuLCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcywgbyA9IGFyZ3VtZW50cztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBuLmFwcGx5KHQsIG8pLCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEpuKG4pIHtcbiAgcmV0dXJuIG4ubmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG59XG5mdW5jdGlvbiBlaShuKSB7XG4gIHJldHVybiAvXlstXFx3XStcXC8oWy0rXFx3XSt8XFwqKSQvLnRlc3Qobik7XG59XG5mdW5jdGlvbiBFbyhuLCBlLCB0KSB7XG4gIGxldCBvO1xuICByZXR1cm4gKC4uLmkpID0+IHtcbiAgICBjb25zdCBzID0gdGhpcywgciA9ICgpID0+IHtcbiAgICAgIG8gPSBudWxsLCB0IHx8IG4uYXBwbHkocywgaSk7XG4gICAgfSwgYSA9IHQgJiYgIW87XG4gICAgd2luZG93LmNsZWFyVGltZW91dChvKSwgbyA9IHdpbmRvdy5zZXRUaW1lb3V0KHIsIGUpLCBhICYmIG4uYXBwbHkocywgaSk7XG4gIH07XG59XG5mdW5jdGlvbiBkdChuLCBlLCB0ID0gdm9pZCAwKSB7XG4gIGxldCBvLCBpLCBzLCByID0gbnVsbCwgYSA9IDA7XG4gIHQgfHwgKHQgPSB7fSk7XG4gIGNvbnN0IGwgPSBmdW5jdGlvbigpIHtcbiAgICBhID0gdC5sZWFkaW5nID09PSAhMSA/IDAgOiBEYXRlLm5vdygpLCByID0gbnVsbCwgcyA9IG4uYXBwbHkobywgaSksIHIgfHwgKG8gPSBpID0gbnVsbCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjID0gRGF0ZS5ub3coKTtcbiAgICAhYSAmJiB0LmxlYWRpbmcgPT09ICExICYmIChhID0gYyk7XG4gICAgY29uc3QgdSA9IGUgLSAoYyAtIGEpO1xuICAgIHJldHVybiBvID0gdGhpcywgaSA9IGFyZ3VtZW50cywgdSA8PSAwIHx8IHUgPiBlID8gKHIgJiYgKGNsZWFyVGltZW91dChyKSwgciA9IG51bGwpLCBhID0gYywgcyA9IG4uYXBwbHkobywgaSksIHIgfHwgKG8gPSBpID0gbnVsbCkpIDogIXIgJiYgdC50cmFpbGluZyAhPT0gITEgJiYgKHIgPSBzZXRUaW1lb3V0KGwsIHUpKSwgcztcbiAgfTtcbn1cbmZ1bmN0aW9uIHRpKCkge1xuICBjb25zdCBuID0ge1xuICAgIHdpbjogITEsXG4gICAgbWFjOiAhMSxcbiAgICB4MTE6ICExLFxuICAgIGxpbnV4OiAhMVxuICB9LCBlID0gT2JqZWN0LmtleXMobikuZmluZCgodCkgPT4gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0KSAhPT0gLTEpO1xuICByZXR1cm4gZSAmJiAobltlXSA9ICEwKSwgbjtcbn1cbmZ1bmN0aW9uIGplKG4pIHtcbiAgcmV0dXJuIG5bMF0udG9VcHBlckNhc2UoKSArIG4uc2xpY2UoMSk7XG59XG5mdW5jdGlvbiB1dChuLCAuLi5lKSB7XG4gIGlmICghZS5sZW5ndGgpXG4gICAgcmV0dXJuIG47XG4gIGNvbnN0IHQgPSBlLnNoaWZ0KCk7XG4gIGlmIChEKG4pICYmIEQodCkpXG4gICAgZm9yIChjb25zdCBvIGluIHQpXG4gICAgICBEKHRbb10pID8gKG5bb10gfHwgT2JqZWN0LmFzc2lnbihuLCB7IFtvXToge30gfSksIHV0KG5bb10sIHRbb10pKSA6IE9iamVjdC5hc3NpZ24obiwgeyBbb106IHRbb10gfSk7XG4gIHJldHVybiB1dChuLCAuLi5lKTtcbn1cbmZ1bmN0aW9uIHZ0KG4pIHtcbiAgY29uc3QgZSA9IHRpKCk7XG4gIHJldHVybiBuID0gbi5yZXBsYWNlKC9zaGlmdC9naSwgXCLih6dcIikucmVwbGFjZSgvYmFja3NwYWNlL2dpLCBcIuKMq1wiKS5yZXBsYWNlKC9lbnRlci9naSwgXCLij45cIikucmVwbGFjZSgvdXAvZ2ksIFwi4oaRXCIpLnJlcGxhY2UoL2xlZnQvZ2ksIFwi4oaSXCIpLnJlcGxhY2UoL2Rvd24vZ2ksIFwi4oaTXCIpLnJlcGxhY2UoL3JpZ2h0L2dpLCBcIuKGkFwiKS5yZXBsYWNlKC9lc2NhcGUvZ2ksIFwi4o6LXCIpLnJlcGxhY2UoL2luc2VydC9naSwgXCJJbnNcIikucmVwbGFjZSgvZGVsZXRlL2dpLCBcIuKQoVwiKS5yZXBsYWNlKC9cXCsvZ2ksIFwiICsgXCIpLCBlLm1hYyA/IG4gPSBuLnJlcGxhY2UoL2N0cmx8Y21kL2dpLCBcIuKMmFwiKS5yZXBsYWNlKC9hbHQvZ2ksIFwi4oylXCIpIDogbiA9IG4ucmVwbGFjZSgvY21kL2dpLCBcIkN0cmxcIikucmVwbGFjZSgvd2luZG93cy9naSwgXCJXSU5cIiksIG47XG59XG5mdW5jdGlvbiBvaShuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwobikuaHJlZjtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIG4uc3Vic3RyaW5nKDAsIDIpID09PSBcIi8vXCIgPyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBuIDogd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIG47XG59XG5mdW5jdGlvbiBuaSgpIHtcbiAgcmV0dXJuIFZuKDEwKTtcbn1cbmZ1bmN0aW9uIGlpKG4pIHtcbiAgd2luZG93Lm9wZW4obiwgXCJfYmxhbmtcIik7XG59XG5mdW5jdGlvbiBzaShuID0gXCJcIikge1xuICByZXR1cm4gYCR7bn0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkudG9TdHJpbmcoMTYpfWA7XG59XG5mdW5jdGlvbiBodChuLCBlLCB0KSB7XG4gIGNvbnN0IG8gPSBgwqske2V9wrsgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFBsZWFzZSB1c2UgdGhlIMKrJHt0fcK7IGluc3RlYWQuYDtcbiAgbiAmJiBYKG8sIFwid2FyblwiKTtcbn1cbmZ1bmN0aW9uIG1lKG4sIGUsIHQpIHtcbiAgY29uc3QgbyA9IHQudmFsdWUgPyBcInZhbHVlXCIgOiBcImdldFwiLCBpID0gdFtvXSwgcyA9IGAjJHtlfUNhY2hlYDtcbiAgaWYgKHRbb10gPSBmdW5jdGlvbiguLi5yKSB7XG4gICAgcmV0dXJuIHRoaXNbc10gPT09IHZvaWQgMCAmJiAodGhpc1tzXSA9IGkuYXBwbHkodGhpcywgLi4ucikpLCB0aGlzW3NdO1xuICB9LCBvID09PSBcImdldFwiICYmIHQuc2V0KSB7XG4gICAgY29uc3QgciA9IHQuc2V0O1xuICAgIHQuc2V0ID0gZnVuY3Rpb24oYSkge1xuICAgICAgZGVsZXRlIG5bc10sIHIuYXBwbHkodGhpcywgYSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNvbnN0IFJvID0gNjUwO1xuZnVuY3Rpb24gYmUoKSB7XG4gIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShgKG1heC13aWR0aDogJHtSb31weClgKS5tYXRjaGVzO1xufVxuY29uc3QgcHQgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtICYmICgvaVAoYWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gXCJNYWNJbnRlbFwiICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKTtcbmZ1bmN0aW9uIHJpKG4sIGUpIHtcbiAgY29uc3QgdCA9IEFycmF5LmlzQXJyYXkobikgfHwgRChuKSwgbyA9IEFycmF5LmlzQXJyYXkoZSkgfHwgRChlKTtcbiAgcmV0dXJuIHQgfHwgbyA/IEpTT04uc3RyaW5naWZ5KG4pID09PSBKU09OLnN0cmluZ2lmeShlKSA6IG4gPT09IGU7XG59XG5jbGFzcyBkIHtcbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCB0YWcgaGFzIG5vIGNsb3NlZCB0YWdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFnIC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1NpbmdsZVRhZyhlKSB7XG4gICAgcmV0dXJuIGUudGFnTmFtZSAmJiBbXG4gICAgICBcIkFSRUFcIixcbiAgICAgIFwiQkFTRVwiLFxuICAgICAgXCJCUlwiLFxuICAgICAgXCJDT0xcIixcbiAgICAgIFwiQ09NTUFORFwiLFxuICAgICAgXCJFTUJFRFwiLFxuICAgICAgXCJIUlwiLFxuICAgICAgXCJJTUdcIixcbiAgICAgIFwiSU5QVVRcIixcbiAgICAgIFwiS0VZR0VOXCIsXG4gICAgICBcIkxJTktcIixcbiAgICAgIFwiTUVUQVwiLFxuICAgICAgXCJQQVJBTVwiLFxuICAgICAgXCJTT1VSQ0VcIixcbiAgICAgIFwiVFJBQ0tcIixcbiAgICAgIFwiV0JSXCJcbiAgICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGVsZW1lbnQgaXMgQlIgb3IgV0JSXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTGluZUJyZWFrVGFnKGUpIHtcbiAgICByZXR1cm4gZSAmJiBlLnRhZ05hbWUgJiYgW1xuICAgICAgXCJCUlwiLFxuICAgICAgXCJXQlJcIlxuICAgIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZvciBtYWtpbmcgRWxlbWVudHMgd2l0aCBjbGFzcyBuYW1lIGFuZCBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSAtIG5ldyBFbGVtZW50IHRhZyBuYW1lXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfHN0cmluZ30gW2NsYXNzTmFtZXNdIC0gbGlzdCBvciBuYW1lIG9mIENTUyBjbGFzcyBuYW1lKHMpXG4gICAqIEBwYXJhbSAge29iamVjdH0gW2F0dHJpYnV0ZXNdIC0gYW55IGF0dHJpYnV0ZXNcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIG1ha2UoZSwgdCA9IG51bGwsIG8gPSB7fSkge1xuICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICBjb25zdCBzID0gdC5maWx0ZXIoKHIpID0+IHIgIT09IHZvaWQgMCk7XG4gICAgICBpLmNsYXNzTGlzdC5hZGQoLi4ucyk7XG4gICAgfSBlbHNlXG4gICAgICB0ICYmIGkuY2xhc3NMaXN0LmFkZCh0KTtcbiAgICBmb3IgKGNvbnN0IHMgaW4gbylcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBzKSAmJiAoaVtzXSA9IG9bc10pO1xuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIFRleHQgTm9kZSB3aXRoIHRoZSBwYXNzZWQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIHRleHQgY29udGVudFxuICAgKiBAcmV0dXJucyB7VGV4dH1cbiAgICovXG4gIHN0YXRpYyB0ZXh0KGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBvbmUgb3Igc2V2ZXJhbCBlbGVtZW50cyB0byB0aGUgcGFyZW50XG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gcGFyZW50IC0gd2hlcmUgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSAge0VsZW1lbnR8RWxlbWVudFtdfERvY3VtZW50RnJhZ21lbnR8VGV4dHxUZXh0W119IGVsZW1lbnRzIC0gZWxlbWVudCBvciBlbGVtZW50cyBsaXN0XG4gICAqL1xuICBzdGF0aWMgYXBwZW5kKGUsIHQpIHtcbiAgICBBcnJheS5pc0FycmF5KHQpID8gdC5mb3JFYWNoKChvKSA9PiBlLmFwcGVuZENoaWxkKG8pKSA6IGUuYXBwZW5kQ2hpbGQodCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCBlbGVtZW50IG9yIGEgY291cGxlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhcmVudCBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAtIHdoZXJlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbGVtZW50cyAtIGVsZW1lbnQgb3IgZWxlbWVudHMgbGlzdFxuICAgKi9cbiAgc3RhdGljIHByZXBlbmQoZSwgdCkge1xuICAgIEFycmF5LmlzQXJyYXkodCkgPyAodCA9IHQucmV2ZXJzZSgpLCB0LmZvckVhY2goKG8pID0+IGUucHJlcGVuZChvKSkpIDogZS5wcmVwZW5kKHQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIHR3byBlbGVtZW50cyBpbiBwYXJlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwxIC0gZnJvbVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbDIgLSB0b1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgc3RhdGljIHN3YXAoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpID0gZS5wYXJlbnROb2RlO1xuICAgIGkuaW5zZXJ0QmVmb3JlKG8sIGUpLCBpLmluc2VydEJlZm9yZShlLCB0KSwgaS5pbnNlcnRCZWZvcmUodCwgbyksIGkucmVtb3ZlQ2hpbGQobyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdG9yIERlY29yYXRvclxuICAgKlxuICAgKiBSZXR1cm5zIGZpcnN0IG1hdGNoXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHdlIHNlYXJjaGluZyBpbnNpZGUuIERlZmF1bHQgLSBET00gRG9jdW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VhcmNoaW5nIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBmaW5kKGUgPSBkb2N1bWVudCwgdCkge1xuICAgIHJldHVybiBlLnF1ZXJ5U2VsZWN0b3IodCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBFbGVtZW50IGJ5IElkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGlkIHRvIGZpbmRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0b3IgRGVjb3JhdG9yLlxuICAgKlxuICAgKiBSZXR1cm5zIGFsbCBtYXRjaGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudH0gZWwgLSBlbGVtZW50IHdlIHNlYXJjaGluZyBpbnNpZGUuIERlZmF1bHQgLSBET00gRG9jdW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VhcmNoaW5nIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3R9XG4gICAqL1xuICBzdGF0aWMgZmluZEFsbChlID0gZG9jdW1lbnQsIHQpIHtcbiAgICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yQWxsKHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIENTUyBzZWxlY3RvciBmb3IgYWxsIHRleHQgaW5wdXRzXG4gICAqL1xuICBzdGF0aWMgZ2V0IGFsbElucHV0c1NlbGVjdG9yKCkge1xuICAgIHJldHVybiBcIltjb250ZW50ZWRpdGFibGU9dHJ1ZV0sIHRleHRhcmVhLCBpbnB1dDpub3QoW3R5cGVdKSwgXCIgKyBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIiwgXCJlbWFpbFwiLCBcIm51bWJlclwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiXS5tYXAoKHQpID0+IGBpbnB1dFt0eXBlPVwiJHt0fVwiXWApLmpvaW4oXCIsIFwiKTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbGwgY29udGVudGVkaXRhYmxlLCB0ZXh0YXJlYSBhbmQgZWRpdGFibGUgaW5wdXQgZWxlbWVudHMgcGFzc2VkIGhvbGRlciBjb250YWluc1xuICAgKlxuICAgKiBAcGFyYW0gaG9sZGVyIC0gZWxlbWVudCB3aGVyZSB0byBmaW5kIGlucHV0c1xuICAgKi9cbiAgc3RhdGljIGZpbmRBbGxJbnB1dHMoZSkge1xuICAgIHJldHVybiBObyhlLnF1ZXJ5U2VsZWN0b3JBbGwoZC5hbGxJbnB1dHNTZWxlY3RvcikpLnJlZHVjZSgodCwgbykgPT4gZC5pc05hdGl2ZUlucHV0KG8pIHx8IGQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMobykgPyBbLi4udCwgb10gOiBbLi4udCwgLi4uZC5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyhvKV0sIFtdKTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIGZvciBkZWVwZXN0IG5vZGUgd2hpY2ggaXMgTGVhZi5cbiAgICogTGVhZiBpcyB0aGUgdmVydGV4IHRoYXQgZG9lc24ndCBoYXZlIGFueSBjaGlsZCBub2Rlc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHJlY3Vyc2l2ZWx5IGdvZXMgdGhyb3cgdGhlIGFsbCBOb2RlIHVudGlsIGl0IGZpbmRzIHRoZSBMZWFmXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHJvb3QgTm9kZS4gRnJvbSB0aGlzIHZlcnRleCB3ZSBzdGFydCBEZWVwLWZpcnN0IHNlYXJjaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVwdGgtZmlyc3Rfc2VhcmNofVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthdExhc3RdIC0gZmluZCBsYXN0IHRleHQgbm9kZVxuICAgKiBAcmV0dXJucyAtIGl0IGNhbiBiZSB0ZXh0IE5vZGUgb3IgRWxlbWVudCBOb2RlLCBzbyB0aGF0IGNhcmV0IHdpbGwgYWJsZSB0byB3b3JrIHdpdGggaXRcbiAgICogICAgICAgICAgICBDYW4gcmV0dXJuIG51bGwgaWYgbm9kZSBpcyBEb2N1bWVudCBvciBEb2N1bWVudEZyYWdtZW50LCBvciBub2RlIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgRE9NXG4gICAqL1xuICBzdGF0aWMgZ2V0RGVlcGVzdE5vZGUoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgbyA9IHQgPyBcImxhc3RDaGlsZFwiIDogXCJmaXJzdENoaWxkXCIsIGkgPSB0ID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIjtcbiAgICBpZiAoZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlW29dKSB7XG4gICAgICBsZXQgcyA9IGVbb107XG4gICAgICBpZiAoZC5pc1NpbmdsZVRhZyhzKSAmJiAhZC5pc05hdGl2ZUlucHV0KHMpICYmICFkLmlzTGluZUJyZWFrVGFnKHMpKVxuICAgICAgICBpZiAoc1tpXSlcbiAgICAgICAgICBzID0gc1tpXTtcbiAgICAgICAgZWxzZSBpZiAocy5wYXJlbnROb2RlW2ldKVxuICAgICAgICAgIHMgPSBzLnBhcmVudE5vZGVbaV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gcy5wYXJlbnROb2RlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVlcGVzdE5vZGUocywgdCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmplY3QgaXMgRE9NIG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlIC0gb2JqZWN0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc3RhdGljIGlzRWxlbWVudChlKSB7XG4gICAgcmV0dXJuIHlvKGUpID8gITEgOiBlICYmIGUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9iamVjdCBpcyBEb2N1bWVudEZyYWdtZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5vZGUgLSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNGcmFnbWVudChlKSB7XG4gICAgcmV0dXJuIHlvKGUpID8gITEgOiBlICYmIGUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBpcyBjb250ZW50ZWRpdGFibGVcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0NvbnRlbnRFZGl0YWJsZShlKSB7XG4gICAgcmV0dXJuIGUuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRhcmdldCBpZiBpdCBpcyBuYXRpdmUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgLSBIVE1MIGVsZW1lbnQgb3Igc3RyaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc3RhdGljIGlzTmF0aXZlSW5wdXQoZSkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICBcIklOUFVUXCIsXG4gICAgICBcIlRFWFRBUkVBXCJcbiAgICBdO1xuICAgIHJldHVybiBlICYmIGUudGFnTmFtZSA/IHQuaW5jbHVkZXMoZS50YWdOYW1lKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgd2UgY2FuIHNldCBjYXJldFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSB0YXJnZXQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY2FuU2V0Q2FyZXQoZSkge1xuICAgIGxldCB0ID0gITA7XG4gICAgaWYgKGQuaXNOYXRpdmVJbnB1dChlKSlcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJyZXNldFwiOlxuICAgICAgICAgIHQgPSAhMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB0ID0gZC5pc0NvbnRlbnRFZGl0YWJsZShlKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIG5vZGUgaWYgaXQgaXMgZW1wdHlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBjaGVja3Mgc2ltcGxlIE5vZGUgd2l0aG91dCBhbnkgY2hpbGRzIGZvciBlbXB0aW5lc3NcbiAgICogSWYgeW91IGhhdmUgTm9kZSB3aXRoIDIgb3IgbW9yZSBjaGlsZHJlbiBpZCBkZXB0aCwgeW91IGJldHRlciB1c2Uge0BsaW5rIERvbSNpc0VtcHR5fSBtZXRob2RcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2lnbm9yZUNoYXJzXSAtIGNoYXIgb3Igc3Vic3RyaW5nIHRvIHRyZWF0IGFzIGVtcHR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0IGlzIGVtcHR5XG4gICAqL1xuICBzdGF0aWMgaXNOb2RlRW1wdHkoZSwgdCkge1xuICAgIGxldCBvO1xuICAgIHJldHVybiB0aGlzLmlzU2luZ2xlVGFnKGUpICYmICF0aGlzLmlzTGluZUJyZWFrVGFnKGUpID8gITEgOiAodGhpcy5pc0VsZW1lbnQoZSkgJiYgdGhpcy5pc05hdGl2ZUlucHV0KGUpID8gbyA9IGUudmFsdWUgOiBvID0gZS50ZXh0Q29udGVudC5yZXBsYWNlKFwi4oCLXCIsIFwiXCIpLCB0ICYmIChvID0gby5yZXBsYWNlKG5ldyBSZWdFeHAodCwgXCJnXCIpLCBcIlwiKSksIG8ubGVuZ3RoID09PSAwKTtcbiAgfVxuICAvKipcbiAgICogY2hlY2tzIG5vZGUgaWYgaXQgaXMgZG9lc24ndCBoYXZlIGFueSBjaGlsZCBub2Rlc1xuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzTGVhZihlKSB7XG4gICAgcmV0dXJuIGUgPyBlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIChCRlMpXG4gICAqIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaH1cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFB1c2hlcyB0byBzdGFjayBhbGwgRE9NIGxlYWZzIGFuZCBjaGVja3MgZm9yIGVtcHRpbmVzc1xuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWdub3JlQ2hhcnNdIC0gY2hhciBvciBzdWJzdHJpbmcgdG8gdHJlYXQgYXMgZW1wdHlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eShlLCB0KSB7XG4gICAgY29uc3QgbyA9IFtlXTtcbiAgICBmb3IgKDsgby5sZW5ndGggPiAwOyApXG4gICAgICBpZiAoZSA9IG8uc2hpZnQoKSwgISFlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGVhZihlKSAmJiAhdGhpcy5pc05vZGVFbXB0eShlLCB0KSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGUuY2hpbGROb2RlcyAmJiBvLnB1c2goLi4uQXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpKTtcbiAgICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHN0cmluZyBjb250YWlucyBodG1sIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNIVE1MU3RyaW5nKGUpIHtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwiZGl2XCIpO1xuICAgIHJldHVybiB0LmlubmVySFRNTCA9IGUsIHQuY2hpbGRFbGVtZW50Q291bnQgPiAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbGVuZ3RoIG9mIG5vZGVgcyB0ZXh0IGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB3aXRoIGNvbnRlbnRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXRDb250ZW50TGVuZ3RoKGUpIHtcbiAgICByZXR1cm4gZC5pc05hdGl2ZUlucHV0KGUpID8gZS52YWx1ZS5sZW5ndGggOiBlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGUubGVuZ3RoIDogZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhcnJheSBvZiBuYW1lcyBvZiBibG9jayBodG1sIGVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIHN0YXRpYyBnZXQgYmxvY2tFbGVtZW50cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJhZGRyZXNzXCIsXG4gICAgICBcImFydGljbGVcIixcbiAgICAgIFwiYXNpZGVcIixcbiAgICAgIFwiYmxvY2txdW90ZVwiLFxuICAgICAgXCJjYW52YXNcIixcbiAgICAgIFwiZGl2XCIsXG4gICAgICBcImRsXCIsXG4gICAgICBcImR0XCIsXG4gICAgICBcImZpZWxkc2V0XCIsXG4gICAgICBcImZpZ2NhcHRpb25cIixcbiAgICAgIFwiZmlndXJlXCIsXG4gICAgICBcImZvb3RlclwiLFxuICAgICAgXCJmb3JtXCIsXG4gICAgICBcImgxXCIsXG4gICAgICBcImgyXCIsXG4gICAgICBcImgzXCIsXG4gICAgICBcImg0XCIsXG4gICAgICBcImg1XCIsXG4gICAgICBcImg2XCIsXG4gICAgICBcImhlYWRlclwiLFxuICAgICAgXCJoZ3JvdXBcIixcbiAgICAgIFwiaHJcIixcbiAgICAgIFwibGlcIixcbiAgICAgIFwibWFpblwiLFxuICAgICAgXCJuYXZcIixcbiAgICAgIFwibm9zY3JpcHRcIixcbiAgICAgIFwib2xcIixcbiAgICAgIFwib3V0cHV0XCIsXG4gICAgICBcInBcIixcbiAgICAgIFwicHJlXCIsXG4gICAgICBcInJ1YnlcIixcbiAgICAgIFwic2VjdGlvblwiLFxuICAgICAgXCJ0YWJsZVwiLFxuICAgICAgXCJ0Ym9keVwiLFxuICAgICAgXCJ0aGVhZFwiLFxuICAgICAgXCJ0clwiLFxuICAgICAgXCJ0Zm9vdFwiLFxuICAgICAgXCJ1bFwiLFxuICAgICAgXCJ2aWRlb1wiXG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGNvbnRlbnQgaW5jbHVkZXMgb25seSBpbmxpbmUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGRhdGEgLSBlbGVtZW50IG9yIGh0bWwgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUpIHtcbiAgICBsZXQgdDtcbiAgICB0ZShlKSA/ICh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdC5pbm5lckhUTUwgPSBlKSA6IHQgPSBlO1xuICAgIGNvbnN0IG8gPSAoaSkgPT4gIWQuYmxvY2tFbGVtZW50cy5pbmNsdWRlcyhpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgQXJyYXkuZnJvbShpLmNoaWxkcmVuKS5ldmVyeShvKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0LmNoaWxkcmVuKS5ldmVyeShvKTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbmQgcmV0dXJuIGFsbCBibG9jayBlbGVtZW50cyBpbiB0aGUgcGFzc2VkIHBhcmVudCAoaW5jbHVkaW5nIHN1YnRyZWUpXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCAtIHJvb3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIHN0YXRpYyBnZXREZWVwZXN0QmxvY2tFbGVtZW50cyhlKSB7XG4gICAgcmV0dXJuIGQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMoZSkgPyBbZV0gOiBBcnJheS5mcm9tKGUuY2hpbGRyZW4pLnJlZHVjZSgodCwgbykgPT4gWy4uLnQsIC4uLmQuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMobyldLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgZ2V0IGhvbGRlciBmcm9tIHtzdHJpbmd9IG9yIHJldHVybiBIVE1MRWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhUTUxFbGVtZW50fSBlbGVtZW50IC0gaG9sZGVyJ3MgaWQgb3IgaG9sZGVyJ3MgSFRNTCBFbGVtZW50XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBnZXRIb2xkZXIoZSkge1xuICAgIHJldHVybiB0ZShlKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpIDogZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgYW5jaG9yIChpcyBBIHRhZylcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0FuY2hvcihlKSB7XG4gICAgcmV0dXJuIGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGVsZW1lbnQncyBvZmZzZXQgcmVsYXRlZCB0byB0aGUgZG9jdW1lbnRcbiAgICpcbiAgICogQHRvZG8gaGFuZGxlIGNhc2Ugd2hlbiBlZGl0b3IgaW5pdGlhbGl6ZWQgaW4gc2Nyb2xsYWJsZSBwb3B1cFxuICAgKiBAcGFyYW0gZWwgLSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0XG4gICAqL1xuICBzdGF0aWMgb2Zmc2V0KGUpIHtcbiAgICBjb25zdCB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgaSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLCBzID0gdC50b3AgKyBpLCByID0gdC5sZWZ0ICsgbztcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBzLFxuICAgICAgbGVmdDogcixcbiAgICAgIGJvdHRvbTogcyArIHQuaGVpZ2h0LFxuICAgICAgcmlnaHQ6IHIgKyB0LndpZHRoXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gYWkobikge1xuICByZXR1cm4gIS9bXlxcdFxcblxcciBdLy50ZXN0KG4pO1xufVxuZnVuY3Rpb24gbGkobikge1xuICBjb25zdCBlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobiksIHQgPSBwYXJzZUZsb2F0KGUuZm9udFNpemUpLCBvID0gcGFyc2VGbG9hdChlLmxpbmVIZWlnaHQpIHx8IHQgKiAxLjIsIGkgPSBwYXJzZUZsb2F0KGUucGFkZGluZ1RvcCksIHMgPSBwYXJzZUZsb2F0KGUuYm9yZGVyVG9wV2lkdGgpLCByID0gcGFyc2VGbG9hdChlLm1hcmdpblRvcCksIGEgPSB0ICogMC44LCBsID0gKG8gLSB0KSAvIDI7XG4gIHJldHVybiByICsgcyArIGkgKyBsICsgYTtcbn1cbmZ1bmN0aW9uIERvKG4pIHtcbiAgbi5kYXRhc2V0LmVtcHR5ID0gZC5pc0VtcHR5KG4pID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG59XG5jb25zdCBjaSA9IHtcbiAgYmxvY2tUdW5lczoge1xuICAgIHRvZ2dsZXI6IHtcbiAgICAgIFwiQ2xpY2sgdG8gdHVuZVwiOiBcIlwiLFxuICAgICAgXCJvciBkcmFnIHRvIG1vdmVcIjogXCJcIlxuICAgIH1cbiAgfSxcbiAgaW5saW5lVG9vbGJhcjoge1xuICAgIGNvbnZlcnRlcjoge1xuICAgICAgXCJDb252ZXJ0IHRvXCI6IFwiXCJcbiAgICB9XG4gIH0sXG4gIHRvb2xiYXI6IHtcbiAgICB0b29sYm94OiB7XG4gICAgICBBZGQ6IFwiXCJcbiAgICB9XG4gIH0sXG4gIHBvcG92ZXI6IHtcbiAgICBGaWx0ZXI6IFwiXCIsXG4gICAgXCJOb3RoaW5nIGZvdW5kXCI6IFwiXCIsXG4gICAgXCJDb252ZXJ0IHRvXCI6IFwiXCJcbiAgfVxufSwgZGkgPSB7XG4gIFRleHQ6IFwiXCIsXG4gIExpbms6IFwiXCIsXG4gIEJvbGQ6IFwiXCIsXG4gIEl0YWxpYzogXCJcIlxufSwgdWkgPSB7XG4gIGxpbms6IHtcbiAgICBcIkFkZCBhIGxpbmtcIjogXCJcIlxuICB9LFxuICBzdHViOiB7XG4gICAgXCJUaGUgYmxvY2sgY2FuIG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LlwiOiBcIlwiXG4gIH1cbn0sIGhpID0ge1xuICBkZWxldGU6IHtcbiAgICBEZWxldGU6IFwiXCIsXG4gICAgXCJDbGljayB0byBkZWxldGVcIjogXCJcIlxuICB9LFxuICBtb3ZlVXA6IHtcbiAgICBcIk1vdmUgdXBcIjogXCJcIlxuICB9LFxuICBtb3ZlRG93bjoge1xuICAgIFwiTW92ZSBkb3duXCI6IFwiXCJcbiAgfVxufSwgRm8gPSB7XG4gIHVpOiBjaSxcbiAgdG9vbE5hbWVzOiBkaSxcbiAgdG9vbHM6IHVpLFxuICBibG9ja1R1bmVzOiBoaVxufSwgam8gPSBjbGFzcyBoZSB7XG4gIC8qKlxuICAgKiBUeXBlLXNhZmUgdHJhbnNsYXRpb24gZm9yIGludGVybmFsIFVJIHRleHRzOlxuICAgKiBQZXJmb3JtIHRyYW5zbGF0aW9uIG9mIHRoZSBzdHJpbmcgYnkgbmFtZXNwYWNlIGFuZCBhIGtleVxuICAgKlxuICAgKiBAZXhhbXBsZSBJMThuLnVpKEkxOG5JbnRlcm5hbE5TLnVpLmJsb2NrVHVuZXMudG9nZ2xlciwgJ0NsaWNrIHRvIHR1bmUnKVxuICAgKiBAcGFyYW0gaW50ZXJuYWxOYW1lc3BhY2UgLSBwYXRoIHRvIHRyYW5zbGF0ZWQgc3RyaW5nIGluIGRpY3Rpb25hcnlcbiAgICogQHBhcmFtIGRpY3RLZXkgLSBkaWN0aW9uYXJ5IGtleS4gQmV0dGVyIHRvIHVzZSBkZWZhdWx0IGxvY2FsZSBvcmlnaW5hbCB0ZXh0XG4gICAqL1xuICBzdGF0aWMgdWkoZSwgdCkge1xuICAgIHJldHVybiBoZS5fdChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNsYXRlIGZvciBleHRlcm5hbCBzdHJpbmdzIHRoYXQgaXMgbm90IHByZXNlbnRlZCBpbiBkZWZhdWx0IGRpY3Rpb25hcnkuXG4gICAqIEZvciBleGFtcGxlLCBmb3IgdXNlci1zcGVjaWZpZWQgdG9vbCBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIHQoZSwgdCkge1xuICAgIHJldHVybiBoZS5fdChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWRqdXN0IG1vZHVsZSBmb3IgdXNpbmcgZXh0ZXJuYWwgZGljdGlvbmFyeVxuICAgKlxuICAgKiBAcGFyYW0gZGljdGlvbmFyeSAtIG5ldyBtZXNzYWdlcyBsaXN0IHRvIG92ZXJyaWRlIGRlZmF1bHRcbiAgICovXG4gIHN0YXRpYyBzZXREaWN0aW9uYXJ5KGUpIHtcbiAgICBoZS5jdXJyZW50RGljdGlvbmFyeSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gdHJhbnNsYXRpb24gYm90aCBmb3IgaW50ZXJuYWwgYW5kIGV4dGVybmFsIG5hbWVzcGFjZXNcbiAgICogSWYgdGhlcmUgaXMgbm8gdHJhbnNsYXRpb24gZm91bmQsIHJldHVybnMgcGFzc2VkIGtleSBhcyBhIHRyYW5zbGF0ZWQgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIF90KGUsIHQpIHtcbiAgICBjb25zdCBvID0gaGUuZ2V0TmFtZXNwYWNlKGUpO1xuICAgIHJldHVybiAhbyB8fCAhb1t0XSA/IHQgOiBvW3RdO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIG1lc3NhZ2VzIHNlY3Rpb24gYnkgbmFtZXNwYWNlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gc2VjdGlvblxuICAgKi9cbiAgc3RhdGljIGdldE5hbWVzcGFjZShlKSB7XG4gICAgcmV0dXJuIGUuc3BsaXQoXCIuXCIpLnJlZHVjZSgobywgaSkgPT4gIW8gfHwgIU9iamVjdC5rZXlzKG8pLmxlbmd0aCA/IHt9IDogb1tpXSwgaGUuY3VycmVudERpY3Rpb25hcnkpO1xuICB9XG59O1xuam8uY3VycmVudERpY3Rpb25hcnkgPSBGbztcbmxldCB6ID0gam87XG5jbGFzcyBIbyBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIE9lIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW55IGV2ZW50IG9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uKGUsIHQpIHtcbiAgICBlIGluIHRoaXMuc3Vic2NyaWJlcnMgfHwgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPSBbXSksIHRoaXMuc3Vic2NyaWJlcnNbZV0ucHVzaCh0KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIGFueSBldmVudCBvbiBjYWxsYmFjay4gQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbmQgYmUgcmVtb3ZlZCBmcm9tIHN1YnNjcmliZXJzIGFycmF5IGFmdGVyIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uY2UoZSwgdCkge1xuICAgIGUgaW4gdGhpcy5zdWJzY3JpYmVycyB8fCAodGhpcy5zdWJzY3JpYmVyc1tlXSA9IFtdKTtcbiAgICBjb25zdCBvID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0KGkpLCByID0gdGhpcy5zdWJzY3JpYmVyc1tlXS5pbmRleE9mKG8pO1xuICAgICAgcmV0dXJuIHIgIT09IC0xICYmIHRoaXMuc3Vic2NyaWJlcnNbZV0uc3BsaWNlKHIsIDEpLCBzO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyc1tlXS5wdXNoKG8pO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGNhbGxiYWNrcyB3aXRoIHBhc3NlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBkYXRhIC0gc3Vic2NyaWJlcnMgZ2V0IHRoaXMgZGF0YSB3aGVuIHRoZXkgd2VyZSBmaXJlZFxuICAgKi9cbiAgZW1pdChlLCB0KSB7XG4gICAgVih0aGlzLnN1YnNjcmliZXJzKSB8fCAhdGhpcy5zdWJzY3JpYmVyc1tlXSB8fCB0aGlzLnN1YnNjcmliZXJzW2VdLnJlZHVjZSgobywgaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IGkobyk7XG4gICAgICByZXR1cm4gcyAhPT0gdm9pZCAwID8gcyA6IG87XG4gICAgfSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGNhbGxiYWNrIGZyb20gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb2ZmKGUsIHQpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVyc1tlXSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEV2ZW50RGlzcGF0Y2hlciAub2ZmKCk6IHRoZXJlIGlzIG5vIHN1YnNjcmliZXJzIGZvciBldmVudCBcIiR7ZS50b1N0cmluZygpfVwiLiBQcm9iYWJseSwgLm9mZigpIGNhbGxlZCBiZWZvcmUgLm9uKClgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0aGlzLnN1YnNjcmliZXJzW2VdLmxlbmd0aDsgbysrKVxuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlcnNbZV1bb10gPT09IHQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3Vic2NyaWJlcnNbZV1bb107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95ZXJcbiAgICogY2xlYXJzIHN1YnNjcmliZXJzIGxpc3RcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICB9XG59XG5mdW5jdGlvbiBKKG4pIHtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBpZFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gbi5pZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvb2wgbmFtZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBuLm5hbWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUb29sIGNvbmZpZyBwYXNzZWQgb24gRWRpdG9yJ3MgaW5pdGlhbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtUb29sQ29uZmlnfVxuICAgICAqL1xuICAgIGdldCBjb25maWcoKSB7XG4gICAgICByZXR1cm4gbi5jb25maWc7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAuY2UtYmxvY2sgZWxlbWVudCwgdGhhdCB3cmFwcyBwbHVnaW4gY29udGVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgaG9sZGVyKCkge1xuICAgICAgcmV0dXJuIG4uaG9sZGVyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBjb250ZW50IGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiBuLmlzRW1wdHk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGlzIHNlbGVjdGVkIHdpdGggQ3Jvc3MtQmxvY2sgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gbi5zZWxlY3RlZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCBCbG9jaydzIHN0cmV0Y2ggc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUg4oCUIHN0YXRlIHRvIHNldFxuICAgICAqL1xuICAgIHNldCBzdHJldGNoZWQodCkge1xuICAgICAgbi5zdHJldGNoZWQgPSB0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBpcyBzdHJldGNoZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBzdHJldGNoZWQoKSB7XG4gICAgICByZXR1cm4gbi5zdHJldGNoZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGhhcyBpbnB1dHMgdG8gYmUgZm9jdXNlZFxuICAgICAqL1xuICAgIGdldCBmb2N1c2FibGUoKSB7XG4gICAgICByZXR1cm4gbi5mb2N1c2FibGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFRvb2wgbWV0aG9kIHdpdGggZXJyb3JzIGhhbmRsZXIgdW5kZXItdGhlLWhvb2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0gLSBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3Vua25vd259XG4gICAgICovXG4gICAgY2FsbCh0LCBvKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHQsIG8pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2F2ZSBCbG9jayBjb250ZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkfFNhdmVkRGF0YT59XG4gICAgICovXG4gICAgc2F2ZSgpIHtcbiAgICAgIHJldHVybiBuLnNhdmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIEJsb2NrIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gZGF0YSAtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh0KSB7XG4gICAgICByZXR1cm4gbi52YWxpZGF0ZSh0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBzYXkgRWRpdG9yIHRoYXQgQmxvY2sgd2FzIGNoYW5nZWQuIFVzZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBFZGl0b3IncyAnb25DaGFuZ2UnIGNhbGxiYWNrXG4gICAgICogQ2FuIGJlIHVzZWZ1bCBmb3IgYmxvY2sgY2hhbmdlcyBpbnZpc2libGUgZm9yIGVkaXRvciBjb3JlLlxuICAgICAqL1xuICAgIGRpc3BhdGNoQ2hhbmdlKCkge1xuICAgICAgbi5kaXNwYXRjaENoYW5nZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVG9vbCBjb3VsZCBzcGVjaWZ5IHNldmVyYWwgZW50cmllcyB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIFRvb2xib3ggKGZvciBleGFtcGxlLCBcIkhlYWRpbmcgMVwiLCBcIkhlYWRpbmcgMlwiLCBcIkhlYWRpbmcgM1wiKVxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVudHJ5IHRoYXQgaXMgcmVsYXRlZCB0byB0aGUgQmxvY2sgKGRlcGVuZGVkIG9uIHRoZSBCbG9jayBkYXRhKVxuICAgICAqL1xuICAgIGdldEFjdGl2ZVRvb2xib3hFbnRyeSgpIHtcbiAgICAgIHJldHVybiBuLmdldEFjdGl2ZVRvb2xib3hFbnRyeSgpO1xuICAgIH1cbiAgfSk7XG59XG5jbGFzcyBfZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWxsTGlzdGVuZXJzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZXZlbnQgbGlzdGVuZXIgb24gZWxlbWVudCBhbmQgcmV0dXJucyB1bmlxdWUgaWRlbnRpZmllclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gRE9NIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBiZSBsaXN0ZW5lZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gbWV0aG9kIHRoYXQgd2lsbCBiZSBmaXJlZCBvbiBldmVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSB1c2VDYXB0dXJlIG9yIHtjYXB0dXJlLCBwYXNzaXZlLCBvbmNlfVxuICAgKi9cbiAgb24oZSwgdCwgbywgaSA9ICExKSB7XG4gICAgY29uc3QgcyA9IHNpKFwibFwiKSwgciA9IHtcbiAgICAgIGlkOiBzLFxuICAgICAgZWxlbWVudDogZSxcbiAgICAgIGV2ZW50VHlwZTogdCxcbiAgICAgIGhhbmRsZXI6IG8sXG4gICAgICBvcHRpb25zOiBpXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuZmluZE9uZShlLCB0LCBvKSlcbiAgICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5wdXNoKHIpLCBlLmFkZEV2ZW50TGlzdGVuZXIodCwgbywgaSksIHM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIgZnJvbSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gZWxlbWVudCB0aGF0IHdlIHJlbW92aW5nIGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSByZW1vdmUgaGFuZGxlciwgaWYgZWxlbWVudCBsaXN0ZW5zIHNldmVyYWwgaGFuZGxlcnMgb24gdGhlIHNhbWUgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSB1c2VDYXB0dXJlIG9yIHtjYXB0dXJlLCBwYXNzaXZlLCBvbmNlfVxuICAgKi9cbiAgb2ZmKGUsIHQsIG8sIGkpIHtcbiAgICBjb25zdCBzID0gdGhpcy5maW5kQWxsKGUsIHQsIG8pO1xuICAgIHMuZm9yRWFjaCgociwgYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IHRoaXMuYWxsTGlzdGVuZXJzLmluZGV4T2Yoc1thXSk7XG4gICAgICBsID4gLTEgJiYgKHRoaXMuYWxsTGlzdGVuZXJzLnNwbGljZShsLCAxKSwgci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoci5ldmVudFR5cGUsIHIuaGFuZGxlciwgci5vcHRpb25zKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gbGlzdGVuZXIgaWRlbnRpZmllclxuICAgKi9cbiAgb2ZmQnlJZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmluZEJ5SWQoZSk7XG4gICAgdCAmJiB0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LmV2ZW50VHlwZSwgdC5oYW5kbGVyLCB0Lm9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyBhbmQgcmV0dXJucyBmaXJzdCBsaXN0ZW5lciBieSBwYXNzZWQgcGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBldmVudCB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtldmVudFR5cGVdIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGF8bnVsbH1cbiAgICovXG4gIGZpbmRPbmUoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSB0aGlzLmZpbmRBbGwoZSwgdCwgbyk7XG4gICAgcmV0dXJuIGkubGVuZ3RoID4gMCA/IGlbMF0gOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHN0b3JlZCBsaXN0ZW5lcnMgYnkgcGFzc2VkIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gZXZlbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX1cbiAgICovXG4gIGZpbmRBbGwoZSwgdCwgbykge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHMgPSBlID8gdGhpcy5maW5kQnlFdmVudFRhcmdldChlKSA6IFtdO1xuICAgIHJldHVybiBlICYmIHQgJiYgbyA/IGkgPSBzLmZpbHRlcigocikgPT4gci5ldmVudFR5cGUgPT09IHQgJiYgci5oYW5kbGVyID09PSBvKSA6IGUgJiYgdCA/IGkgPSBzLmZpbHRlcigocikgPT4gci5ldmVudFR5cGUgPT09IHQpIDogaSA9IHMsIGk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgKi9cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuYWxsTGlzdGVuZXJzLm1hcCgoZSkgPT4ge1xuICAgICAgZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS5ldmVudFR5cGUsIGUuaGFuZGxlciwgZS5vcHRpb25zKTtcbiAgICB9KSwgdGhpcy5hbGxMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIGNsZWFudXAgb24gZGVzdHJ1Y3Rpb25cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBzZWFyY2hpbmcgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3RlbmVycyB0aGF0IGZvdW5kIG9uIGVsZW1lbnRcbiAgICovXG4gIGZpbmRCeUV2ZW50VGFyZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5lbGVtZW50ID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBldmVudCB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5VHlwZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbHRlcigodCkgPT4ge1xuICAgICAgaWYgKHQuZXZlbnRUeXBlID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VhcmNoIG1ldGhvZDogbG9va3MgZm9yIGxpc3RlbmVyIGJ5IHBhc3NlZCBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGFbXX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5SGFuZGxlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbHRlcigodCkgPT4ge1xuICAgICAgaWYgKHQuaGFuZGxlciA9PT0gZSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdGVuZXIgZGF0YSBmb3VuZCBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBsaXN0ZW5lciBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtMaXN0ZW5lckRhdGF9XG4gICAqL1xuICBmaW5kQnlJZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbmQoKHQpID0+IHQuaWQgPT09IGUpO1xuICB9XG59XG5jbGFzcyBFIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE1vZHVsZSBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIE1vZHVsZSBjb25maWdcbiAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRzRGlzcGF0Y2hlciAtIENvbW1vbiBldmVudCBidXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBpZiAodGhpcy5ub2RlcyA9IHt9LCB0aGlzLmxpc3RlbmVycyA9IG5ldyBfZSgpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQXNzaWducyBldmVudCBsaXN0ZW5lciBvbiBET00gZWxlbWVudCBhbmQgcHVzaGVzIGludG8gc3BlY2lhbCBhcnJheSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gRE9NIEVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBFdmVudCBuYW1lXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlclxuICAgICAgICogQHBhcmFtIHtib29sZWFufEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zIC0gTGlzdGVuaW5nIG9wdGlvbnNcbiAgICAgICAqL1xuICAgICAgb246IChvLCBpLCBzLCByID0gITEpID0+IHtcbiAgICAgICAgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMucHVzaChcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5vbihvLCBpLCBzLCByKVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJzIGFsbCBtdXRhYmxlIGxpc3RlbmVyc1xuICAgICAgICovXG4gICAgICBjbGVhckFsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMpXG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMub2ZmQnlJZChvKTtcbiAgICAgICAgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm11dGFibGVMaXN0ZW5lcklkcyA9IFtdLCBuZXcudGFyZ2V0ID09PSBFKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9ycyBmb3IgYWJzdHJhY3QgY2xhc3MgTW9kdWxlIGFyZSBub3QgYWxsb3dlZC5cIik7XG4gICAgdGhpcy5jb25maWcgPSBlLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBFZGl0b3IgbW9kdWxlcyBzZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtFZGl0b3JNb2R1bGVzfSBFZGl0b3IgLSBFZGl0b3IncyBNb2R1bGVzXG4gICAqL1xuICBzZXQgc3RhdGUoZSkge1xuICAgIHRoaXMuRWRpdG9yID0gZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIG1lbW9yaXplZCBub2Rlc1xuICAgKi9cbiAgcmVtb3ZlQWxsTm9kZXMoKSB7XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMubm9kZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLm5vZGVzW2VdO1xuICAgICAgdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY3VycmVudCBkaXJlY3Rpb24gaXMgUlRMIChSaWdodC1Uby1MZWZ0KVxuICAgKi9cbiAgZ2V0IGlzUnRsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5pMThuLmRpcmVjdGlvbiA9PT0gXCJydGxcIjtcbiAgfVxufVxuY2xhc3MgYiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsLCB0aGlzLnNlbGVjdGlvbiA9IG51bGwsIHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSA9IG51bGwsIHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgPSAhMSwgdGhpcy5jb21tYW5kQmFja2dyb3VuZCA9IFwiYmFja0NvbG9yXCIsIHRoaXMuY29tbWFuZFJlbW92ZUZvcm1hdCA9IFwicmVtb3ZlRm9ybWF0XCI7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvciBzdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge3tlZGl0b3JXcmFwcGVyOiBzdHJpbmcsIGVkaXRvclpvbmU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yV3JhcHBlcjogXCJjb2RleC1lZGl0b3JcIixcbiAgICAgIGVkaXRvclpvbmU6IFwiY29kZXgtZWRpdG9yX19yZWRhY3RvclwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCBhbmNob3JcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9TZWxlY3Rpb24vYW5jaG9yTm9kZX1cbiAgICpcbiAgICogQHJldHVybnMge05vZGV8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgYW5jaG9yTm9kZSgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBlID8gZS5hbmNob3JOb2RlIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCBhbmNob3IgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JFbGVtZW50KCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdCA9IGUuYW5jaG9yTm9kZTtcbiAgICByZXR1cm4gdCA/IGQuaXNFbGVtZW50KHQpID8gdCA6IHQucGFyZW50RWxlbWVudCA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0aW9uIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIGFuY2hvciBub2RlXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvU2VsZWN0aW9uL2FuY2hvck9mZnNldH1cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JPZmZzZXQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSA/IGUuYW5jaG9yT2Zmc2V0IDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogSXMgY3VycmVudCBzZWxlY3Rpb24gcmFuZ2UgY29sbGFwc2VkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzQ29sbGFwc2VkKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGUgPyBlLmlzQ29sbGFwc2VkIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgY3VycmVudCBzZWxlY3Rpb24gaWYgaXQgaXMgYXQgRWRpdG9yJ3Mgem9uZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNBdEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGlvbkF0RWRpdG9yKGIuZ2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgc2VsZWN0aW9uIGlzIGF0IEVkaXRvcidzIHpvbmVcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIFNlbGVjdGlvbiBvYmplY3QgdG8gY2hlY2tcbiAgICovXG4gIHN0YXRpYyBpc1NlbGVjdGlvbkF0RWRpdG9yKGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IHQgPSBlLmFuY2hvck5vZGUgfHwgZS5mb2N1c05vZGU7XG4gICAgdCAmJiB0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiAodCA9IHQucGFyZW50Tm9kZSk7XG4gICAgbGV0IG8gPSBudWxsO1xuICAgIHJldHVybiB0ICYmIHQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIChvID0gdC5jbG9zZXN0KGAuJHtiLkNTUy5lZGl0b3Jab25lfWApKSwgbyA/IG8ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCByYW5nZSBhdCBFZGl0b3Igem9uZVxuICAgKlxuICAgKiBAcGFyYW0gcmFuZ2UgLSByYW5nZSB0byBjaGVja1xuICAgKi9cbiAgc3RhdGljIGlzUmFuZ2VBdEVkaXRvcihlKSB7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gZS5zdGFydENvbnRhaW5lcjtcbiAgICB0ICYmIHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmICh0ID0gdC5wYXJlbnROb2RlKTtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgcmV0dXJuIHQgJiYgdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKG8gPSB0LmNsb3Nlc3QoYC4ke2IuQ1NTLmVkaXRvclpvbmV9YCkpLCBvID8gby5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgOiAhMTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kcyByZXR1cm4gYm9vbGVhbiB0aGF0IHRydWUgaWYgc2VsZWN0aW9uIGV4aXN0cyBvbiB0aGUgcGFnZVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1NlbGVjdGlvbkV4aXN0cygpIHtcbiAgICByZXR1cm4gISFiLmdldCgpLmFuY2hvck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UmFuZ2V8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VGcm9tU2VsZWN0aW9uKHRoaXMuZ2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJhbmdlIGZyb20gcGFzc2VkIFNlbGVjdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIFNlbGVjdGlvbiBvYmplY3QgdG8gZ2V0IFJhbmdlIGZyb21cbiAgICovXG4gIHN0YXRpYyBnZXRSYW5nZUZyb21TZWxlY3Rpb24oZSkge1xuICAgIHJldHVybiBlICYmIGUucmFuZ2VDb3VudCA/IGUuZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgcG9zaXRpb24gYW5kIHNpemUgb2Ygc2VsZWN0ZWQgdGV4dFxuICAgKlxuICAgKiBAcmV0dXJucyB7RE9NUmVjdCB8IENsaWVudFJlY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHJlY3QoKSB7XG4gICAgbGV0IGUgPSBkb2N1bWVudC5zZWxlY3Rpb24sIHQsIG8gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBpZiAoZSAmJiBlLnR5cGUgIT09IFwiQ29udHJvbFwiKVxuICAgICAgcmV0dXJuIGUgPSBlLCB0ID0gZS5jcmVhdGVSYW5nZSgpLCBvLnggPSB0LmJvdW5kaW5nTGVmdCwgby55ID0gdC5ib3VuZGluZ1RvcCwgby53aWR0aCA9IHQuYm91bmRpbmdXaWR0aCwgby5oZWlnaHQgPSB0LmJvdW5kaW5nSGVpZ2h0LCBvO1xuICAgIGlmICghd2luZG93LmdldFNlbGVjdGlvbilcbiAgICAgIHJldHVybiBTKFwiTWV0aG9kIHdpbmRvdy5nZXRTZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZFwiLCBcIndhcm5cIiksIG87XG4gICAgaWYgKGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIGUucmFuZ2VDb3VudCA9PT0gbnVsbCB8fCBpc05hTihlLnJhbmdlQ291bnQpKVxuICAgICAgcmV0dXJuIFMoXCJNZXRob2QgU2VsZWN0aW9uVXRpbHMucmFuZ2VDb3VudCBpcyBub3Qgc3VwcG9ydGVkXCIsIFwid2FyblwiKSwgbztcbiAgICBpZiAoZS5yYW5nZUNvdW50ID09PSAwKVxuICAgICAgcmV0dXJuIG87XG4gICAgaWYgKHQgPSBlLmdldFJhbmdlQXQoMCkuY2xvbmVSYW5nZSgpLCB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAobyA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLCBvLnggPT09IDAgJiYgby55ID09PSAwKSB7XG4gICAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBpZiAoaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgaS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIuKAi1wiKSksIHQuaW5zZXJ0Tm9kZShpKSwgbyA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHMgPSBpLnBhcmVudE5vZGU7XG4gICAgICAgIHMucmVtb3ZlQ2hpbGQoaSksIHMubm9ybWFsaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHQgYXMgU3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRTZWxlY3Rpb24gPyB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKSA6IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2luZG93IFNlbGVjdGlvblV0aWxzXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvV2luZG93L2dldFNlbGVjdGlvbn1cbiAgICpcbiAgICogQHJldHVybnMge1NlbGVjdGlvbn1cbiAgICovXG4gIHN0YXRpYyBnZXQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGZvY3VzIHRvIGNvbnRlbnRlZGl0YWJsZSBvciBuYXRpdmUgaW5wdXQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgdG8gc2V0IGZvY3VzXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBvZmZzZXQgb2YgY3Vyc29yXG4gICAqL1xuICBzdGF0aWMgc2V0Q3Vyc29yKGUsIHQgPSAwKSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIGkgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGQuaXNOYXRpdmVJbnB1dChlKSA/IGQuY2FuU2V0Q2FyZXQoZSkgPyAoZS5mb2N1cygpLCBlLnNlbGVjdGlvblN0YXJ0ID0gZS5zZWxlY3Rpb25FbmQgPSB0LCBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSA6IHZvaWQgMCA6IChvLnNldFN0YXJ0KGUsIHQpLCBvLnNldEVuZChlLCB0KSwgaS5yZW1vdmVBbGxSYW5nZXMoKSwgaS5hZGRSYW5nZShvKSwgby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGN1cnJlbnQgcmFuZ2UgZXhpc3RzIGFuZCBiZWxvbmdzIHRvIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gd2hlcmUgcmFuZ2Ugc2hvdWxkIGJlXG4gICAqL1xuICBzdGF0aWMgaXNSYW5nZUluc2lkZUNvbnRhaW5lcihlKSB7XG4gICAgY29uc3QgdCA9IGIucmFuZ2U7XG4gICAgcmV0dXJuIHQgPT09IG51bGwgPyAhMSA6IGUuY29udGFpbnModC5zdGFydENvbnRhaW5lcik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZmFrZSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgcmFuZ2VcbiAgICovXG4gIHN0YXRpYyBhZGRGYWtlQ3Vyc29yKCkge1xuICAgIGNvbnN0IGUgPSBiLnJhbmdlO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJzcGFuXCIsIFwiY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKTtcbiAgICB0LmRhdGFzZXQubXV0YXRpb25GcmVlID0gXCJ0cnVlXCIsIGUuY29sbGFwc2UoKSwgZS5pbnNlcnROb2RlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgZWxlbWVudCBjb250YWlucyBhIGZha2UgY3Vyc29yXG4gICAqXG4gICAqIEBwYXJhbSBlbCAtIHdoZXJlIHRvIGNoZWNrXG4gICAqL1xuICBzdGF0aWMgaXNGYWtlQ3Vyc29ySW5zaWRlQ29udGFpbmVyKGUpIHtcbiAgICByZXR1cm4gZC5maW5kKGUsIFwiLmNvZGV4LWVkaXRvcl9fZmFrZS1jdXJzb3JcIikgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZmFrZSBjdXJzb3IgZnJvbSBhIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gY29udGFpbmVyIHRvIGxvb2sgZm9yXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRmFrZUN1cnNvcihlID0gZG9jdW1lbnQuYm9keSkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoZSwgXCIuY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKTtcbiAgICB0ICYmIHQucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZmFrZSBiYWNrZ3JvdW5kXG4gICAqL1xuICByZW1vdmVGYWtlQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkICYmICh0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkID0gITEsIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZFJlbW92ZUZvcm1hdCkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGZha2UgYmFja2dyb3VuZFxuICAgKi9cbiAgc2V0RmFrZUJhY2tncm91bmQoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kQmFja2dyb3VuZCwgITEsIFwiI2E4ZDZmZlwiKSwgdGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBTYXZlIFNlbGVjdGlvblV0aWxzJ3MgcmFuZ2VcbiAgICovXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gYi5yYW5nZTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZSBzYXZlZCBTZWxlY3Rpb25VdGlscydzIHJhbmdlXG4gICAqL1xuICByZXN0b3JlKCkge1xuICAgIGlmICghdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgZS5yZW1vdmVBbGxSYW5nZXMoKSwgZS5hZGRSYW5nZSh0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgc2F2ZWQgc2VsZWN0aW9uXG4gICAqL1xuICBjbGVhclNhdmVkKCkge1xuICAgIHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxhcHNlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqL1xuICBjb2xsYXBzZVRvRW5kKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHQgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHQuc2VsZWN0Tm9kZUNvbnRlbnRzKGUuZm9jdXNOb2RlKSwgdC5jb2xsYXBzZSghMSksIGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodCk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIGFoZWFkIHRvIGZpbmQgcGFzc2VkIHRhZyBmcm9tIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnTmFtZSAgICAgICAtIHRhZyB0byBmb3VuZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtjbGFzc05hbWVdICAgLSB0YWcncyBjbGFzcyBuYW1lXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3NlYXJjaERlcHRoXSAtIGNvdW50IG9mIHRhZ3MgdGhhdCBjYW4gYmUgaW5jbHVkZWQuIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZmluZFBhcmVudFRhZyhlLCB0LCBvID0gMTApIHtcbiAgICBjb25zdCBpID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGxldCBzID0gbnVsbDtcbiAgICByZXR1cm4gIWkgfHwgIWkuYW5jaG9yTm9kZSB8fCAhaS5mb2N1c05vZGUgPyBudWxsIDogKFtcbiAgICAgIC8qKiB0aGUgTm9kZSBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIGJlZ2lucyAqL1xuICAgICAgaS5hbmNob3JOb2RlLFxuICAgICAgLyoqIHRoZSBOb2RlIGluIHdoaWNoIHRoZSBzZWxlY3Rpb24gZW5kcyAqL1xuICAgICAgaS5mb2N1c05vZGVcbiAgICBdLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGxldCBsID0gbztcbiAgICAgIGZvciAoOyBsID4gMCAmJiBhLnBhcmVudE5vZGUgJiYgIShhLnRhZ05hbWUgPT09IGUgJiYgKHMgPSBhLCB0ICYmIGEuY2xhc3NMaXN0ICYmICFhLmNsYXNzTGlzdC5jb250YWlucyh0KSAmJiAocyA9IG51bGwpLCBzKSk7IClcbiAgICAgICAgYSA9IGEucGFyZW50Tm9kZSwgbC0tO1xuICAgIH0pLCBzKTtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kcyBzZWxlY3Rpb24gcmFuZ2UgdG8gdGhlIHBhc3NlZCBwYXJlbnQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB3aGljaCBjb250ZW50cyBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICovXG4gIGV4cGFuZFRvVGFnKGUpIHtcbiAgICBjb25zdCB0ID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHQucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgby5zZWxlY3ROb2RlQ29udGVudHMoZSksIHQuYWRkUmFuZ2Uobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpKG4sIGUpIHtcbiAgY29uc3QgeyB0eXBlOiB0LCB0YXJnZXQ6IG8sIGFkZGVkTm9kZXM6IGksIHJlbW92ZWROb2RlczogcyB9ID0gbjtcbiAgcmV0dXJuIG4udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgbi5hdHRyaWJ1dGVOYW1lID09PSBcImRhdGEtZW1wdHlcIiA/ICExIDogISEoZS5jb250YWlucyhvKSB8fCB0ID09PSBcImNoaWxkTGlzdFwiICYmIChBcnJheS5mcm9tKGkpLnNvbWUoKGwpID0+IGwgPT09IGUpIHx8IEFycmF5LmZyb20ocykuc29tZSgobCkgPT4gbCA9PT0gZSkpKTtcbn1cbmNvbnN0IGZ0ID0gXCJyZWRhY3RvciBkb20gY2hhbmdlZFwiLCAkbyA9IFwiYmxvY2sgY2hhbmdlZFwiLCB6byA9IFwiZmFrZSBjdXJzb3IgaXMgYWJvdXQgdG8gYmUgdG9nZ2xlZFwiLCBVbyA9IFwiZmFrZSBjdXJzb3IgaGF2ZSBiZWVuIHNldFwiLCBUZSA9IFwiZWRpdG9yIG1vYmlsZSBsYXlvdXQgdG9nZ2xlZFwiO1xuZnVuY3Rpb24gZ3QobiwgZSkge1xuICBpZiAoIW4uY29udmVyc2lvbkNvbmZpZylcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHQgPSBuLmNvbnZlcnNpb25Db25maWdbZV07XG4gIHJldHVybiBBKHQpIHx8IHRlKHQpO1xufVxuZnVuY3Rpb24gSGUobiwgZSkge1xuICByZXR1cm4gZ3Qobi50b29sLCBlKTtcbn1cbmZ1bmN0aW9uIFdvKG4sIGUpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG4pLnNvbWUoKFt0LCBvXSkgPT4gZVt0XSAmJiByaShlW3RdLCBvKSk7XG59XG5hc3luYyBmdW5jdGlvbiBZbyhuLCBlKSB7XG4gIGNvbnN0IG8gPSAoYXdhaXQgbi5zYXZlKCkpLmRhdGEsIGkgPSBlLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gbi5uYW1lKTtcbiAgcmV0dXJuIGkgIT09IHZvaWQgMCAmJiAhZ3QoaSwgXCJleHBvcnRcIikgPyBbXSA6IGUucmVkdWNlKChzLCByKSA9PiB7XG4gICAgaWYgKCFndChyLCBcImltcG9ydFwiKSB8fCByLnRvb2xib3ggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBzO1xuICAgIGNvbnN0IGEgPSByLnRvb2xib3guZmlsdGVyKChsKSA9PiB7XG4gICAgICBpZiAoVihsKSB8fCBsLmljb24gPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGwuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChXbyhsLmRhdGEsIG8pKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0gZWxzZSBpZiAoci5uYW1lID09PSBuLm5hbWUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9KTtcbiAgICByZXR1cm4gcy5wdXNoKHtcbiAgICAgIC4uLnIsXG4gICAgICB0b29sYm94OiBhXG4gICAgfSksIHM7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHhvKG4sIGUpIHtcbiAgcmV0dXJuIG4ubWVyZ2VhYmxlID8gbi5uYW1lID09PSBlLm5hbWUgPyAhMCA6IEhlKGUsIFwiZXhwb3J0XCIpICYmIEhlKG4sIFwiaW1wb3J0XCIpIDogITE7XG59XG5mdW5jdGlvbiBmaShuLCBlKSB7XG4gIGNvbnN0IHQgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmV4cG9ydDtcbiAgcmV0dXJuIEEodCkgPyB0KG4pIDogdGUodCkgPyBuW3RdIDogKHQgIT09IHZvaWQgMCAmJiBTKFwiQ29udmVyc2lvbiDCq2V4cG9ydMK7IHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24uIFN0cmluZyBtZWFucyBrZXkgb2Ygc2F2ZWQgZGF0YSBvYmplY3QgdG8gZXhwb3J0LiBGdW5jdGlvbiBzaG91bGQgZXhwb3J0IHByb2Nlc3NlZCBzdHJpbmcgdG8gZXhwb3J0LlwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiBCbyhuLCBlLCB0KSB7XG4gIGNvbnN0IG8gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmltcG9ydDtcbiAgcmV0dXJuIEEobykgPyBvKG4sIHQpIDogdGUobykgPyB7XG4gICAgW29dOiBuXG4gIH0gOiAobyAhPT0gdm9pZCAwICYmIFMoXCJDb252ZXJzaW9uIMKraW1wb3J0wrsgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvbi4gU3RyaW5nIG1lYW5zIGtleSBvZiB0b29sIGRhdGEgdG8gaW1wb3J0LiBGdW5jdGlvbiBhY2NlcHRzIGEgaW1wb3J0ZWQgc3RyaW5nIGFuZCByZXR1cm4gY29tcG9zZWQgdG9vbCBkYXRhLlwiKSwge30pO1xufVxudmFyIF8gPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5EZWZhdWx0ID0gXCJkZWZhdWx0XCIsIG4uU2VwYXJhdG9yID0gXCJzZXBhcmF0b3JcIiwgbi5IdG1sID0gXCJodG1sXCIsIG4pKShfIHx8IHt9KSwgZWUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5BUFBFTkRfQ0FMTEJBQ0sgPSBcImFwcGVuZENhbGxiYWNrXCIsIG4uUkVOREVSRUQgPSBcInJlbmRlcmVkXCIsIG4uTU9WRUQgPSBcIm1vdmVkXCIsIG4uVVBEQVRFRCA9IFwidXBkYXRlZFwiLCBuLlJFTU9WRUQgPSBcInJlbW92ZWRcIiwgbi5PTl9QQVNURSA9IFwib25QYXN0ZVwiLCBuKSkoZWUgfHwge30pO1xuY2xhc3MgUiBleHRlbmRzIE9lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYmxvY2sgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0gW29wdGlvbnMuaWRdIC0gYmxvY2sncyBpZC4gV2lsbCBiZSBnZW5lcmF0ZWQgaWYgb21pdHRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRvb2wncyBpbml0aWFsIGRhdGFcbiAgICogQHBhcmFtIG9wdGlvbnMudG9vbCDigJQgYmxvY2sncyB0b29sXG4gICAqIEBwYXJhbSBvcHRpb25zLmFwaSAtIEVkaXRvciBBUEkgbW9kdWxlIGZvciBwYXNzIGl0IHRvIHRoZSBCbG9jayBUdW5lc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFkT25seSAtIFJlYWQtT25seSBmbGFnXG4gICAqIEBwYXJhbSBbZXZlbnRCdXNdIC0gRWRpdG9yIGNvbW1vbiBldmVudCBidXMuIEFsbG93cyB0byBzdWJzY3JpYmUgb24gc29tZSBFZGl0b3IgZXZlbnRzLiBDb3VsZCBiZSBvbWl0dGVkIHdoZW4gXCJ2aXJ0dWFsXCIgQmxvY2sgaXMgY3JlYXRlZC4gU2VlIEJsb2Nrc0FQSUBjb21wb3NlQmxvY2tEYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGlkOiBlID0gbmkoKSxcbiAgICBkYXRhOiB0LFxuICAgIHRvb2w6IG8sXG4gICAgcmVhZE9ubHk6IGksXG4gICAgdHVuZXNEYXRhOiBzXG4gIH0sIHIpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNhY2hlZElucHV0cyA9IFtdLCB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQgPSBudWxsLCB0aGlzLnR1bmVzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhID0ge30sIHRoaXMuaW5wdXRJbmRleCA9IDAsIHRoaXMuZWRpdG9yRXZlbnRCdXMgPSBudWxsLCB0aGlzLmhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgdGhpcy5kcm9wSW5wdXRzQ2FjaGUoKSwgdGhpcy51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCB0aGlzLmRpZE11dGF0ZWQgPSAoYSA9IHZvaWQgMCkgPT4ge1xuICAgICAgY29uc3QgbCA9IGEgPT09IHZvaWQgMCwgYyA9IGEgaW5zdGFuY2VvZiBJbnB1dEV2ZW50O1xuICAgICAgIWwgJiYgIWMgJiYgdGhpcy5kZXRlY3RUb29sUm9vdENoYW5nZShhKTtcbiAgICAgIGxldCB1O1xuICAgICAgbCB8fCBjID8gdSA9ICEwIDogdSA9ICEoYS5sZW5ndGggPiAwICYmIGEuZXZlcnkoKHApID0+IHtcbiAgICAgICAgY29uc3QgeyBhZGRlZE5vZGVzOiBnLCByZW1vdmVkTm9kZXM6IGYsIHRhcmdldDogdiB9ID0gcDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAuLi5BcnJheS5mcm9tKGcpLFxuICAgICAgICAgIC4uLkFycmF5LmZyb20oZiksXG4gICAgICAgICAgdlxuICAgICAgICBdLnNvbWUoKFQpID0+IChkLmlzRWxlbWVudChUKSB8fCAoVCA9IFQucGFyZW50RWxlbWVudCksIFQgJiYgVC5jbG9zZXN0KCdbZGF0YS1tdXRhdGlvbi1mcmVlPVwidHJ1ZVwiXScpICE9PSBudWxsKSk7XG4gICAgICB9KSksIHUgJiYgKHRoaXMuZHJvcElucHV0c0NhY2hlKCksIHRoaXMudXBkYXRlQ3VycmVudElucHV0KCksIHRoaXMudG9nZ2xlSW5wdXRzRW1wdHlNYXJrKCksIHRoaXMuY2FsbChcbiAgICAgICAgXCJ1cGRhdGVkXCJcbiAgICAgICAgLyogVVBEQVRFRCAqL1xuICAgICAgKSwgdGhpcy5lbWl0KFwiZGlkTXV0YXRlZFwiLCB0aGlzKSk7XG4gICAgfSwgdGhpcy5uYW1lID0gby5uYW1lLCB0aGlzLmlkID0gZSwgdGhpcy5zZXR0aW5ncyA9IG8uc2V0dGluZ3MsIHRoaXMuY29uZmlnID0gby5zZXR0aW5ncy5jb25maWcgfHwge30sIHRoaXMuZWRpdG9yRXZlbnRCdXMgPSByIHx8IG51bGwsIHRoaXMuYmxvY2tBUEkgPSBuZXcgSih0aGlzKSwgdGhpcy50b29sID0gbywgdGhpcy50b29sSW5zdGFuY2UgPSBvLmNyZWF0ZSh0LCB0aGlzLmJsb2NrQVBJLCBpKSwgdGhpcy50dW5lcyA9IG8udHVuZXMsIHRoaXMuY29tcG9zZVR1bmVzKHMpLCB0aGlzLmhvbGRlciA9IHRoaXMuY29tcG9zZSgpLCB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLndhdGNoQmxvY2tNdXRhdGlvbnMoKSwgdGhpcy5hZGRJbnB1dEV2ZW50cygpLCB0aGlzLnRvZ2dsZUlucHV0c0VtcHR5TWFyaygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3NlcyBmb3IgdGhlIEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHt7d3JhcHBlcjogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyYXBwZXI6IFwiY2UtYmxvY2tcIixcbiAgICAgIHdyYXBwZXJTdHJldGNoZWQ6IFwiY2UtYmxvY2stLXN0cmV0Y2hlZFwiLFxuICAgICAgY29udGVudDogXCJjZS1ibG9ja19fY29udGVudFwiLFxuICAgICAgc2VsZWN0ZWQ6IFwiY2UtYmxvY2stLXNlbGVjdGVkXCIsXG4gICAgICBkcm9wVGFyZ2V0OiBcImNlLWJsb2NrLS1kcm9wLXRhcmdldFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhbmQgcmV0dXJuIGFsbCBlZGl0YWJsZSBlbGVtZW50cyAoY29udGVudGVkaXRhYmxlIGFuZCBuYXRpdmUgaW5wdXRzKSBpbiB0aGUgVG9vbCBIVE1MXG4gICAqL1xuICBnZXQgaW5wdXRzKCkge1xuICAgIGlmICh0aGlzLmNhY2hlZElucHV0cy5sZW5ndGggIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRJbnB1dHM7XG4gICAgY29uc3QgZSA9IGQuZmluZEFsbElucHV0cyh0aGlzLmhvbGRlcik7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmRleCA+IGUubGVuZ3RoIC0gMSAmJiAodGhpcy5pbnB1dEluZGV4ID0gZS5sZW5ndGggLSAxKSwgdGhpcy5jYWNoZWRJbnB1dHMgPSBlLCBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gY3VycmVudCBUb29sYHMgaW5wdXRcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU2V0IGlucHV0IGluZGV4IHRvIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEhUTUwgRWxlbWVudCB0byBzZXQgYXMgY3VycmVudCBpbnB1dFxuICAgKi9cbiAgc2V0IGN1cnJlbnRJbnB1dChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXRzLmZpbmRJbmRleCgobykgPT4gbyA9PT0gZSB8fCBvLmNvbnRhaW5zKGUpKTtcbiAgICB0ICE9PSAtMSAmJiAodGhpcy5pbnB1dEluZGV4ID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCBUb29sYHMgaW5wdXRcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IGZpcnN0SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgVG9vbGBzIGlucHV0XG4gICAqIElmIEJsb2NrIGRvZXNuJ3QgY29udGFpbiBpbnB1dHMsIHJldHVybiB1bmRlZmluZWRcbiAgICovXG4gIGdldCBsYXN0SW5wdXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXRzO1xuICAgIHJldHVybiBlW2UubGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBuZXh0IFRvb2xgcyBpbnB1dCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKiBJZiBCbG9jayBkb2Vzbid0IGNvbnRhaW4gaW5wdXRzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgbmV4dElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0c1t0aGlzLmlucHV0SW5kZXggKyAxXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHByZXZpb3VzIFRvb2xgcyBpbnB1dCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKiBJZiBCbG9jayBkb2Vzbid0IGNvbnRhaW4gaW5wdXRzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgcHJldmlvdXNJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4IC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jaydzIEpTT04gZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZSgpLnRoZW4oKGUpID0+IGUgJiYgIVYoZS5kYXRhKSA/IGUuZGF0YSA6IHt9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0b29sJ3Mgc2FuaXRpemVyIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2wuc2FuaXRpemVDb25maWc7XG4gIH1cbiAgLyoqXG4gICAqIGlzIGJsb2NrIG1lcmdlYWJsZVxuICAgKiBXZSBwbHVnaW4gaGF2ZSBtZXJnZSBmdW5jdGlvbiB0aGVuIHdlIGNhbGwgaXQgbWVyZ2VhYmxlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IG1lcmdlYWJsZSgpIHtcbiAgICByZXR1cm4gQSh0aGlzLnRvb2xJbnN0YW5jZS5tZXJnZSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIEJsb2NrIGNvbnRhaW5zIGlucHV0cywgaXQgaXMgZm9jdXNhYmxlXG4gICAqL1xuICBnZXQgZm9jdXNhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0cy5sZW5ndGggIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGJsb2NrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICBjb25zdCBlID0gZC5pc0VtcHR5KHRoaXMucGx1Z2luc0NvbnRlbnQsIFwiL1wiKSwgdCA9ICF0aGlzLmhhc01lZGlhO1xuICAgIHJldHVybiBlICYmIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJsb2NrIGhhcyBhIG1lZGlhIGNvbnRlbnQgc3VjaCBhcyBpbWFnZXMsIGlmcmFtZSBhbmQgb3RoZXJcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaGFzTWVkaWEoKSB7XG4gICAgY29uc3QgZSA9IFtcbiAgICAgIFwiaW1nXCIsXG4gICAgICBcImlmcmFtZVwiLFxuICAgICAgXCJ2aWRlb1wiLFxuICAgICAgXCJhdWRpb1wiLFxuICAgICAgXCJzb3VyY2VcIixcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIFwidGV4dGFyZWFcIixcbiAgICAgIFwidHdpdHRlcndpZGdldFwiXG4gICAgXTtcbiAgICByZXR1cm4gISF0aGlzLmhvbGRlci5xdWVyeVNlbGVjdG9yKGUuam9pbihcIixcIikpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgc3RhdGVcbiAgICogV2UgZG9uJ3QgbmVlZCB0byBtYXJrIEJsb2NrIGFzIFNlbGVjdGVkIHdoZW4gaXQgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyB0byBzZWxlY3QsICdmYWxzZScgdG8gcmVtb3ZlIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IHNlbGVjdGVkKGUpIHtcbiAgICB2YXIgaSwgcztcbiAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QudG9nZ2xlKFIuQ1NTLnNlbGVjdGVkLCBlKTtcbiAgICBjb25zdCB0ID0gZSA9PT0gITAgJiYgYi5pc1JhbmdlSW5zaWRlQ29udGFpbmVyKHRoaXMuaG9sZGVyKSwgbyA9IGUgPT09ICExICYmIGIuaXNGYWtlQ3Vyc29ySW5zaWRlQ29udGFpbmVyKHRoaXMuaG9sZGVyKTtcbiAgICAodCB8fCBvKSAmJiAoKGkgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IGkuZW1pdCh6bywgeyBzdGF0ZTogZSB9KSwgdCA/IGIuYWRkRmFrZUN1cnNvcigpIDogYi5yZW1vdmVGYWtlQ3Vyc29yKHRoaXMuaG9sZGVyKSwgKHMgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IHMuZW1pdChVbywgeyBzdGF0ZTogZSB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVHJ1ZSBpZiBpdCBpcyBTZWxlY3RlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFIuQ1NTLnNlbGVjdGVkKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHN0cmV0Y2hlZCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gJ3RydWUnIHRvIGVuYWJsZSwgJ2ZhbHNlJyB0byBkaXNhYmxlIHN0cmV0Y2hlZCBzdGF0ZVxuICAgKi9cbiAgc2V0IHN0cmV0Y2hlZChlKSB7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShSLkNTUy53cmFwcGVyU3RyZXRjaGVkLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEJsb2NrJ3Mgc3RyZXRjaGVkIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHN0cmV0Y2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFIuQ1NTLndyYXBwZXJTdHJldGNoZWQpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgZHJvcCB0YXJnZXQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyBpZiBibG9jayBpcyBkcm9wIHRhcmdldCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBzZXQgZHJvcFRhcmdldChlKSB7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShSLkNTUy5kcm9wVGFyZ2V0LCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBQbHVnaW5zIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IHBsdWdpbnNDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIFRvb2wncyBtZXRob2RcbiAgICpcbiAgICogTWV0aG9kIGNoZWNrcyB0b29sIHByb3BlcnR5IHtNZXRob2ROYW1lfS4gRmlyZXMgbWV0aG9kIHdpdGggcGFzc2VzIHBhcmFtcyBJZiBpdCBpcyBpbnN0YW5jZSBvZiBGdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIG1ldGhvZCB0byBjYWxsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBtZXRob2QgYXJndW1lbnRcbiAgICovXG4gIGNhbGwoZSwgdCkge1xuICAgIGlmIChBKHRoaXMudG9vbEluc3RhbmNlW2VdKSkge1xuICAgICAgZSA9PT0gXCJhcHBlbmRDYWxsYmFja1wiICYmIFMoXG4gICAgICAgIFwiYGFwcGVuZENhbGxiYWNrYCBob29rIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBVc2UgYHJlbmRlcmVkYCBob29rIGluc3RlYWRcIixcbiAgICAgICAgXCJ3YXJuXCJcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnRvb2xJbnN0YW5jZVtlXS5jYWxsKHRoaXMudG9vbEluc3RhbmNlLCB0KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgUyhgRXJyb3IgZHVyaW5nICcke2V9JyBjYWxsOiAke28ubWVzc2FnZX1gLCBcImVycm9yXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBwbHVnaW5zIG1lcmdlIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IGRhdGEgLSBkYXRhIHRvIG1lcmdlXG4gICAqL1xuICBhc3luYyBtZXJnZVdpdGgoZSkge1xuICAgIGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLm1lcmdlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0cyBkYXRhIGZyb20gQmxvY2tcbiAgICogR3JvdXBzIFRvb2wncyBzYXZlIHByb2Nlc3NpbmcgdGltZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy50b29sSW5zdGFuY2Uuc2F2ZSh0aGlzLnBsdWdpbnNDb250ZW50KSwgdCA9IHRoaXMudW5hdmFpbGFibGVUdW5lc0RhdGE7XG4gICAgW1xuICAgICAgLi4udGhpcy50dW5lc0luc3RhbmNlcy5lbnRyaWVzKCksXG4gICAgICAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy5lbnRyaWVzKClcbiAgICBdLmZvckVhY2goKFtzLCByXSkgPT4ge1xuICAgICAgaWYgKEEoci5zYXZlKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0W3NdID0gci5zYXZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgICAgICBTKGBUdW5lICR7ci5jb25zdHJ1Y3Rvci5uYW1lfSBzYXZlIG1ldGhvZCB0aHJvd3MgYW4gRXJyb3IgJW9gLCBcIndhcm5cIiwgYSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGxldCBpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZSkudGhlbigocykgPT4gKGkgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgdG9vbDogdGhpcy5uYW1lLFxuICAgICAgZGF0YTogcyxcbiAgICAgIHR1bmVzOiB0LFxuICAgICAgdGltZTogaSAtIG9cbiAgICB9KSkuY2F0Y2goKHMpID0+IHtcbiAgICAgIFMoYFNhdmluZyBwcm9jZXNzIGZvciAke3RoaXMubmFtZX0gdG9vbCBmYWlsZWQgZHVlIHRvIHRoZSAke3N9YCwgXCJsb2dcIiwgXCJyZWRcIik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZXMgVG9vbCdzIHZhbGlkYXRpb24gbWV0aG9kIHRvIGNoZWNrIHRoZSBjb3JyZWN0bmVzcyBvZiBvdXRwdXQgZGF0YVxuICAgKiBUb29sJ3MgdmFsaWRhdGlvbiBtZXRob2QgaXMgb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZXR1cm5zIHRydWV8ZmFsc2Ugd2hldGhlciBkYXRhIHBhc3NlZCB0aGUgdmFsaWRhdGlvbiBvciBub3RcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdmFsaWRcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKGUpIHtcbiAgICBsZXQgdCA9ICEwO1xuICAgIHJldHVybiB0aGlzLnRvb2xJbnN0YW5jZS52YWxpZGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmICh0ID0gYXdhaXQgdGhpcy50b29sSW5zdGFuY2UudmFsaWRhdGUoZSkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRhdGEgdG8gcmVuZGVyIGluIEJsb2NrIFR1bmVzIG1lbnUuXG4gICAqIFNwbGl0cyBibG9jayB0dW5lcyBpbnRvIDIgZ3JvdXBzOiBibG9jayBzcGVjaWZpYyB0dW5lcyBhbmQgY29tbW9uIHR1bmVzXG4gICAqL1xuICBnZXRUdW5lcygpIHtcbiAgICBjb25zdCBlID0gW10sIHQgPSBbXSwgbyA9IHR5cGVvZiB0aGlzLnRvb2xJbnN0YW5jZS5yZW5kZXJTZXR0aW5ncyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnRvb2xJbnN0YW5jZS5yZW5kZXJTZXR0aW5ncygpIDogW107XG4gICAgcmV0dXJuIGQuaXNFbGVtZW50KG8pID8gZS5wdXNoKHtcbiAgICAgIHR5cGU6IF8uSHRtbCxcbiAgICAgIGVsZW1lbnQ6IG9cbiAgICB9KSA6IEFycmF5LmlzQXJyYXkobykgPyBlLnB1c2goLi4ubykgOiBlLnB1c2gobyksIFtcbiAgICAgIC4uLnRoaXMudHVuZXNJbnN0YW5jZXMudmFsdWVzKCksXG4gICAgICAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy52YWx1ZXMoKVxuICAgIF0ubWFwKChzKSA9PiBzLnJlbmRlcigpKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBkLmlzRWxlbWVudChzKSA/IHQucHVzaCh7XG4gICAgICAgIHR5cGU6IF8uSHRtbCxcbiAgICAgICAgZWxlbWVudDogc1xuICAgICAgfSkgOiBBcnJheS5pc0FycmF5KHMpID8gdC5wdXNoKC4uLnMpIDogdC5wdXNoKHMpO1xuICAgIH0pLCB7XG4gICAgICB0b29sVHVuZXM6IGUsXG4gICAgICBjb21tb25UdW5lczogdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBjdXJyZW50IGlucHV0IGluZGV4IHdpdGggc2VsZWN0aW9uIGFuY2hvciBub2RlXG4gICAqL1xuICB1cGRhdGVDdXJyZW50SW5wdXQoKSB7XG4gICAgdGhpcy5jdXJyZW50SW5wdXQgPSBkLmlzTmF0aXZlSW5wdXQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgfHwgIWIuYW5jaG9yTm9kZSA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBiLmFuY2hvck5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyB0byBzYXkgRWRpdG9yIHRoYXQgQmxvY2sgd2FzIGNoYW5nZWQuIFVzZWQgdG8gbWFudWFsbHkgdHJpZ2dlciBFZGl0b3IncyAnb25DaGFuZ2UnIGNhbGxiYWNrXG4gICAqIENhbiBiZSB1c2VmdWwgZm9yIGJsb2NrIGNoYW5nZXMgaW52aXNpYmxlIGZvciBlZGl0b3IgY29yZS5cbiAgICovXG4gIGRpc3BhdGNoQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlkTXV0YXRlZCgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIFRvb2wgaW5zdGFuY2UgZGVzdHJveSBtZXRob2RcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bndhdGNoQmxvY2tNdXRhdGlvbnMoKSwgdGhpcy5yZW1vdmVJbnB1dEV2ZW50cygpLCBzdXBlci5kZXN0cm95KCksIEEodGhpcy50b29sSW5zdGFuY2UuZGVzdHJveSkgJiYgdGhpcy50b29sSW5zdGFuY2UuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBUb29sIGNvdWxkIHNwZWNpZnkgc2V2ZXJhbCBlbnRyaWVzIHRvIGJlIGRpc3BsYXllZCBhdCB0aGUgVG9vbGJveCAoZm9yIGV4YW1wbGUsIFwiSGVhZGluZyAxXCIsIFwiSGVhZGluZyAyXCIsIFwiSGVhZGluZyAzXCIpXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVudHJ5IHRoYXQgaXMgcmVsYXRlZCB0byB0aGUgQmxvY2sgKGRlcGVuZGVkIG9uIHRoZSBCbG9jayBkYXRhKVxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZlVG9vbGJveEVudHJ5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnRvb2wudG9vbGJveDtcbiAgICBpZiAoZS5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9vbC50b29sYm94WzBdKTtcbiAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5kYXRhLCBvID0gZTtcbiAgICByZXR1cm4gbyA9PSBudWxsID8gdm9pZCAwIDogby5maW5kKChpKSA9PiBXbyhpLmRhdGEsIHQpKTtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0cyBCbG9jayBkYXRhIGFzIHN0cmluZyB1c2luZyBjb252ZXJzaW9uIGNvbmZpZ1xuICAgKi9cbiAgYXN5bmMgZXhwb3J0RGF0YUFzU3RyaW5nKCkge1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLmRhdGE7XG4gICAgcmV0dXJuIGZpKGUsIHRoaXMudG9vbC5jb252ZXJzaW9uQ29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogTWFrZSBkZWZhdWx0IEJsb2NrIHdyYXBwZXJzIGFuZCBwdXQgVG9vbGBzIGNvbnRlbnQgdGhlcmVcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgY29tcG9zZSgpIHtcbiAgICBjb25zdCBlID0gZC5tYWtlKFwiZGl2XCIsIFIuQ1NTLndyYXBwZXIpLCB0ID0gZC5tYWtlKFwiZGl2XCIsIFIuQ1NTLmNvbnRlbnQpLCBvID0gdGhpcy50b29sSW5zdGFuY2UucmVuZGVyKCk7XG4gICAgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN5XCIsIFwiYmxvY2std3JhcHBlclwiKSwgZS5kYXRhc2V0LmlkID0gdGhpcy5pZCwgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gbywgdC5hcHBlbmRDaGlsZCh0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQpO1xuICAgIGxldCBpID0gdDtcbiAgICByZXR1cm4gWy4uLnRoaXMudHVuZXNJbnN0YW5jZXMudmFsdWVzKCksIC4uLnRoaXMuZGVmYXVsdFR1bmVzSW5zdGFuY2VzLnZhbHVlcygpXS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBpZiAoQShzLndyYXApKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGkgPSBzLndyYXAoaSk7XG4gICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICBTKGBUdW5lICR7cy5jb25zdHJ1Y3Rvci5uYW1lfSB3cmFwIG1ldGhvZCB0aHJvd3MgYW4gRXJyb3IgJW9gLCBcIndhcm5cIiwgcik7XG4gICAgICAgIH1cbiAgICB9KSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbiAgfVxuICAvKipcbiAgICogSW5zdGFudGlhdGUgQmxvY2sgVHVuZXNcbiAgICpcbiAgICogQHBhcmFtIHR1bmVzRGF0YSAtIGN1cnJlbnQgQmxvY2sgdHVuZXMgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcG9zZVR1bmVzKGUpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMudHVuZXMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICh0LmlzSW50ZXJuYWwgPyB0aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcyA6IHRoaXMudHVuZXNJbnN0YW5jZXMpLnNldCh0Lm5hbWUsIHQuY3JlYXRlKGVbdC5uYW1lXSwgdGhpcy5ibG9ja0FQSSkpO1xuICAgIH0pLCBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbdCwgb10pID0+IHtcbiAgICAgIHRoaXMudHVuZXNJbnN0YW5jZXMuaGFzKHQpIHx8ICh0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhW3RdID0gbyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIHRvIGFsbCBpbnB1dHMgYW5kIGNvbnRlbnRlZGl0YWJsZVxuICAgKi9cbiAgYWRkSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5oYW5kbGVGb2N1cyksIGQuaXNOYXRpdmVJbnB1dChlKSAmJiBlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmRpZE11dGF0ZWQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZW1vdmVzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFsbCBpbnB1dHMgYW5kIGNvbnRlbnRlZGl0YWJsZVxuICAgKi9cbiAgcmVtb3ZlSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5oYW5kbGVGb2N1cyksIGQuaXNOYXRpdmVJbnB1dChlKSAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmRpZE11dGF0ZWQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gY29tbW9uIGVkaXRvciBEb20gQ2hhbmdlZCBldmVudCBhbmQgZGV0ZWN0IG11dGF0aW9ucyByZWxhdGVkIHRvIHRoZSAgQmxvY2tcbiAgICovXG4gIHdhdGNoQmxvY2tNdXRhdGlvbnMoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5yZWRhY3RvckRvbUNoYW5nZWRDYWxsYmFjayA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IG11dGF0aW9uczogbyB9ID0gdDtcbiAgICAgIG8uc29tZSgocykgPT4gcGkocywgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50KSkgJiYgdGhpcy5kaWRNdXRhdGVkKG8pO1xuICAgIH0sIChlID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBlLm9uKGZ0LCB0aGlzLnJlZGFjdG9yRG9tQ2hhbmdlZENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlZGFjdG9yIGRvbSBjaGFuZ2UgZXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHVud2F0Y2hCbG9ja011dGF0aW9ucygpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMuZWRpdG9yRXZlbnRCdXMpID09IG51bGwgfHwgZS5vZmYoZnQsIHRoaXMucmVkYWN0b3JEb21DaGFuZ2VkQ2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBTb21ldGltZXMgVG9vbCBjYW4gcmVwbGFjZSBvd24gbWFpbiBlbGVtZW50LCBmb3IgZXhhbXBsZSBIMiAtPiBINCBvciBVTCAtPiBPTFxuICAgKiBXZSBuZWVkIHRvIGRldGVjdCBzdWNoIGNoYW5nZXMgYW5kIHVwZGF0ZSBhIGxpbmsgdG8gdG9vbHMgbWFpbiBlbGVtZW50IHdpdGggdGhlIG5ldyBvbmVcbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9ucyAtIHJlY29yZHMgb2YgYmxvY2sgY29udGVudCBtdXRhdGlvbnNcbiAgICovXG4gIGRldGVjdFRvb2xSb290Q2hhbmdlKGUpIHtcbiAgICBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGlmIChBcnJheS5mcm9tKHQucmVtb3ZlZE5vZGVzKS5pbmNsdWRlcyh0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0LmFkZGVkTm9kZXNbdC5hZGRlZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQgPSBpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgaW5wdXRzIGNhY2hlZCB2YWx1ZVxuICAgKi9cbiAgZHJvcElucHV0c0NhY2hlKCkge1xuICAgIHRoaXMuY2FjaGVkSW5wdXRzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgaW5wdXRzIHdpdGggJ2RhdGEtZW1wdHknIGF0dHJpYnV0ZSB3aXRoIHRoZSBlbXB0eSBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlSW5wdXRzRW1wdHlNYXJrKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goRG8pO1xuICB9XG59XG5jbGFzcyBnaSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmluc2VydCA9IChlID0gdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLCB0ID0ge30sIG8gPSB7fSwgaSwgcywgciwgYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoe1xuICAgICAgICBpZDogYSxcbiAgICAgICAgdG9vbDogZSxcbiAgICAgICAgZGF0YTogdCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIG5lZWRUb0ZvY3VzOiBzLFxuICAgICAgICByZXBsYWNlOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgSihsKTtcbiAgICB9LCB0aGlzLmNvbXBvc2VCbG9ja0RhdGEgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMuZ2V0KGUpO1xuICAgICAgcmV0dXJuIG5ldyBSKHtcbiAgICAgICAgdG9vbDogdCxcbiAgICAgICAgYXBpOiB0aGlzLkVkaXRvci5BUEksXG4gICAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIHR1bmVzRGF0YToge31cbiAgICAgIH0pLmRhdGE7XG4gICAgfSwgdGhpcy51cGRhdGUgPSBhc3luYyAoZSwgdCwgbykgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGkgfSA9IHRoaXMuRWRpdG9yLCBzID0gaS5nZXRCbG9ja0J5SWQoZSk7XG4gICAgICBpZiAocyA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggaWQgXCIke2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICBjb25zdCByID0gYXdhaXQgaS51cGRhdGUocywgdCwgbyk7XG4gICAgICByZXR1cm4gbmV3IEoocik7XG4gICAgfSwgdGhpcy5jb252ZXJ0ID0gYXN5bmMgKGUsIHQsIG8pID0+IHtcbiAgICAgIHZhciBoLCBwO1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGksIFRvb2xzOiBzIH0gPSB0aGlzLkVkaXRvciwgciA9IGkuZ2V0QmxvY2tCeUlkKGUpO1xuICAgICAgaWYgKCFyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrIHdpdGggaWQgXCIke2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICBjb25zdCBhID0gcy5ibG9ja1Rvb2xzLmdldChyLm5hbWUpLCBsID0gcy5ibG9ja1Rvb2xzLmdldCh0KTtcbiAgICAgIGlmICghbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayBUb29sIHdpdGggdHlwZSBcIiR7dH1cIiBub3QgZm91bmRgKTtcbiAgICAgIGNvbnN0IGMgPSAoKGggPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmNvbnZlcnNpb25Db25maWcpID09IG51bGwgPyB2b2lkIDAgOiBoLmV4cG9ydCkgIT09IHZvaWQgMCwgdSA9ICgocCA9IGwuY29udmVyc2lvbkNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IHAuaW1wb3J0KSAhPT0gdm9pZCAwO1xuICAgICAgaWYgKGMgJiYgdSkge1xuICAgICAgICBjb25zdCBnID0gYXdhaXQgaS5jb252ZXJ0KHIsIHQsIG8pO1xuICAgICAgICByZXR1cm4gbmV3IEooZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBnID0gW1xuICAgICAgICAgIGMgPyAhMSA6IGplKHIubmFtZSksXG4gICAgICAgICAgdSA/ICExIDogamUodClcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBhbmQgXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnNpb24gZnJvbSBcIiR7ci5uYW1lfVwiIHRvIFwiJHt0fVwiIGlzIG5vdCBwb3NzaWJsZS4gJHtnfSB0b29sKHMpIHNob3VsZCBwcm92aWRlIGEgXCJjb252ZXJzaW9uQ29uZmlnXCJgKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmluc2VydE1hbnkgPSAoZSwgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoIC0gMSkgPT4ge1xuICAgICAgdGhpcy52YWxpZGF0ZUluZGV4KHQpO1xuICAgICAgY29uc3QgbyA9IGUubWFwKCh7IGlkOiBpLCB0eXBlOiBzLCBkYXRhOiByIH0pID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jb21wb3NlQmxvY2soe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgdG9vbDogcyB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgICAgIGRhdGE6IHJcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0TWFueShvLCB0KSwgby5tYXAoKGkpID0+IG5ldyBKKGkpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsZWFyOiAoKSA9PiB0aGlzLmNsZWFyKCksXG4gICAgICByZW5kZXI6IChlKSA9PiB0aGlzLnJlbmRlcihlKSxcbiAgICAgIHJlbmRlckZyb21IVE1MOiAoZSkgPT4gdGhpcy5yZW5kZXJGcm9tSFRNTChlKSxcbiAgICAgIGRlbGV0ZTogKGUpID0+IHRoaXMuZGVsZXRlKGUpLFxuICAgICAgc3dhcDogKGUsIHQpID0+IHRoaXMuc3dhcChlLCB0KSxcbiAgICAgIG1vdmU6IChlLCB0KSA9PiB0aGlzLm1vdmUoZSwgdCksXG4gICAgICBnZXRCbG9ja0J5SW5kZXg6IChlKSA9PiB0aGlzLmdldEJsb2NrQnlJbmRleChlKSxcbiAgICAgIGdldEJ5SWQ6IChlKSA9PiB0aGlzLmdldEJ5SWQoZSksXG4gICAgICBnZXRDdXJyZW50QmxvY2tJbmRleDogKCkgPT4gdGhpcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLFxuICAgICAgZ2V0QmxvY2tJbmRleDogKGUpID0+IHRoaXMuZ2V0QmxvY2tJbmRleChlKSxcbiAgICAgIGdldEJsb2Nrc0NvdW50OiAoKSA9PiB0aGlzLmdldEJsb2Nrc0NvdW50KCksXG4gICAgICBnZXRCbG9ja0J5RWxlbWVudDogKGUpID0+IHRoaXMuZ2V0QmxvY2tCeUVsZW1lbnQoZSksXG4gICAgICBzdHJldGNoQmxvY2s6IChlLCB0ID0gITApID0+IHRoaXMuc3RyZXRjaEJsb2NrKGUsIHQpLFxuICAgICAgaW5zZXJ0TmV3QmxvY2s6ICgpID0+IHRoaXMuaW5zZXJ0TmV3QmxvY2soKSxcbiAgICAgIGluc2VydDogdGhpcy5pbnNlcnQsXG4gICAgICBpbnNlcnRNYW55OiB0aGlzLmluc2VydE1hbnksXG4gICAgICB1cGRhdGU6IHRoaXMudXBkYXRlLFxuICAgICAgY29tcG9zZUJsb2NrRGF0YTogdGhpcy5jb21wb3NlQmxvY2tEYXRhLFxuICAgICAgY29udmVydDogdGhpcy5jb252ZXJ0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9ja3MgY291bnRcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldEJsb2Nrc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IGJsb2NrIGluZGV4XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRDdXJyZW50QmxvY2tJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBCbG9jayBieSBpZDtcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gYmxvY2sgaWRcbiAgICovXG4gIGdldEJsb2NrSW5kZXgoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKGUpO1xuICAgIGlmICghdCkge1xuICAgICAgWChcIlRoZXJlIGlzIG5vIGJsb2NrIHdpdGggaWQgYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tJbmRleCh0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9ja0FQSSBvYmplY3QgYnkgQmxvY2sgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggdG8gZ2V0XG4gICAqL1xuICBnZXRCbG9ja0J5SW5kZXgoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KGUpO1xuICAgIGlmICh0ID09PSB2b2lkIDApIHtcbiAgICAgIFgoXCJUaGVyZSBpcyBubyBibG9jayBhdCBpbmRleCBgXCIgKyBlICsgXCJgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKKHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrQVBJIG9iamVjdCBieSBCbG9jayBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICovXG4gIGdldEJ5SWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKGUpO1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyAoWChcIlRoZXJlIGlzIG5vIGJsb2NrIHdpdGggaWQgYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIiksIG51bGwpIDogbmV3IEoodCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jayBBUEkgb2JqZWN0IGJ5IGFueSBjaGlsZCBodG1sIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBodG1sIGVsZW1lbnQgdG8gZ2V0IEJsb2NrIGJ5XG4gICAqL1xuICBnZXRCbG9ja0J5RWxlbWVudChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwKSB7XG4gICAgICBYKFwiVGhlcmUgaXMgbm8gYmxvY2sgY29ycmVzcG9uZGluZyB0byBlbGVtZW50IGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEoodCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgQmxvY2sgTWFuYWdlciBtZXRob2QgdGhhdCBzd2FwIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gcG9zaXRpb24gb2YgZmlyc3QgQmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBwb3NpdGlvbiBvZiBzZWNvbmQgQmxvY2tcbiAgICogQGRlcHJlY2F0ZWQg4oCUIHVzZSAnbW92ZScgaW5zdGVhZFxuICAgKi9cbiAgc3dhcChlLCB0KSB7XG4gICAgUyhcbiAgICAgIFwiYGJsb2Nrcy5zd2FwKClgIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGBibG9jay5tb3ZlKClgIG1ldGhvZCBpbnN0ZWFkXCIsXG4gICAgICBcImluZm9cIlxuICAgICksIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zd2FwKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGJsb2NrIGZyb20gb25lIGluZGV4IHRvIGFub3RoZXJcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCB0byBtb3ZlIHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBpbmRleCB0byBtb3ZlIGZyb21cbiAgICovXG4gIG1vdmUoZSwgdCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5tb3ZlKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja0luZGV4IC0gaW5kZXggb2YgQmxvY2sgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5yZW1vdmVCbG9jayh0KTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBYKHQsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGggPT09IDAgJiYgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydCgpLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaywgdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkVORCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgRWRpdG9yJ3MgYXJlYVxuICAgKi9cbiAgYXN5bmMgY2xlYXIoKSB7XG4gICAgYXdhaXQgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmNsZWFyKCEwKSwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBGaWxscyBFZGl0b3Igd2l0aCBCbG9ja3MgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge091dHB1dERhdGF9IGRhdGEg4oCUIFNhdmVkIEVkaXRvciBkYXRhXG4gICAqL1xuICBhc3luYyByZW5kZXIoZSkge1xuICAgIGlmIChlID09PSB2b2lkIDAgfHwgZS5ibG9ja3MgPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBkYXRhIHBhc3NlZCB0byB0aGUgcmVuZGVyKCkgbWV0aG9kXCIpO1xuICAgIHRoaXMuRWRpdG9yLk1vZGlmaWNhdGlvbnNPYnNlcnZlci5kaXNhYmxlKCksIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcigpLCBhd2FpdCB0aGlzLkVkaXRvci5SZW5kZXJlci5yZW5kZXIoZS5ibG9ja3MpLCB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZW5hYmxlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwYXNzZWQgSFRNTCBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBIVE1MIHN0cmluZyB0byByZW5kZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICByZW5kZXJGcm9tSFRNTChlKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcigpLCB0aGlzLkVkaXRvci5QYXN0ZS5wcm9jZXNzVGV4dChlLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cmV0Y2ggQmxvY2sncyBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIHN0cmV0Y2hcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0dXMgLSB0cnVlIHRvIGVuYWJsZSwgZmFsc2UgdG8gZGlzYWJsZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgQmxvY2tBUEkgaW50ZXJmYWNlIHRvIHN0cmV0Y2ggQmxvY2tzXG4gICAqL1xuICBzdHJldGNoQmxvY2soZSwgdCA9ICEwKSB7XG4gICAgaHQoXG4gICAgICAhMCxcbiAgICAgIFwiYmxvY2tzLnN0cmV0Y2hCbG9jaygpXCIsXG4gICAgICBcIkJsb2NrQVBJXCJcbiAgICApO1xuICAgIGNvbnN0IG8gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KGUpO1xuICAgIG8gJiYgKG8uc3RyZXRjaGVkID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgQmxvY2tcbiAgICogQWZ0ZXIgc2V0IGNhcmV0IHRvIHRoaXMgQmxvY2tcbiAgICpcbiAgICogQHRvZG8gcmVtb3ZlIGluIDMuMC4wXG4gICAqIEBkZXByZWNhdGVkIHdpdGggaW5zZXJ0KCkgbWV0aG9kXG4gICAqL1xuICBpbnNlcnROZXdCbG9jaygpIHtcbiAgICBTKFwiTWV0aG9kIGJsb2Nrcy5pbnNlcnROZXdCbG9jaygpIGlzIGRlcHJlY2F0ZWQgYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBVc2UgYmxvY2tzLmluc2VydCgpIGluc3RlYWQuXCIsIFwid2FyblwiKSwgdGhpcy5pbnNlcnQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVkIGJsb2NrIGluZGV4IGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgaXQncyBpbnZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHRvIHZhbGlkYXRlXG4gICAqL1xuICB2YWxpZGF0ZUluZGV4KGUpIHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJudW1iZXJcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IHNob3VsZCBiZSBhIG51bWJlclwiKTtcbiAgICBpZiAoZSA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBcIik7XG4gICAgaWYgKGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDBcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIG1pKG4sIGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBlLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgobikgOiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gZS5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKG4pIDogZS5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKG4uaWQpO1xufVxuY2xhc3MgYmkgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zZXRUb0ZpcnN0QmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmZpcnN0QmxvY2sgPyAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZmlyc3RCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvTGFzdEJsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2sgPyAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9QcmV2aW91c0Jsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5wcmV2aW91c0Jsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnByZXZpb3VzQmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb05leHRCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubmV4dEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLm5leHRCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvQmxvY2sgPSAoZSwgdCA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCBvID0gMCkgPT4ge1xuICAgICAgY29uc3QgaSA9IG1pKGUsIHRoaXMuRWRpdG9yKTtcbiAgICAgIHJldHVybiBpID09PSB2b2lkIDAgPyAhMSA6ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKGksIHQsIG8pLCAhMCk7XG4gICAgfSwgdGhpcy5mb2N1cyA9IChlID0gITEpID0+IGUgPyB0aGlzLnNldFRvTGFzdEJsb2NrKHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5FTkQpIDogdGhpcy5zZXRUb0ZpcnN0QmxvY2sodGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLlNUQVJUKTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0NhcmV0fVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFRvRmlyc3RCbG9jazogdGhpcy5zZXRUb0ZpcnN0QmxvY2ssXG4gICAgICBzZXRUb0xhc3RCbG9jazogdGhpcy5zZXRUb0xhc3RCbG9jayxcbiAgICAgIHNldFRvUHJldmlvdXNCbG9jazogdGhpcy5zZXRUb1ByZXZpb3VzQmxvY2ssXG4gICAgICBzZXRUb05leHRCbG9jazogdGhpcy5zZXRUb05leHRCbG9jayxcbiAgICAgIHNldFRvQmxvY2s6IHRoaXMuc2V0VG9CbG9jayxcbiAgICAgIGZvY3VzOiB0aGlzLmZvY3VzXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgdmkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtFdmVudHN9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1pdDogKGUsIHQpID0+IHRoaXMuZW1pdChlLCB0KSxcbiAgICAgIG9mZjogKGUsIHQpID0+IHRoaXMub2ZmKGUsIHQpLFxuICAgICAgb246IChlLCB0KSA9PiB0aGlzLm9uKGUsIHQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIG9uIEV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gZXZlbnQgbmFtZSB0byBzdWJzY3JpYmVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBvbihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGV2ZW50IHdpdGggZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gZXZlbnQgdG8gZW1pdFxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGV2ZW50J3MgZGF0YVxuICAgKi9cbiAgZW1pdChlLCB0KSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gRXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IHRvIHVuc3Vic2NyaWJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb2ZmKGUsIHQpIHtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub2ZmKGUsIHQpO1xuICB9XG59XG5jbGFzcyBrdCBleHRlbmRzIEUge1xuICAvKipcbiAgICogUmV0dXJuIG5hbWVzcGFjZSBzZWN0aW9uIGZvciB0b29sIG9yIGJsb2NrIHR1bmVcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCBuYW1lXG4gICAqIEBwYXJhbSBpc1R1bmUgLSBpcyB0b29sIGEgYmxvY2sgdHVuZVxuICAgKi9cbiAgc3RhdGljIGdldE5hbWVzcGFjZShlLCB0KSB7XG4gICAgcmV0dXJuIHQgPyBgYmxvY2tUdW5lcy4ke2V9YCA6IGB0b29scy4ke2V9YDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEkxOG4gQVBJIG1ldGhvZHMgd2l0aCBnbG9iYWwgZGljdGlvbmFyeSBhY2Nlc3NcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0OiAoKSA9PiB7XG4gICAgICAgIFgoXCJJMThuLnQoKSBtZXRob2QgY2FuIGJlIGFjY2Vzc2VkIG9ubHkgZnJvbSBUb29sc1wiLCBcIndhcm5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEkxOG4gQVBJIG1ldGhvZHMgd2l0aCB0b29sIG5hbWVzcGFjZWQgZGljdGlvbmFyeVxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIG5hbWVcbiAgICogQHBhcmFtIGlzVHVuZSAtIGlzIHRvb2wgYSBibG9jayB0dW5lXG4gICAqL1xuICBnZXRNZXRob2RzRm9yVG9vbChlLCB0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLm1ldGhvZHMsXG4gICAgICB7XG4gICAgICAgIHQ6IChvKSA9PiB6LnQoa3QuZ2V0TmFtZXNwYWNlKGUsIHQpLCBvKVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIGtpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBFZGl0b3IuanMgQ29yZSBBUEkgbW9kdWxlc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrczogdGhpcy5FZGl0b3IuQmxvY2tzQVBJLm1ldGhvZHMsXG4gICAgICBjYXJldDogdGhpcy5FZGl0b3IuQ2FyZXRBUEkubWV0aG9kcyxcbiAgICAgIHRvb2xzOiB0aGlzLkVkaXRvci5Ub29sc0FQSS5tZXRob2RzLFxuICAgICAgZXZlbnRzOiB0aGlzLkVkaXRvci5FdmVudHNBUEkubWV0aG9kcyxcbiAgICAgIGxpc3RlbmVyczogdGhpcy5FZGl0b3IuTGlzdGVuZXJzQVBJLm1ldGhvZHMsXG4gICAgICBub3RpZmllcjogdGhpcy5FZGl0b3IuTm90aWZpZXJBUEkubWV0aG9kcyxcbiAgICAgIHNhbml0aXplcjogdGhpcy5FZGl0b3IuU2FuaXRpemVyQVBJLm1ldGhvZHMsXG4gICAgICBzYXZlcjogdGhpcy5FZGl0b3IuU2F2ZXJBUEkubWV0aG9kcyxcbiAgICAgIHNlbGVjdGlvbjogdGhpcy5FZGl0b3IuU2VsZWN0aW9uQVBJLm1ldGhvZHMsXG4gICAgICBzdHlsZXM6IHRoaXMuRWRpdG9yLlN0eWxlc0FQSS5jbGFzc2VzLFxuICAgICAgdG9vbGJhcjogdGhpcy5FZGl0b3IuVG9vbGJhckFQSS5tZXRob2RzLFxuICAgICAgaW5saW5lVG9vbGJhcjogdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhckFQSS5tZXRob2RzLFxuICAgICAgdG9vbHRpcDogdGhpcy5FZGl0b3IuVG9vbHRpcEFQSS5tZXRob2RzLFxuICAgICAgaTE4bjogdGhpcy5FZGl0b3IuSTE4bkFQSS5tZXRob2RzLFxuICAgICAgcmVhZE9ubHk6IHRoaXMuRWRpdG9yLlJlYWRPbmx5QVBJLm1ldGhvZHMsXG4gICAgICB1aTogdGhpcy5FZGl0b3IuVWlBUEkubWV0aG9kc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgRWRpdG9yLmpzIENvcmUgQVBJIG1ldGhvZHMgZm9yIHBhc3NlZCB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIHRvb2wgbmFtZVxuICAgKiBAcGFyYW0gaXNUdW5lIC0gaXMgdG9vbCBhIGJsb2NrIHR1bmVcbiAgICovXG4gIGdldE1ldGhvZHNGb3JUb29sKGUsIHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHRoaXMubWV0aG9kcyxcbiAgICAgIHtcbiAgICAgICAgaTE4bjogdGhpcy5FZGl0b3IuSTE4bkFQSS5nZXRNZXRob2RzRm9yVG9vbChlLCB0KVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIHlpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7SW5saW5lVG9vbGJhcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZTogKCkgPT4gdGhpcy5jbG9zZSgpLFxuICAgICAgb3BlbjogKCkgPT4gdGhpcy5vcGVuKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIElubGluZSBUb29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIudHJ5VG9TaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIElubGluZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbn1cbmNsYXNzIHdpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiAoZSwgdCwgbywgaSkgPT4gdGhpcy5vbihlLCB0LCBvLCBpKSxcbiAgICAgIG9mZjogKGUsIHQsIG8sIGkpID0+IHRoaXMub2ZmKGUsIHQsIG8sIGkpLFxuICAgICAgb2ZmQnlJZDogKGUpID0+IHRoaXMub2ZmQnlJZChlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFkcyBhIERPTSBldmVudCBsaXN0ZW5lci4gUmV0dXJuIGl0J3MgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHNldCBoYW5kbGVyIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYXB0dXJlIC0gY2FwdHVyZSBldmVudCBvciBub3RcbiAgICovXG4gIG9uKGUsIHQsIG8sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMub24oZSwgdCwgbywgaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVyIGZyb20gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlbW92ZSBoYW5kbGVyIGZyb21cbiAgICogQHBhcmFtIGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSAtIGNhcHR1cmUgZXZlbnQgb3Igbm90XG4gICAqL1xuICBvZmYoZSwgdCwgbywgaSkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZihlLCB0LCBvLCBpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBET00gbGlzdGVuZXIgYnkgdGhlIGxpc3RlbmVyIGlkXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGlkIG9mIHRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIG9mZkJ5SWQoZSkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZkJ5SWQoZSk7XG4gIH1cbn1cbnZhciBLbyA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihuLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgbi5leHBvcnRzID0gbygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICAgIGlmIChvW3NdKVxuICAgICAgICAgIHJldHVybiBvW3NdLmV4cG9ydHM7XG4gICAgICAgIHZhciByID0gb1tzXSA9IHsgaTogcywgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiB0W3NdLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIGkpLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkubSA9IHQsIGkuYyA9IG8sIGkuZCA9IGZ1bmN0aW9uKHMsIHIsIGEpIHtcbiAgICAgICAgaS5vKHMsIHIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCByLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGEgfSk7XG4gICAgICB9LCBpLnIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIGkudCA9IGZ1bmN0aW9uKHMsIHIpIHtcbiAgICAgICAgaWYgKDEgJiByICYmIChzID0gaShzKSksIDggJiByIHx8IDQgJiByICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCIgJiYgcyAmJiBzLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIHZhciBhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmIChpLnIoYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IHMgfSksIDIgJiByICYmIHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBzKVxuICAgICAgICAgICAgaS5kKGEsIGwsIChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzW2NdO1xuICAgICAgICAgICAgfSkuYmluZChudWxsLCBsKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgaS5uID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgciA9IHMgJiYgcy5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHMuZGVmYXVsdDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaS5kKHIsIFwiYVwiLCByKSwgcjtcbiAgICAgIH0sIGkubyA9IGZ1bmN0aW9uKHMsIHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCByKTtcbiAgICAgIH0sIGkucCA9IFwiL1wiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGkoMSksIC8qIVxuICAgICAgICogQ29kZXggSmF2YVNjcmlwdCBOb3RpZmljYXRpb24gbW9kdWxlXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29kZXgtdGVhbS9qcy1ub3RpZmllclxuICAgICAgICovXG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSBpKDYpLCByID0gXCJjZHgtbm90aWZ5LS1ib3VuY2UtaW5cIiwgYSA9IG51bGw7XG4gICAgICAgIHJldHVybiB7IHNob3c6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBpZiAobC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgYSA9IHMuZ2V0V3JhcHBlcigpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBjID0gbnVsbCwgdSA9IGwudGltZSB8fCA4ZTM7XG4gICAgICAgICAgICBzd2l0Y2ggKGwudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY29uZmlybVwiOlxuICAgICAgICAgICAgICAgIGMgPSBzLmNvbmZpcm0obCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJwcm9tcHRcIjpcbiAgICAgICAgICAgICAgICBjID0gcy5wcm9tcHQobCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYyA9IHMuYWxlcnQobCksIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgYy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9LCB1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoYyksIGMuY2xhc3NMaXN0LmFkZChyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfTtcbiAgICAgIH0oKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgcyA9IGkoMik7XG4gICAgICB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIChzID0gW1t0LmksIHMsIFwiXCJdXSk7XG4gICAgICB2YXIgciA9IHsgaG1yOiAhMCwgdHJhbnNmb3JtOiB2b2lkIDAsIGluc2VydEludG86IHZvaWQgMCB9O1xuICAgICAgaSg0KShzLCByKSwgcy5sb2NhbHMgJiYgKHQuZXhwb3J0cyA9IHMubG9jYWxzKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICAodC5leHBvcnRzID0gaSgzKSghMSkpLnB1c2goW3QuaSwgYC5jZHgtbm90aWZ5LS1lcnJvcntiYWNrZ3JvdW5kOiNmZmZiZmIhaW1wb3J0YW50fS5jZHgtbm90aWZ5LS1lcnJvcjo6YmVmb3Jle2JhY2tncm91bmQ6I2ZiNWQ1ZCFpbXBvcnRhbnR9LmNkeC1ub3RpZnlfX2lucHV0e21heC13aWR0aDoxMzBweDtwYWRkaW5nOjVweCAxMHB4O2JhY2tncm91bmQ6I2Y3ZjdmNztib3JkZXI6MDtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6MTNweDtjb2xvcjojNjU2YjdjO291dGxpbmU6MH0uY2R4LW5vdGlmeV9faW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM2NTZiN2N9LmNkeC1ub3RpZnlfX2lucHV0OjpwbGFjZWhvbGRlcntjb2xvcjojNjU2YjdjfS5jZHgtbm90aWZ5X19pbnB1dDpmb2N1czotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6cmdiYSgxMDEsMTA3LDEyNCwuMyl9LmNkeC1ub3RpZnlfX2lucHV0OmZvY3VzOjpwbGFjZWhvbGRlcntjb2xvcjpyZ2JhKDEwMSwxMDcsMTI0LC4zKX0uY2R4LW5vdGlmeV9fYnV0dG9ue2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtc2l6ZToxM3B4O3BhZGRpbmc6NXB4IDEwcHg7Y3Vyc29yOnBvaW50ZXJ9LmNkeC1ub3RpZnlfX2J1dHRvbjpsYXN0LWNoaWxke21hcmdpbi1sZWZ0OjEwcHh9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2Vse2JhY2tncm91bmQ6I2YyZjVmNztib3gtc2hhZG93OjAgMnB4IDFweCAwIHJnYmEoMTYsMTksMjksMCk7Y29sb3I6IzY1NmI3Y30uY2R4LW5vdGlmeV9fYnV0dG9uLS1jYW5jZWw6aG92ZXJ7YmFja2dyb3VuZDojZWVlfS5jZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm17YmFja2dyb3VuZDojMzRjOTkyO2JveC1zaGFkb3c6MCAxcHggMXB4IDAgcmdiYSgxOCw0OSwzNSwuMDUpO2NvbG9yOiNmZmZ9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY29uZmlybTpob3ZlcntiYWNrZ3JvdW5kOiMzM2IwODJ9LmNkeC1ub3RpZnlfX2J0bnMtd3JhcHBlcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1mbG93OnJvdyBub3dyYXA7ZmxleC1mbG93OnJvdyBub3dyYXA7bWFyZ2luLXRvcDo1cHh9LmNkeC1ub3RpZnlfX2Nyb3Nze3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1cHg7cmlnaHQ6NXB4O3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7cGFkZGluZzo1cHg7b3BhY2l0eTouNTQ7Y3Vyc29yOnBvaW50ZXJ9LmNkeC1ub3RpZnlfX2Nyb3NzOjphZnRlciwuY2R4LW5vdGlmeV9fY3Jvc3M6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6OXB4O3RvcDo1cHg7aGVpZ2h0OjEycHg7d2lkdGg6MnB4O2JhY2tncm91bmQ6IzU3NWQ2N30uY2R4LW5vdGlmeV9fY3Jvc3M6OmJlZm9yZXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LmNkeC1ub3RpZnlfX2Nyb3NzOjphZnRlcnt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uY2R4LW5vdGlmeV9fY3Jvc3M6aG92ZXJ7b3BhY2l0eToxfS5jZHgtbm90aWZpZXN7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoyO2JvdHRvbToyMHB4O2xlZnQ6MjBweDtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxcIlNlZ29lIFVJXCIsUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFwiRmlyYSBTYW5zXCIsXCJEcm9pZCBTYW5zXCIsXCJIZWx2ZXRpY2EgTmV1ZVwiLHNhbnMtc2VyaWZ9LmNkeC1ub3RpZnl7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MjIwcHg7bWFyZ2luLXRvcDoxNXB4O3BhZGRpbmc6MTNweCAxNnB4O2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjAgMTFweCAxN3B4IDAgcmdiYSgyMywzMiw2MSwuMTMpO2JvcmRlci1yYWRpdXM6NXB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNGVtO3dvcmQtd3JhcDpicmVhay13b3JkfS5jZHgtbm90aWZ5OjpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3RvcDowO2xlZnQ6MDt3aWR0aDozcHg7aGVpZ2h0OmNhbGMoMTAwJSAtIDZweCk7bWFyZ2luOjNweDtib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOjAgMH1Aa2V5ZnJhbWVzIGJvdW5jZUluezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjMpfTUwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlKDEuMDUpfTcwJXt0cmFuc2Zvcm06c2NhbGUoLjkpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX0uY2R4LW5vdGlmeS0tYm91bmNlLWlue2FuaW1hdGlvbi1uYW1lOmJvdW5jZUluO2FuaW1hdGlvbi1kdXJhdGlvbjouNnM7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDoxfS5jZHgtbm90aWZ5LS1zdWNjZXNze2JhY2tncm91bmQ6I2ZhZmZmZSFpbXBvcnRhbnR9LmNkeC1ub3RpZnktLXN1Y2Nlc3M6OmJlZm9yZXtiYWNrZ3JvdW5kOiM0MWZmYjEhaW1wb3J0YW50fWAsIFwiXCJdKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBzID0gW107XG4gICAgICAgIHJldHVybiBzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHZhciBhID0gZnVuY3Rpb24obCwgYykge1xuICAgICAgICAgICAgICB2YXIgdSA9IGxbMV0gfHwgXCJcIiwgaCA9IGxbM107XG4gICAgICAgICAgICAgIGlmICghaClcbiAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgICAgaWYgKGMgJiYgdHlwZW9mIGJ0b2EgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSAoZiA9IGgsIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZikpKSkgKyBcIiAqL1wiKSwgZyA9IGguc291cmNlcy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIiArIGguc291cmNlUm9vdCArIHYgKyBcIiAqL1wiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdV0uY29uY2F0KGcpLmNvbmNhdChbcF0pLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgIHJldHVybiBbdV0uam9pbihgXG5gKTtcbiAgICAgICAgICAgIH0ociwgaSk7XG4gICAgICAgICAgICByZXR1cm4gclsyXSA/IFwiQG1lZGlhIFwiICsgclsyXSArIFwie1wiICsgYSArIFwifVwiIDogYTtcbiAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB9LCBzLmkgPSBmdW5jdGlvbihyLCBhKSB7XG4gICAgICAgICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IFtbbnVsbCwgciwgXCJcIl1dKTtcbiAgICAgICAgICBmb3IgKHZhciBsID0ge30sIGMgPSAwOyBjIDwgdGhpcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzW2NdWzBdO1xuICAgICAgICAgICAgdHlwZW9mIHUgPT0gXCJudW1iZXJcIiAmJiAobFt1XSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gMDsgYyA8IHIubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBoID0gcltjXTtcbiAgICAgICAgICAgIHR5cGVvZiBoWzBdID09IFwibnVtYmVyXCIgJiYgbFtoWzBdXSB8fCAoYSAmJiAhaFsyXSA/IGhbMl0gPSBhIDogYSAmJiAoaFsyXSA9IFwiKFwiICsgaFsyXSArIFwiKSBhbmQgKFwiICsgYSArIFwiKVwiKSwgcy5wdXNoKGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHM7XG4gICAgICB9O1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHZhciBzLCByLCBhID0ge30sIGwgPSAocyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCAmJiAociA9IHMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHI7XG4gICAgICB9KSwgYyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHcgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIHcoKTtcbiAgICAgICAgICBpZiAobVt3XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgeCA9IChmdW5jdGlvbihJKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKEkpO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLCB3KTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgeCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4ID0geC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgeCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bd10gPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbVt3XTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSwgdSA9IG51bGwsIGggPSAwLCBwID0gW10sIGcgPSBpKDUpO1xuICAgICAgZnVuY3Rpb24gZihrLCBtKSB7XG4gICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgay5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciB4ID0ga1t3XSwgSSA9IGFbeC5pZF07XG4gICAgICAgICAgaWYgKEkpIHtcbiAgICAgICAgICAgIEkucmVmcysrO1xuICAgICAgICAgICAgZm9yICh2YXIgQyA9IDA7IEMgPCBJLnBhcnRzLmxlbmd0aDsgQysrKVxuICAgICAgICAgICAgICBJLnBhcnRzW0NdKHgucGFydHNbQ10pO1xuICAgICAgICAgICAgZm9yICg7IEMgPCB4LnBhcnRzLmxlbmd0aDsgQysrKVxuICAgICAgICAgICAgICBJLnBhcnRzLnB1c2goRih4LnBhcnRzW0NdLCBtKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBOID0gW107XG4gICAgICAgICAgICBmb3IgKEMgPSAwOyBDIDwgeC5wYXJ0cy5sZW5ndGg7IEMrKylcbiAgICAgICAgICAgICAgTi5wdXNoKEYoeC5wYXJ0c1tDXSwgbSkpO1xuICAgICAgICAgICAgYVt4LmlkXSA9IHsgaWQ6IHguaWQsIHJlZnM6IDEsIHBhcnRzOiBOIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2KGssIG0pIHtcbiAgICAgICAgZm9yICh2YXIgdyA9IFtdLCB4ID0ge30sIEkgPSAwOyBJIDwgay5sZW5ndGg7IEkrKykge1xuICAgICAgICAgIHZhciBDID0ga1tJXSwgTiA9IG0uYmFzZSA/IENbMF0gKyBtLmJhc2UgOiBDWzBdLCBCID0geyBjc3M6IENbMV0sIG1lZGlhOiBDWzJdLCBzb3VyY2VNYXA6IENbM10gfTtcbiAgICAgICAgICB4W05dID8geFtOXS5wYXJ0cy5wdXNoKEIpIDogdy5wdXNoKHhbTl0gPSB7IGlkOiBOLCBwYXJ0czogW0JdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTyhrLCBtKSB7XG4gICAgICAgIHZhciB3ID0gYyhrLmluc2VydEludG8pO1xuICAgICAgICBpZiAoIXcpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIHZhciB4ID0gcFtwLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoay5pbnNlcnRBdCA9PT0gXCJ0b3BcIilcbiAgICAgICAgICB4ID8geC5uZXh0U2libGluZyA/IHcuaW5zZXJ0QmVmb3JlKG0sIHgubmV4dFNpYmxpbmcpIDogdy5hcHBlbmRDaGlsZChtKSA6IHcuaW5zZXJ0QmVmb3JlKG0sIHcuZmlyc3RDaGlsZCksIHAucHVzaChtKTtcbiAgICAgICAgZWxzZSBpZiAoay5pbnNlcnRBdCA9PT0gXCJib3R0b21cIilcbiAgICAgICAgICB3LmFwcGVuZENoaWxkKG0pO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGsuaW5zZXJ0QXQgIT0gXCJvYmplY3RcIiB8fCAhay5pbnNlcnRBdC5iZWZvcmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtTdHlsZSBMb2FkZXJdXG5cbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcbmApO1xuICAgICAgICAgIHZhciBJID0gYyhrLmluc2VydEludG8gKyBcIiBcIiArIGsuaW5zZXJ0QXQuYmVmb3JlKTtcbiAgICAgICAgICB3Lmluc2VydEJlZm9yZShtLCBJKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gVChrKSB7XG4gICAgICAgIGlmIChrLnBhcmVudE5vZGUgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoayk7XG4gICAgICAgIHZhciBtID0gcC5pbmRleE9mKGspO1xuICAgICAgICBtID49IDAgJiYgcC5zcGxpY2UobSwgMSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBNKGspIHtcbiAgICAgICAgdmFyIG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIHJldHVybiBrLmF0dHJzLnR5cGUgPT09IHZvaWQgMCAmJiAoay5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiKSwgcShtLCBrLmF0dHJzKSwgTyhrLCBtKSwgbTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHEoaywgbSkge1xuICAgICAgICBPYmplY3Qua2V5cyhtKS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICBrLnNldEF0dHJpYnV0ZSh3LCBtW3ddKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBGKGssIG0pIHtcbiAgICAgICAgdmFyIHcsIHgsIEksIEM7XG4gICAgICAgIGlmIChtLnRyYW5zZm9ybSAmJiBrLmNzcykge1xuICAgICAgICAgIGlmICghKEMgPSBtLnRyYW5zZm9ybShrLmNzcykpKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBrLmNzcyA9IEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0uc2luZ2xldG9uKSB7XG4gICAgICAgICAgdmFyIE4gPSBoKys7XG4gICAgICAgICAgdyA9IHUgfHwgKHUgPSBNKG0pKSwgeCA9IGllLmJpbmQobnVsbCwgdywgTiwgITEpLCBJID0gaWUuYmluZChudWxsLCB3LCBOLCAhMCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGsuc291cmNlTWFwICYmIHR5cGVvZiBVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIEJsb2IgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIiA/ICh3ID0gZnVuY3Rpb24oQikge1xuICAgICAgICAgICAgdmFyIFcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICAgICAgICAgIHJldHVybiBCLmF0dHJzLnR5cGUgPT09IHZvaWQgMCAmJiAoQi5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiKSwgQi5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIiwgcShXLCBCLmF0dHJzKSwgTyhCLCBXKSwgVztcbiAgICAgICAgICB9KG0pLCB4ID0gKGZ1bmN0aW9uKEIsIFcsIHZlKSB7XG4gICAgICAgICAgICB2YXIgc2UgPSB2ZS5jc3MsIHR0ID0gdmUuc291cmNlTWFwLCBZbiA9IFcuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB2b2lkIDAgJiYgdHQ7XG4gICAgICAgICAgICAoVy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgWW4pICYmIChzZSA9IGcoc2UpKSwgdHQgJiYgKHNlICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYCArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHR0KSkpKSArIFwiICovXCIpO1xuICAgICAgICAgICAgdmFyIEtuID0gbmV3IEJsb2IoW3NlXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSksIGtvID0gQi5ocmVmO1xuICAgICAgICAgICAgQi5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChLbiksIGtvICYmIFVSTC5yZXZva2VPYmplY3RVUkwoa28pO1xuICAgICAgICAgIH0pLmJpbmQobnVsbCwgdywgbSksIEkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFQodyksIHcuaHJlZiAmJiBVUkwucmV2b2tlT2JqZWN0VVJMKHcuaHJlZik7XG4gICAgICAgICAgfSkgOiAodyA9IE0obSksIHggPSAoZnVuY3Rpb24oQiwgVykge1xuICAgICAgICAgICAgdmFyIHZlID0gVy5jc3MsIHNlID0gVy5tZWRpYTtcbiAgICAgICAgICAgIGlmIChzZSAmJiBCLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIHNlKSwgQi5zdHlsZVNoZWV0KVxuICAgICAgICAgICAgICBCLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHZlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoOyBCLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICAgICAgICBCLnJlbW92ZUNoaWxkKEIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgIEIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5iaW5kKG51bGwsIHcpLCBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBUKHcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geChrKSwgZnVuY3Rpb24oQikge1xuICAgICAgICAgIGlmIChCKSB7XG4gICAgICAgICAgICBpZiAoQi5jc3MgPT09IGsuY3NzICYmIEIubWVkaWEgPT09IGsubWVkaWEgJiYgQi5zb3VyY2VNYXAgPT09IGsuc291cmNlTWFwKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB4KGsgPSBCKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEkoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGssIG0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBERUJVRyA8IFwidVwiICYmIERFQlVHICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgICAgICAgKG0gPSBtIHx8IHt9KS5hdHRycyA9IHR5cGVvZiBtLmF0dHJzID09IFwib2JqZWN0XCIgPyBtLmF0dHJzIDoge30sIG0uc2luZ2xldG9uIHx8IHR5cGVvZiBtLnNpbmdsZXRvbiA9PSBcImJvb2xlYW5cIiB8fCAobS5zaW5nbGV0b24gPSBsKCkpLCBtLmluc2VydEludG8gfHwgKG0uaW5zZXJ0SW50byA9IFwiaGVhZFwiKSwgbS5pbnNlcnRBdCB8fCAobS5pbnNlcnRBdCA9IFwiYm90dG9tXCIpO1xuICAgICAgICB2YXIgdyA9IHYoaywgbSk7XG4gICAgICAgIHJldHVybiBmKHcsIG0pLCBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgZm9yICh2YXIgSSA9IFtdLCBDID0gMDsgQyA8IHcubGVuZ3RoOyBDKyspIHtcbiAgICAgICAgICAgIHZhciBOID0gd1tDXTtcbiAgICAgICAgICAgIChCID0gYVtOLmlkXSkucmVmcy0tLCBJLnB1c2goQik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoeCAmJiBmKHYoeCwgbSksIG0pLCBDID0gMDsgQyA8IEkubGVuZ3RoOyBDKyspIHtcbiAgICAgICAgICAgIHZhciBCO1xuICAgICAgICAgICAgaWYgKChCID0gSVtDXSkucmVmcyA9PT0gMCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBXID0gMDsgVyA8IEIucGFydHMubGVuZ3RoOyBXKyspXG4gICAgICAgICAgICAgICAgQi5wYXJ0c1tXXSgpO1xuICAgICAgICAgICAgICBkZWxldGUgYVtCLmlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdmFyIEgsIFEgPSAoSCA9IFtdLCBmdW5jdGlvbihrLCBtKSB7XG4gICAgICAgIHJldHVybiBIW2tdID0gbSwgSC5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKTtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gaWUoaywgbSwgdywgeCkge1xuICAgICAgICB2YXIgSSA9IHcgPyBcIlwiIDogeC5jc3M7XG4gICAgICAgIGlmIChrLnN0eWxlU2hlZXQpXG4gICAgICAgICAgay5zdHlsZVNoZWV0LmNzc1RleHQgPSBRKG0sIEkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgQyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEkpLCBOID0gay5jaGlsZE5vZGVzO1xuICAgICAgICAgIE5bbV0gJiYgay5yZW1vdmVDaGlsZChOW21dKSwgTi5sZW5ndGggPyBrLmluc2VydEJlZm9yZShDLCBOW21dKSA6IGsuYXBwZW5kQ2hpbGQoQyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBzID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKCFzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICAgICAgICBpZiAoIWkgfHwgdHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgdmFyIHIgPSBzLnByb3RvY29sICsgXCIvL1wiICsgcy5ob3N0LCBhID0gciArIHMucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG4gICAgICAgIHJldHVybiBpLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihsLCBjKSB7XG4gICAgICAgICAgdmFyIHUsIGggPSBjLnRyaW0oKS5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24ocCwgZykge1xuICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgfSkucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihwLCBnKSB7XG4gICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdChoKSA/IGwgOiAodSA9IGguaW5kZXhPZihcIi8vXCIpID09PSAwID8gaCA6IGguaW5kZXhPZihcIi9cIikgPT09IDAgPyByICsgaCA6IGEgKyBoLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKSwgXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeSh1KSArIFwiKVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHZhciBzLCByLCBhLCBsLCBjLCB1LCBoLCBwLCBnO1xuICAgICAgdC5leHBvcnRzID0gKHMgPSBcImNkeC1ub3RpZmllc1wiLCByID0gXCJjZHgtbm90aWZ5XCIsIGEgPSBcImNkeC1ub3RpZnlfX2Nyb3NzXCIsIGwgPSBcImNkeC1ub3RpZnlfX2J1dHRvbi0tY29uZmlybVwiLCBjID0gXCJjZHgtbm90aWZ5X19idXR0b24tLWNhbmNlbFwiLCB1ID0gXCJjZHgtbm90aWZ5X19pbnB1dFwiLCBoID0gXCJjZHgtbm90aWZ5X19idXR0b25cIiwgcCA9IFwiY2R4LW5vdGlmeV9fYnRucy13cmFwcGVyXCIsIHsgYWxlcnQ6IGcgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciB2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgTyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIFQgPSBmLm1lc3NhZ2UsIE0gPSBmLnN0eWxlO1xuICAgICAgICByZXR1cm4gdi5jbGFzc0xpc3QuYWRkKHIpLCBNICYmIHYuY2xhc3NMaXN0LmFkZChyICsgXCItLVwiICsgTSksIHYuaW5uZXJIVE1MID0gVCwgTy5jbGFzc0xpc3QuYWRkKGEpLCBPLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB2LnJlbW92ZS5iaW5kKHYpKSwgdi5hcHBlbmRDaGlsZChPKSwgdjtcbiAgICAgIH0sIGNvbmZpcm06IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHYgPSBnKGYpLCBPID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIE0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBxID0gdi5xdWVyeVNlbGVjdG9yKFwiLlwiICsgYSksIEYgPSBmLmNhbmNlbEhhbmRsZXIsIEggPSBmLm9rSGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIE8uY2xhc3NMaXN0LmFkZChwKSwgVC5pbm5lckhUTUwgPSBmLm9rVGV4dCB8fCBcIkNvbmZpcm1cIiwgTS5pbm5lckhUTUwgPSBmLmNhbmNlbFRleHQgfHwgXCJDYW5jZWxcIiwgVC5jbGFzc0xpc3QuYWRkKGgpLCBNLmNsYXNzTGlzdC5hZGQoaCksIFQuY2xhc3NMaXN0LmFkZChsKSwgTS5jbGFzc0xpc3QuYWRkKGMpLCBGICYmIHR5cGVvZiBGID09IFwiZnVuY3Rpb25cIiAmJiAoTS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgRiksIHEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEYpKSwgSCAmJiB0eXBlb2YgSCA9PSBcImZ1bmN0aW9uXCIgJiYgVC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgSCksIFQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHYucmVtb3ZlLmJpbmQodikpLCBNLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB2LnJlbW92ZS5iaW5kKHYpKSwgTy5hcHBlbmRDaGlsZChUKSwgTy5hcHBlbmRDaGlsZChNKSwgdi5hcHBlbmRDaGlsZChPKSwgdjtcbiAgICAgIH0sIHByb21wdDogZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgdiA9IGcoZiksIE8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBUID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgcSA9IHYucXVlcnlTZWxlY3RvcihcIi5cIiArIGEpLCBGID0gZi5jYW5jZWxIYW5kbGVyLCBIID0gZi5va0hhbmRsZXI7XG4gICAgICAgIHJldHVybiBPLmNsYXNzTGlzdC5hZGQocCksIFQuaW5uZXJIVE1MID0gZi5va1RleHQgfHwgXCJPa1wiLCBULmNsYXNzTGlzdC5hZGQoaCksIFQuY2xhc3NMaXN0LmFkZChsKSwgTS5jbGFzc0xpc3QuYWRkKHUpLCBmLnBsYWNlaG9sZGVyICYmIE0uc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgZi5wbGFjZWhvbGRlciksIGYuZGVmYXVsdCAmJiAoTS52YWx1ZSA9IGYuZGVmYXVsdCksIGYuaW5wdXRUeXBlICYmIChNLnR5cGUgPSBmLmlucHV0VHlwZSksIEYgJiYgdHlwZW9mIEYgPT0gXCJmdW5jdGlvblwiICYmIHEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEYpLCBIICYmIHR5cGVvZiBIID09IFwiZnVuY3Rpb25cIiAmJiBULmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBIKE0udmFsdWUpO1xuICAgICAgICB9KSwgVC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdi5yZW1vdmUuYmluZCh2KSksIE8uYXBwZW5kQ2hpbGQoTSksIE8uYXBwZW5kQ2hpbGQoVCksIHYuYXBwZW5kQ2hpbGQoTyksIHY7XG4gICAgICB9LCBnZXRXcmFwcGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICByZXR1cm4gZi5jbGFzc0xpc3QuYWRkKHMpLCBmO1xuICAgICAgfSB9KTtcbiAgICB9XSk7XG4gIH0pO1xufSkoS28pO1xudmFyIEVpID0gS28uZXhwb3J0cztcbmNvbnN0IHhpID0gLyogQF9fUFVSRV9fICovIEtlKEVpKTtcbmNsYXNzIEJpIHtcbiAgLyoqXG4gICAqIFNob3cgd2ViIG5vdGlmaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge05vdGlmaWVyT3B0aW9ucyB8IENvbmZpcm1Ob3RpZmllck9wdGlvbnMgfCBQcm9tcHROb3RpZmllck9wdGlvbnN9IG9wdGlvbnMgLSBub3RpZmljYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgc2hvdyhlKSB7XG4gICAgeGkuc2hvdyhlKTtcbiAgfVxufVxuY2xhc3MgQ2kgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLm5vdGlmaWVyID0gbmV3IEJpKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvdzogKGUpID0+IHRoaXMuc2hvdyhlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNob3cgbm90aWZpY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm90aWZpZXJPcHRpb25zfSBvcHRpb25zIC0gbWVzc2FnZSBvcHRpb25cbiAgICovXG4gIHNob3coZSkge1xuICAgIHJldHVybiB0aGlzLm5vdGlmaWVyLnNob3coZSk7XG4gIH1cbn1cbmNsYXNzIFRpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHRoaXMuaXNFbmFibGVkO1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGU6ICh0KSA9PiB0aGlzLnRvZ2dsZSh0KSxcbiAgICAgIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiBlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIHRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gc3RhdGUgLSBzZXQgb3IgdG9nZ2xlIHN0YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IHZhbHVlXG4gICAqL1xuICB0b2dnbGUoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS50b2dnbGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCByZWFkLW9ubHkgc3RhdGVcbiAgICovXG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZDtcbiAgfVxufVxudmFyIFhvID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKG4sIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBuLmV4cG9ydHMgPSBvKCk7XG4gIH0pKENlLCBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiB0KGgpIHtcbiAgICAgIHZhciBwID0gaC50YWdzLCBnID0gT2JqZWN0LmtleXMocCksIGYgPSBnLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcFt2XTtcbiAgICAgIH0pLmV2ZXJ5KGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IFwib2JqZWN0XCIgfHwgdiA9PT0gXCJib29sZWFuXCIgfHwgdiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb25maWd1cmF0aW9uIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgdGhpcy5jb25maWcgPSBoO1xuICAgIH1cbiAgICB2YXIgbyA9IFtcIlBcIiwgXCJMSVwiLCBcIlREXCIsIFwiVEhcIiwgXCJESVZcIiwgXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIiwgXCJQUkVcIl07XG4gICAgZnVuY3Rpb24gaShoKSB7XG4gICAgICByZXR1cm4gby5pbmRleE9mKGgubm9kZU5hbWUpICE9PSAtMTtcbiAgICB9XG4gICAgdmFyIHMgPSBbXCJBXCIsIFwiQlwiLCBcIlNUUk9OR1wiLCBcIklcIiwgXCJFTVwiLCBcIlNVQlwiLCBcIlNVUFwiLCBcIlVcIiwgXCJTVFJJS0VcIl07XG4gICAgZnVuY3Rpb24gcihoKSB7XG4gICAgICByZXR1cm4gcy5pbmRleE9mKGgubm9kZU5hbWUpICE9PSAtMTtcbiAgICB9XG4gICAgdC5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbihoKSB7XG4gICAgICBjb25zdCBwID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCksIGcgPSBwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gZy5pbm5lckhUTUwgPSBoLCB0aGlzLl9zYW5pdGl6ZShwLCBnKSwgZy5pbm5lckhUTUw7XG4gICAgfSwgdC5wcm90b3R5cGUuX3Nhbml0aXplID0gZnVuY3Rpb24oaCwgcCkge1xuICAgICAgdmFyIGcgPSBhKGgsIHApLCBmID0gZy5maXJzdENoaWxkKCk7XG4gICAgICBpZiAoZilcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChmLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSlcbiAgICAgICAgICAgIGlmIChmLmRhdGEudHJpbSgpID09PSBcIlwiICYmIChmLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgaShmLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IGYubmV4dEVsZW1lbnRTaWJsaW5nICYmIGkoZi5uZXh0RWxlbWVudFNpYmxpbmcpKSkge1xuICAgICAgICAgICAgICBwLnJlbW92ZUNoaWxkKGYpLCB0aGlzLl9zYW5pdGl6ZShoLCBwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKGYubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBwLnJlbW92ZUNoaWxkKGYpLCB0aGlzLl9zYW5pdGl6ZShoLCBwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdiA9IHIoZiksIE87XG4gICAgICAgICAgdiAmJiAoTyA9IEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwoZi5jaGlsZE5vZGVzLCBpKSk7XG4gICAgICAgICAgdmFyIFQgPSAhIXAucGFyZW50Tm9kZSwgTSA9IGkocCkgJiYgaShmKSAmJiBULCBxID0gZi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBGID0gbCh0aGlzLmNvbmZpZywgcSwgZiksIEggPSB2ICYmIE87XG4gICAgICAgICAgaWYgKEggfHwgYyhmLCBGKSB8fCAhdGhpcy5jb25maWcua2VlcE5lc3RlZEJsb2NrRWxlbWVudHMgJiYgTSkge1xuICAgICAgICAgICAgaWYgKCEoZi5ub2RlTmFtZSA9PT0gXCJTQ1JJUFRcIiB8fCBmLm5vZGVOYW1lID09PSBcIlNUWUxFXCIpKVxuICAgICAgICAgICAgICBmb3IgKDsgZi5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7IClcbiAgICAgICAgICAgICAgICBwLmluc2VydEJlZm9yZShmLmNoaWxkTm9kZXNbMF0sIGYpO1xuICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgUSA9IDA7IFEgPCBmLmF0dHJpYnV0ZXMubGVuZ3RoOyBRICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBpZSA9IGYuYXR0cmlidXRlc1tRXTtcbiAgICAgICAgICAgIHUoaWUsIEYsIGYpICYmIChmLnJlbW92ZUF0dHJpYnV0ZShpZS5uYW1lKSwgUSA9IFEgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2FuaXRpemUoaCwgZik7XG4gICAgICAgIH0gd2hpbGUgKGYgPSBnLm5leHRTaWJsaW5nKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYShoLCBwKSB7XG4gICAgICByZXR1cm4gaC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICBwLFxuICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQsXG4gICAgICAgIG51bGwsXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsKGgsIHAsIGcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaC50YWdzW3BdID09IFwiZnVuY3Rpb25cIiA/IGgudGFnc1twXShnKSA6IGgudGFnc1twXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYyhoLCBwKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHAgPiBcInVcIiA/ICEwIDogdHlwZW9mIHAgPT0gXCJib29sZWFuXCIgPyAhcCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KGgsIHAsIGcpIHtcbiAgICAgIHZhciBmID0gaC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcCA9PT0gITAgPyAhMSA6IHR5cGVvZiBwW2ZdID09IFwiZnVuY3Rpb25cIiA/ICFwW2ZdKGgudmFsdWUsIGcpIDogdHlwZW9mIHBbZl0gPiBcInVcIiB8fCBwW2ZdID09PSAhMSA/ICEwIDogdHlwZW9mIHBbZl0gPT0gXCJzdHJpbmdcIiA/IHBbZl0gIT09IGgudmFsdWUgOiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH0pO1xufSkoWG8pO1xudmFyIFNpID0gWG8uZXhwb3J0cztcbmNvbnN0IElpID0gLyogQF9fUFVSRV9fICovIEtlKFNpKTtcbmZ1bmN0aW9uIHl0KG4sIGUpIHtcbiAgcmV0dXJuIG4ubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgbyA9IEEoZSkgPyBlKHQudG9vbCkgOiBlO1xuICAgIHJldHVybiBWKG8pIHx8ICh0LmRhdGEgPSB3dCh0LmRhdGEsIG8pKSwgdDtcbiAgfSk7XG59XG5mdW5jdGlvbiBaKG4sIGUgPSB7fSkge1xuICBjb25zdCB0ID0ge1xuICAgIHRhZ3M6IGVcbiAgfTtcbiAgcmV0dXJuIG5ldyBJaSh0KS5jbGVhbihuKTtcbn1cbmZ1bmN0aW9uIHd0KG4sIGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobikgPyBPaShuLCBlKSA6IEQobikgPyBfaShuLCBlKSA6IHRlKG4pID8gTWkobiwgZSkgOiBuO1xufVxuZnVuY3Rpb24gT2kobiwgZSkge1xuICByZXR1cm4gbi5tYXAoKHQpID0+IHd0KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIF9pKG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICBmb3IgKGNvbnN0IG8gaW4gbikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIG8pKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgaSA9IG5bb10sIHMgPSBBaShlW29dKSA/IGVbb10gOiBlO1xuICAgIHRbb10gPSB3dChpLCBzKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIE1pKG4sIGUpIHtcbiAgcmV0dXJuIEQoZSkgPyBaKG4sIGUpIDogZSA9PT0gITEgPyBaKG4sIHt9KSA6IG47XG59XG5mdW5jdGlvbiBBaShuKSB7XG4gIHJldHVybiBEKG4pIHx8IEduKG4pIHx8IEEobik7XG59XG5jbGFzcyBMaSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge1Nhbml0aXplckNvbmZpZ31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGVhbjogKGUsIHQpID0+IHRoaXMuY2xlYW4oZSwgdClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIHNhbml0aXppbmcgb2YgYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhaW50U3RyaW5nIC0gd2hhdCB0byBzYW5pdGl6ZVxuICAgKiBAcGFyYW0ge1Nhbml0aXplckNvbmZpZ30gY29uZmlnIC0gc2FuaXRpemVyIGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY2xlYW4oZSwgdCkge1xuICAgIHJldHVybiBaKGUsIHQpO1xuICB9XG59XG5jbGFzcyBQaSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge1NhdmVyfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhdmU6ICgpID0+IHRoaXMuc2F2ZSgpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEVkaXRvcidzIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBzYXZlKCkge1xuICAgIGNvbnN0IGUgPSBcIkVkaXRvcidzIGNvbnRlbnQgY2FuIG5vdCBiZSBzYXZlZCBpbiByZWFkLW9ubHkgbW9kZVwiO1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgPyAoWChlLCBcIndhcm5cIiksIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlKSkpIDogdGhpcy5FZGl0b3IuU2F2ZXIuc2F2ZSgpO1xuICB9XG59XG5jbGFzcyBOaSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnNlbGVjdGlvblV0aWxzID0gbmV3IGIoKTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge1NlbGVjdGlvbkFQSUludGVyZmFjZX1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaW5kUGFyZW50VGFnOiAoZSwgdCkgPT4gdGhpcy5maW5kUGFyZW50VGFnKGUsIHQpLFxuICAgICAgZXhwYW5kVG9UYWc6IChlKSA9PiB0aGlzLmV4cGFuZFRvVGFnKGUpLFxuICAgICAgc2F2ZTogKCkgPT4gdGhpcy5zZWxlY3Rpb25VdGlscy5zYXZlKCksXG4gICAgICByZXN0b3JlOiAoKSA9PiB0aGlzLnNlbGVjdGlvblV0aWxzLnJlc3RvcmUoKSxcbiAgICAgIHNldEZha2VCYWNrZ3JvdW5kOiAoKSA9PiB0aGlzLnNlbGVjdGlvblV0aWxzLnNldEZha2VCYWNrZ3JvdW5kKCksXG4gICAgICByZW1vdmVGYWtlQmFja2dyb3VuZDogKCkgPT4gdGhpcy5zZWxlY3Rpb25VdGlscy5yZW1vdmVGYWtlQmFja2dyb3VuZCgpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgYWhlYWQgZnJvbSBzZWxlY3Rpb24gYW5kIGZpbmQgcGFzc2VkIHRhZyB3aXRoIGNsYXNzIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgLSB0YWcgdG8gZmluZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gdGFnJ3MgY2xhc3MgbmFtZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZpbmRQYXJlbnRUYWcoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblV0aWxzLmZpbmRQYXJlbnRUYWcoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZCBzZWxlY3Rpb24gdG8gcGFzc2VkIHRhZ1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIC0gdGFnIHRoYXQgc2hvdWxkIGNvbnRhaW4gc2VsZWN0aW9uXG4gICAqL1xuICBleHBhbmRUb1RhZyhlKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25VdGlscy5leHBhbmRUb1RhZyhlKTtcbiAgfVxufVxuY2xhc3MgUmkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0QmxvY2tUb29sczogKCkgPT4gQXJyYXkuZnJvbSh0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLnZhbHVlcygpKVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIERpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBFeHBvcnRlZCBjbGFzc2VzXG4gICAqL1xuICBnZXQgY2xhc3NlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBCYXNlIEJsb2NrIHN0eWxlc1xuICAgICAgICovXG4gICAgICBibG9jazogXCJjZHgtYmxvY2tcIixcbiAgICAgIC8qKlxuICAgICAgICogSW5saW5lIFRvb2xzIHN0eWxlc1xuICAgICAgICovXG4gICAgICBpbmxpbmVUb29sQnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBpbmxpbmVUb29sQnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIC8qKlxuICAgICAgICogVUkgZWxlbWVudHNcbiAgICAgICAqL1xuICAgICAgaW5wdXQ6IFwiY2R4LWlucHV0XCIsXG4gICAgICBsb2FkZXI6IFwiY2R4LWxvYWRlclwiLFxuICAgICAgYnV0dG9uOiBcImNkeC1idXR0b25cIixcbiAgICAgIC8qKlxuICAgICAgICogU2V0dGluZ3Mgc3R5bGVzXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzQnV0dG9uOiBcImNkeC1zZXR0aW5ncy1idXR0b25cIixcbiAgICAgIHNldHRpbmdzQnV0dG9uQWN0aXZlOiBcImNkeC1zZXR0aW5ncy1idXR0b24tLWFjdGl2ZVwiXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgRmkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYmFyfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlOiAoKSA9PiB0aGlzLmNsb3NlKCksXG4gICAgICBvcGVuOiAoKSA9PiB0aGlzLm9wZW4oKSxcbiAgICAgIHRvZ2dsZUJsb2NrU2V0dGluZ3M6IChlKSA9PiB0aGlzLnRvZ2dsZUJsb2NrU2V0dGluZ3MoZSksXG4gICAgICB0b2dnbGVUb29sYm94OiAoZSkgPT4gdGhpcy50b2dnbGVUb29sYm94KGUpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3BlbiB0b29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdG9vbGJhciBhbmQgYWxsIGluY2x1ZGVkIGVsZW1lbnRzXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgQmxvY2sgU2V0dGluZyBvZiB0aGUgY3VycmVudCBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5pbmdTdGF0ZSDigJQgIG9wZW5pbmcgc3RhdGUgb2YgQmxvY2sgU2V0dGluZ1xuICAgKi9cbiAgdG9nZ2xlQmxvY2tTZXR0aW5ncyhlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCA9PT0gLTEpIHtcbiAgICAgIFgoXCJDb3VsZCd0IHRvZ2dsZSB0aGUgVG9vbGJhciBiZWNhdXNlIHRoZXJlIGlzIG5vIGJsb2NrIHNlbGVjdGVkIFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPz8gIXRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkID8gKHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuKCkpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHRvb2xib3hcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuaW5nU3RhdGUgLSBPcGVuaW5nIHN0YXRlIG9mIHRvb2xib3hcbiAgICovXG4gIHRvZ2dsZVRvb2xib3goZSkge1xuICAgIGlmICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICBYKFwiQ291bGQndCB0b2dnbGUgdGhlIFRvb2xib3ggYmVjYXVzZSB0aGVyZSBpcyBubyBibG9jayBzZWxlY3RlZCBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID8/ICF0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbmVkID8gKHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW4oKSkgOiB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3guY2xvc2UoKTtcbiAgfVxufVxudmFyIFZvID0geyBleHBvcnRzOiB7fSB9O1xuLyohXG4gKiBDb2RlWC5Ub29sdGlwc1xuICogXG4gKiBAdmVyc2lvbiAxLjAuNVxuICogXG4gKiBAbGljZW5jZSBNSVRcbiAqIEBhdXRob3IgQ29kZVggPGh0dHBzOi8vY29kZXguc28+XG4gKiBcbiAqIFxuICovXG4oZnVuY3Rpb24obiwgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIG4uZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBpZiAob1tzXSlcbiAgICAgICAgICByZXR1cm4gb1tzXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bc10gPSB7IGk6IHMsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtzXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihzLCByLCBhKSB7XG4gICAgICAgIGkubyhzLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBhIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAocyA9IGkocykpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGEpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBzIH0pLCAyICYgciAmJiB0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gcylcbiAgICAgICAgICAgIGkuZChhLCBsLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gc1tjXTtcbiAgICAgICAgICAgIH0pLmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHIgPSBzICYmIHMuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcik7XG4gICAgICB9LCBpLnAgPSBcIlwiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHQuZXhwb3J0cyA9IGkoMSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgaS5yKG8pLCBpLmQobywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0pO1xuICAgICAgY2xhc3MgcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSB7IHdyYXBwZXI6IG51bGwsIGNvbnRlbnQ6IG51bGwgfSwgdGhpcy5zaG93ZWQgPSAhMSwgdGhpcy5vZmZzZXRUb3AgPSAxMCwgdGhpcy5vZmZzZXRMZWZ0ID0gMTAsIHRoaXMub2Zmc2V0UmlnaHQgPSAxMCwgdGhpcy5oaWRpbmdEZWxheSA9IDAsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93ZWQgJiYgdGhpcy5oaWRlKCEwKTtcbiAgICAgICAgICB9LCB0aGlzLmxvYWRTdHlsZXMoKSwgdGhpcy5wcmVwYXJlKCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsLCB7IHBhc3NpdmU6ICEwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCBDU1MoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdG9vbHRpcDogXCJjdFwiLCB0b29sdGlwQ29udGVudDogXCJjdF9fY29udGVudFwiLCB0b29sdGlwU2hvd246IFwiY3QtLXNob3duXCIsIHBsYWNlbWVudDogeyBsZWZ0OiBcImN0LS1sZWZ0XCIsIGJvdHRvbTogXCJjdC0tYm90dG9tXCIsIHJpZ2h0OiBcImN0LS1yaWdodFwiLCB0b3A6IFwiY3QtLXRvcFwiIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBzaG93KGEsIGwsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgfHwgdGhpcy5wcmVwYXJlKCksIHRoaXMuaGlkaW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5oaWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICBjb25zdCB1ID0gT2JqZWN0LmFzc2lnbih7IHBsYWNlbWVudDogXCJib3R0b21cIiwgbWFyZ2luVG9wOiAwLCBtYXJnaW5MZWZ0OiAwLCBtYXJnaW5SaWdodDogMCwgbWFyZ2luQm90dG9tOiAwLCBkZWxheTogNzAsIGhpZGluZ0RlbGF5OiAwIH0sIGMpO1xuICAgICAgICAgIGlmICh1LmhpZGluZ0RlbGF5ICYmICh0aGlzLmhpZGluZ0RlbGF5ID0gdS5oaWRpbmdEZWxheSksIHRoaXMubm9kZXMuY29udGVudC5pbm5lckhUTUwgPSBcIlwiLCB0eXBlb2YgbCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGwgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbQ29kZVggVG9vbHRpcF0gV3JvbmcgdHlwZSBvZiDCq2NvbnRlbnTCuyBwYXNzZWQuIEl0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlIG9yIFN0cmluZy4gQnV0IFwiICsgdHlwZW9mIGwgKyBcIiBnaXZlbi5cIik7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoLi4uT2JqZWN0LnZhbHVlcyh0aGlzLkNTUy5wbGFjZW1lbnQpKSwgdS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVRvcChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICB0aGlzLnBsYWNlTGVmdChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVJpZ2h0KGEsIHUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VCb3R0b20oYSwgdSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUgJiYgdS5kZWxheSA/IHRoaXMuc2hvd2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITA7XG4gICAgICAgICAgfSwgdS5kZWxheSkgOiAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MudG9vbHRpcFNob3duKSwgdGhpcy5zaG93ZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZShhID0gITEpIHtcbiAgICAgICAgICBpZiAodGhpcy5oaWRpbmdEZWxheSAmJiAhYSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkaW5nVGltZW91dCksIHZvaWQgKHRoaXMuaGlkaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoITApO1xuICAgICAgICAgICAgfSwgdGhpcy5oaWRpbmdEZWxheSkpO1xuICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITEsIHRoaXMuc2hvd2luZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd2luZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIG9uSG92ZXIoYSwgbCwgYykge1xuICAgICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93KGEsIGwsIGMpO1xuICAgICAgICAgIH0pLCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyLnJlbW92ZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZSgpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSB0aGlzLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbHRpcCksIHRoaXMubm9kZXMuY29udGVudCA9IHRoaXMubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sdGlwQ29udGVudCksIHRoaXMuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgdGhpcy5hcHBlbmQoZG9jdW1lbnQuYm9keSwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkU3R5bGVzKCkge1xuICAgICAgICAgIGNvbnN0IGEgPSBcImNvZGV4LXRvb2x0aXBzLXN0eWxlXCI7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGwgPSBpKDIpLCBjID0gdGhpcy5tYWtlKFwic3R5bGVcIiwgbnVsbCwgeyB0ZXh0Q29udGVudDogbC50b1N0cmluZygpLCBpZDogYSB9KTtcbiAgICAgICAgICB0aGlzLnByZXBlbmQoZG9jdW1lbnQuaGVhZCwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VCb3R0b20oYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgYS5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQgKyB0aGlzLm9mZnNldFRvcCArIGwubWFyZ2luVG9wO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJib3R0b21cIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VUb3AoYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgYS5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLm5vZGVzLndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gdGhpcy5vZmZzZXRUb3A7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInRvcFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZUxlZnQoYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0IC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC0gdGhpcy5vZmZzZXRMZWZ0IC0gbC5tYXJnaW5MZWZ0LCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyBhLmNsaWVudEhlaWdodCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KFwibGVmdFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZVJpZ2h0KGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMucmlnaHQgKyB0aGlzLm9mZnNldFJpZ2h0ICsgbC5tYXJnaW5SaWdodCwgaCA9IGMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgYS5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInJpZ2h0XCIsIHUsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5UGxhY2VtZW50KGEsIGwsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5wbGFjZW1lbnRbYV0pLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IGwgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBjICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIG1ha2UoYSwgbCA9IG51bGwsIGMgPSB7fSkge1xuICAgICAgICAgIGNvbnN0IHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGEpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkobCkgPyB1LmNsYXNzTGlzdC5hZGQoLi4ubCkgOiBsICYmIHUuY2xhc3NMaXN0LmFkZChsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGggaW4gYylcbiAgICAgICAgICAgIGMuaGFzT3duUHJvcGVydHkoaCkgJiYgKHVbaF0gPSBjW2hdKTtcbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoYSwgbCkge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkobCkgPyBsLmZvckVhY2goKGMpID0+IGEuYXBwZW5kQ2hpbGQoYykpIDogYS5hcHBlbmRDaGlsZChsKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwZW5kKGEsIGwpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gKGwgPSBsLnJldmVyc2UoKSkuZm9yRWFjaCgoYykgPT4gYS5wcmVwZW5kKGMpKSA6IGEucHJlcGVuZChsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHQsIG8pIHtcbiAgICAgIHQuZXhwb3J0cyA9IGAuY3R7ei1pbmRleDo5OTk7b3BhY2l0eTowOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDUwbXMgZWFzZS1pbiwtd2Via2l0LXRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLHRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSksLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRvcCxsZWZ0Oy13ZWJraXQtYm94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym9yZGVyLXJhZGl1czo5cHh9LmN0LC5jdDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowfS5jdDpiZWZvcmV7Y29udGVudDpcIlwiO2JvdHRvbTowO3JpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojMWQyMDJiO3otaW5kZXg6LTE7Ym9yZGVyLXJhZGl1czo0cHh9QHN1cHBvcnRzKC13ZWJraXQtbWFzay1ib3gtaW1hZ2U6dXJsKFwiXCIpKXsuY3Q6YmVmb3Jle2JvcmRlci1yYWRpdXM6MDstd2Via2l0LW1hc2stYm94LWltYWdlOnVybCgnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+PHBhdGggZD1cIk0xMC43MSAwaDIuNThjMy4wMiAwIDQuNjQuNDIgNi4xIDEuMmE4LjE4IDguMTggMCAwMTMuNCAzLjRDMjMuNiA2LjA3IDI0IDcuNyAyNCAxMC43MXYyLjU4YzAgMy4wMi0uNDIgNC42NC0xLjIgNi4xYTguMTggOC4xOCAwIDAxLTMuNCAzLjRjLTEuNDcuOC0zLjEgMS4yMS02LjExIDEuMjFIMTAuN2MtMy4wMiAwLTQuNjQtLjQyLTYuMS0xLjJhOC4xOCA4LjE4IDAgMDEtMy40LTMuNEMuNCAxNy45MyAwIDE2LjMgMCAxMy4yOVYxMC43YzAtMy4wMi40Mi00LjY0IDEuMi02LjFhOC4xOCA4LjE4IDAgMDEzLjQtMy40QzYuMDcuNCA3LjcgMCAxMC43MSAwelwiLz48L3N2Zz4nKSA0OCUgNDElIDM3LjklIDUzLjMlfX1AbWVkaWEgKC0tbW9iaWxlKXsuY3R7ZGlzcGxheTpub25lfX0uY3RfX2NvbnRlbnR7cGFkZGluZzo2cHggMTBweDtjb2xvcjojY2RkMWUwO2ZvbnQtc2l6ZToxMnB4O3RleHQtYWxpZ246Y2VudGVyO2xldHRlci1zcGFjaW5nOi4wMmVtO2xpbmUtaGVpZ2h0OjFlbX0uY3Q6YWZ0ZXJ7Y29udGVudDpcIlwiO3dpZHRoOjhweDtoZWlnaHQ6OHB4O3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6IzFkMjAyYjt6LWluZGV4Oi0xfS5jdC0tYm90dG9tey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg1cHgpfS5jdC0tYm90dG9tOmFmdGVye3RvcDotM3B4O2xlZnQ6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyl9LmN0LS10b3B7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KX0uY3QtLXRvcDphZnRlcnt0b3A6YXV0bztib3R0b206LTNweDtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tbGVmdHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpfS5jdC0tbGVmdDphZnRlcnt0b3A6NTAlO2xlZnQ6YXV0bztyaWdodDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSg0MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlKDQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCg1cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDVweCl9LmN0LS1yaWdodDphZnRlcnt0b3A6NTAlO2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tc2hvd257b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOm5vbmU7dHJhbnNmb3JtOm5vbmV9YDtcbiAgICB9XSkuZGVmYXVsdDtcbiAgfSk7XG59KShWbyk7XG52YXIgamkgPSBWby5leHBvcnRzO1xuY29uc3QgSGkgPSAvKiBAX19QVVJFX18gKi8gS2UoamkpO1xubGV0IFUgPSBudWxsO1xuZnVuY3Rpb24gRXQoKSB7XG4gIFUgfHwgKFUgPSBuZXcgSGkoKSk7XG59XG5mdW5jdGlvbiAkaShuLCBlLCB0KSB7XG4gIEV0KCksIFUgPT0gbnVsbCB8fCBVLnNob3cobiwgZSwgdCk7XG59XG5mdW5jdGlvbiAkZShuID0gITEpIHtcbiAgRXQoKSwgVSA9PSBudWxsIHx8IFUuaGlkZShuKTtcbn1cbmZ1bmN0aW9uIHplKG4sIGUsIHQpIHtcbiAgRXQoKSwgVSA9PSBudWxsIHx8IFUub25Ib3ZlcihuLCBlLCB0KTtcbn1cbmZ1bmN0aW9uIHppKCkge1xuICBVID09IG51bGwgfHwgVS5kZXN0cm95KCksIFUgPSBudWxsO1xufVxuY2xhc3MgVWkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93OiAoZSwgdCwgbykgPT4gdGhpcy5zaG93KGUsIHQsIG8pLFxuICAgICAgaGlkZTogKCkgPT4gdGhpcy5oaWRlKCksXG4gICAgICBvbkhvdmVyOiAoZSwgdCwgbykgPT4gdGhpcy5vbkhvdmVyKGUsIHQsIG8pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHNob3cgdG9vbHRpcCBvbiBlbGVtZW50IHdpdGggcGFzc2VkIEhUTUwgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCBvbiB3aGljaCB0b29sdGlwIHNob3VsZCBiZSBzaG93blxuICAgKiBAcGFyYW0ge1Rvb2x0aXBDb250ZW50fSBjb250ZW50IC0gdG9vbHRpcCBjb250ZW50XG4gICAqIEBwYXJhbSB7VG9vbHRpcE9wdGlvbnN9IG9wdGlvbnMgLSB0b29sdGlwIG9wdGlvbnNcbiAgICovXG4gIHNob3coZSwgdCwgbykge1xuICAgICRpKGUsIHQsIG8pO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgaGlkZXMgdG9vbHRpcCBvbiBIVE1MIHBhZ2VcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgJGUoKTtcbiAgfVxuICAvKipcbiAgICogRGVjb3JhdG9yIGZvciBzaG93aW5nIFRvb2x0aXAgYnkgbW91c2VlbnRlci9tb3VzZWxlYXZlXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IG9uIHdoaWNoIHRvb2x0aXAgc2hvdWxkIGJlIHNob3duXG4gICAqIEBwYXJhbSB7VG9vbHRpcENvbnRlbnR9IGNvbnRlbnQgLSB0b29sdGlwIGNvbnRlbnRcbiAgICogQHBhcmFtIHtUb29sdGlwT3B0aW9uc30gb3B0aW9ucyAtIHRvb2x0aXAgb3B0aW9uc1xuICAgKi9cbiAgb25Ib3ZlcihlLCB0LCBvKSB7XG4gICAgemUoZSwgdCwgbyk7XG4gIH1cbn1cbmNsYXNzIFdpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kcyAvIGdldHRlcnNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlczogdGhpcy5lZGl0b3JOb2Rlc1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBjYW4gYmUgYWRkZWQgc29tZSBVSSBtZXRob2RzLCBsaWtlIHRvZ2dsZVRoaW5Nb2RlKCkgZXRjXG4gICAgICAgKi9cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeHBvcnRlZCBjbGFzc2VzXG4gICAqL1xuICBnZXQgZWRpdG9yTm9kZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVG9wLWxldmVsIGVkaXRvciBpbnN0YW5jZSB3cmFwcGVyXG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXI6IHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIsXG4gICAgICAvKipcbiAgICAgICAqIEVsZW1lbnQgdGhhdCBob2xkcyBhbGwgdGhlIEJsb2Nrc1xuICAgICAgICovXG4gICAgICByZWRhY3RvcjogdGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3JcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBxbyhuLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG4pLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgIGlmIChEKGkpKSB7XG4gICAgICBjb25zdCBzID0gZSA/IGAke2V9LiR7b31gIDogbztcbiAgICAgIE9iamVjdC52YWx1ZXMoaSkuZXZlcnkoKGEpID0+IHRlKGEpKSA/IHRbb10gPSBzIDogdFtvXSA9IHFvKGksIHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0W29dID0gaTtcbiAgfSksIHQ7XG59XG5jb25zdCBLID0gcW8oRm8pO1xuZnVuY3Rpb24gWWkobiwgZSkge1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgY29uc3QgaSA9IGVbb107XG4gICAgaSAhPT0gdm9pZCAwID8gdFtpXSA9IG5bb10gOiB0W29dID0gbltvXTtcbiAgfSksIHQ7XG59XG5jb25zdCBabyA9IGNsYXNzIEVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gbm9kZUxpc3Qg4oCUIHRoZSBsaXN0IG9mIGl0ZXJhYmxlIEhUTUwtaXRlbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvY3VzZWRDc3NDbGFzcyAtIHVzZXItcHJvdmlkZWQgQ1NTLWNsYXNzIHRoYXQgd2lsbCBiZSBzZXQgaW4gZmxpcHBpbmcgcHJvY2Vzc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuY3Vyc29yID0gLTEsIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5pdGVtcyA9IGUgfHwgW10sIHRoaXMuZm9jdXNlZENzc0NsYXNzID0gdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBGb2N1c2VkIGJ1dHRvbiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBjdXJyZW50SXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IgPT09IC0xID8gbnVsbCA6IHRoaXMuaXRlbXNbdGhpcy5jdXJzb3JdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciB0byBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIGN1cnNvclBvc2l0aW9uIC0gbmV3IGN1cnNvciBwb3NpdGlvblxuICAgKi9cbiAgc2V0Q3Vyc29yKGUpIHtcbiAgICBlIDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgZSA+PSAtMSAmJiAodGhpcy5kcm9wQ3Vyc29yKCksIHRoaXMuY3Vyc29yID0gZSwgdGhpcy5pdGVtc1t0aGlzLmN1cnNvcl0uY2xhc3NMaXN0LmFkZCh0aGlzLmZvY3VzZWRDc3NDbGFzcykpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGl0ZW1zLiBDYW4gYmUgdXNlZCB3aGVuIGl0ZXJhYmxlIGl0ZW1zIGNoYW5nZWQgZHluYW1pY2FsbHlcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBub2RlTGlzdCAtIG5vZGVzIHRvIGl0ZXJhdGVcbiAgICovXG4gIHNldEl0ZW1zKGUpIHtcbiAgICB0aGlzLml0ZW1zID0gZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgbmV4dCB0byB0aGUgY3VycmVudFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMubGVhZk5vZGVzQW5kUmV0dXJuSW5kZXgoRWUuZGlyZWN0aW9ucy5SSUdIVCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIGJlZm9yZSBjdXJyZW50XG4gICAqL1xuICBwcmV2aW91cygpIHtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMubGVhZk5vZGVzQW5kUmV0dXJuSW5kZXgoRWUuZGlyZWN0aW9ucy5MRUZUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24gYW5kIHJlbW92ZXMgQ1NTLWNsYXNzIGZyb20gcHJldmlvdXNseSBmb2N1c2VkIGl0ZW1cbiAgICovXG4gIGRyb3BDdXJzb3IoKSB7XG4gICAgdGhpcy5jdXJzb3IgIT09IC0xICYmICh0aGlzLml0ZW1zW3RoaXMuY3Vyc29yXS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZm9jdXNlZENzc0NsYXNzKSwgdGhpcy5jdXJzb3IgPSAtMSk7XG4gIH1cbiAgLyoqXG4gICAqIExlYWZzIG5vZGVzIGluc2lkZSB0aGUgdGFyZ2V0IGxpc3QgZnJvbSBhY3RpdmUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIC0gbGVhZiBkaXJlY3Rpb24uIENhbiBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCBvZiBmb2N1c2VkIG5vZGVcbiAgICovXG4gIGxlYWZOb2Rlc0FuZFJldHVybkluZGV4KGUpIHtcbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3I7XG4gICAgbGV0IHQgPSB0aGlzLmN1cnNvcjtcbiAgICByZXR1cm4gdCA9PT0gLTEgPyB0ID0gZSA9PT0gRWUuZGlyZWN0aW9ucy5SSUdIVCA/IC0xIDogMCA6IHRoaXMuaXRlbXNbdF0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIGUgPT09IEVlLmRpcmVjdGlvbnMuUklHSFQgPyB0ID0gKHQgKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoIDogdCA9ICh0aGlzLml0ZW1zLmxlbmd0aCArIHQgLSAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoLCBkLmNhblNldENhcmV0KHRoaXMuaXRlbXNbdF0pICYmIEZlKCgpID0+IGIuc2V0Q3Vyc29yKHRoaXMuaXRlbXNbdF0pLCA1MCkoKSwgdGhpcy5pdGVtc1t0XS5jbGFzc0xpc3QuYWRkKHRoaXMuZm9jdXNlZENzc0NsYXNzKSwgdDtcbiAgfVxufTtcblpvLmRpcmVjdGlvbnMgPSB7XG4gIFJJR0hUOiBcInJpZ2h0XCIsXG4gIExFRlQ6IFwibGVmdFwiXG59O1xubGV0IGtlID0gWm87XG5jbGFzcyBjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGRpZmZlcmVudCBjb25zdHJ1Y3Rpbmcgc2V0dGluZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLml0ZXJhdG9yID0gbnVsbCwgdGhpcy5hY3RpdmF0ZWQgPSAhMSwgdGhpcy5mbGlwQ2FsbGJhY2tzID0gW10sIHRoaXMub25LZXlEb3duID0gKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzRXZlbnRSZWFkeUZvckhhbmRsaW5nKHQpKVxuICAgICAgICBzd2l0Y2ggKGNlLnVzZWRLZXlzLmluY2x1ZGVzKHQua2V5Q29kZSkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIHkuVEFCOlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJQcmVzcyh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgeS5MRUZUOlxuICAgICAgICAgIGNhc2UgeS5VUDpcbiAgICAgICAgICAgIHRoaXMuZmxpcExlZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgeS5SSUdIVDpcbiAgICAgICAgICBjYXNlIHkuRE9XTjpcbiAgICAgICAgICAgIHRoaXMuZmxpcFJpZ2h0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHkuRU5URVI6XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVudGVyUHJlc3ModCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIHRoaXMuaXRlcmF0b3IgPSBuZXcga2UoZS5pdGVtcywgZS5mb2N1c2VkSXRlbUNsYXNzKSwgdGhpcy5hY3RpdmF0ZUNhbGxiYWNrID0gZS5hY3RpdmF0ZUNhbGxiYWNrLCB0aGlzLmFsbG93ZWRLZXlzID0gZS5hbGxvd2VkS2V5cyB8fCBjZS51c2VkS2V5cztcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBmbGlwcGVyIGlzIGN1cnJlbnRseSBhY3RpdmF0ZWRcbiAgICovXG4gIGdldCBpc0FjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEFycmF5IG9mIGtleXMgKGNvZGVzKSB0aGF0IGlzIGhhbmRsZWQgYnkgRmxpcHBlclxuICAgKiBVc2VkIHRvOlxuICAgKiAgLSBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciB0aGlzIGtleXMsIG5vdCBhbGwga2V5ZG93bnMgKEBzZWUgY29uc3RydWN0b3IpXG4gICAqICAtIHRvIHNraXAgZXh0ZXJuYWwgYmVoYXZpb3VycyBvbmx5IGZvciB0aGVzZSBrZXlzLCB3aGVuIGZpbGxlciBpcyBhY3RpdmF0ZWQgKEBzZWUgQmxvY2tFdmVudHNAYXJyb3dSaWdodEFuZERvd24pXG4gICAqL1xuICBzdGF0aWMgZ2V0IHVzZWRLZXlzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB5LlRBQixcbiAgICAgIHkuTEVGVCxcbiAgICAgIHkuUklHSFQsXG4gICAgICB5LkVOVEVSLFxuICAgICAgeS5VUCxcbiAgICAgIHkuRE9XTlxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2ZSB0YWIvYXJyb3dzIGhhbmRsaW5nIGJ5IGZsaXBwZXJcbiAgICpcbiAgICogQHBhcmFtIGl0ZW1zIC0gU29tZSBtb2R1bGVzIChsaWtlLCBJbmxpbmVUb29sYmFyLCBCbG9ja1NldHRpbmdzKSBtaWdodCByZWZyZXNoIGJ1dHRvbnMgZHluYW1pY2FsbHlcbiAgICogQHBhcmFtIGN1cnNvclBvc2l0aW9uIC0gaW5kZXggb2YgdGhlIGl0ZW0gdGhhdCBzaG91bGQgYmUgZm9jdXNlZCBvbmNlIGZsaXBwZXIgaXMgYWN0aXZhdGVkXG4gICAqL1xuICBhY3RpdmF0ZShlLCB0KSB7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSAhMCwgZSAmJiB0aGlzLml0ZXJhdG9yLnNldEl0ZW1zKGUpLCB0ICE9PSB2b2lkIDAgJiYgdGhpcy5pdGVyYXRvci5zZXRDdXJzb3IodCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgdGFiL2Fycm93cyBoYW5kbGluZyBieSBmbGlwcGVyXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWN0aXZhdGVkID0gITEsIHRoaXMuZHJvcEN1cnNvcigpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93bik7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIGZpcnN0IGl0ZW1cbiAgICovXG4gIGZvY3VzRmlyc3QoKSB7XG4gICAgdGhpcy5kcm9wQ3Vyc29yKCksIHRoaXMuZmxpcFJpZ2h0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzZXMgcHJldmlvdXMgZmxpcHBlciBpdGVyYXRvciBpdGVtXG4gICAqL1xuICBmbGlwTGVmdCgpIHtcbiAgICB0aGlzLml0ZXJhdG9yLnByZXZpb3VzKCksIHRoaXMuZmxpcENhbGxiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzZXMgbmV4dCBmbGlwcGVyIGl0ZXJhdG9yIGl0ZW1cbiAgICovXG4gIGZsaXBSaWdodCgpIHtcbiAgICB0aGlzLml0ZXJhdG9yLm5leHQoKSwgdGhpcy5mbGlwQ2FsbGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgc29tZSBidXR0b24gaXMgZm9jdXNlZFxuICAgKi9cbiAgaGFzRm9jdXMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJlcyBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBvbiBlYWNoIG5hdmlnYXRpb24gYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjYiAtIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIG9uRmxpcChlKSB7XG4gICAgdGhpcy5mbGlwQ2FsbGJhY2tzLnB1c2goZSk7XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXJlcyBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIG9uIGVhY2ggbmF2aWdhdGlvbiBhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGNiIC0gZnVuY3Rpb24gdG8gc3RvcCBleGVjdXRpbmdcbiAgICovXG4gIHJlbW92ZU9uRmxpcChlKSB7XG4gICAgdGhpcy5mbGlwQ2FsbGJhY2tzID0gdGhpcy5mbGlwQ2FsbGJhY2tzLmZpbHRlcigodCkgPT4gdCAhPT0gZSk7XG4gIH1cbiAgLyoqXG4gICAqIERyb3BzIGZsaXBwZXIncyBpdGVyYXRvciBjdXJzb3JcbiAgICpcbiAgICogQHNlZSBEb21JdGVyYXRvciNkcm9wQ3Vyc29yXG4gICAqL1xuICBkcm9wQ3Vyc29yKCkge1xuICAgIHRoaXMuaXRlcmF0b3IuZHJvcEN1cnNvcigpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZpcmVkIGJlZm9yZSBoYW5kbGluZyBmbGlwcGVyIGtleWNvZGVzXG4gICAqIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBkZWZpbmVzIGlmIGl0IGlzIG5lZWQgdG8gYmUgaGFuZGxlZCBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd24ga2V5Ym9hcmQgZXZlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0V2ZW50UmVhZHlGb3JIYW5kbGluZyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkICYmIHRoaXMuYWxsb3dlZEtleXMuaW5jbHVkZXMoZS5rZXlDb2RlKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiBmbGlwcGVyIGlzIGFjdGl2YXRlZCB0YWIgcHJlc3Mgd2lsbCBsZWFmIHRoZSBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gdGFiIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGhhbmRsZVRhYlByZXNzKGUpIHtcbiAgICBzd2l0Y2ggKGUuc2hpZnRLZXkgPyBrZS5kaXJlY3Rpb25zLkxFRlQgOiBrZS5kaXJlY3Rpb25zLlJJR0hUKSB7XG4gICAgICBjYXNlIGtlLmRpcmVjdGlvbnMuUklHSFQ6XG4gICAgICAgIHRoaXMuZmxpcFJpZ2h0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBrZS5kaXJlY3Rpb25zLkxFRlQ6XG4gICAgICAgIHRoaXMuZmxpcExlZnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbnRlciBwcmVzcyB3aWxsIGNsaWNrIGN1cnJlbnQgaXRlbSBpZiBmbGlwcGVyIGlzIGFjdGl2YXRlZFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gZW50ZXIga2V5ZG93biBldmVudFxuICAgKi9cbiAgaGFuZGxlRW50ZXJQcmVzcyhlKSB7XG4gICAgdGhpcy5hY3RpdmF0ZWQgJiYgKHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0gJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbS5jbGljaygpKSwgQSh0aGlzLmFjdGl2YXRlQ2FsbGJhY2spICYmIHRoaXMuYWN0aXZhdGVDYWxsYmFjayh0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVkIGFmdGVyIGZsaXBwaW5nIGluIGFueSBkaXJlY3Rpb25cbiAgICovXG4gIGZsaXBDYWxsYmFjaygpIHtcbiAgICB0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtICYmIHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0uc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpLCB0aGlzLmZsaXBDYWxsYmFja3MuZm9yRWFjaCgoZSkgPT4gZSgpKTtcbiAgfVxufVxuY29uc3QgS2kgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgMTJMOSA3LjFDOSA3LjA0NDc3IDkuMDQ0NzcgNyA5LjEgN0gxMC40QzExLjUgNyAxNCA3LjEgMTQgOS41QzE0IDkuNSAxNCAxMiAxMSAxMk05IDEyVjE2LjhDOSAxNi45MTA1IDkuMDg5NTQgMTcgOS4yIDE3SDEyLjVDMTQgMTcgMTUgMTYgMTUgMTQuNUMxNSAxMS43MDQ2IDExIDEyIDExIDEyTTkgMTJIMTFcIi8+PC9zdmc+JywgWGkgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcgMTBMMTEuODU4NiAxNC44NTg2QzExLjkzNjcgMTQuOTM2NyAxMi4wNjMzIDE0LjkzNjcgMTIuMTQxNCAxNC44NTg2TDE3IDEwXCIvPjwvc3ZnPicsIFZpID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC41IDE3LjVMOS42NDE0MiAxMi42NDE0QzkuNTYzMzEgMTIuNTYzMyA5LjU2MzMxIDEyLjQzNjcgOS42NDE0MiAxMi4zNTg2TDE0LjUgNy41XCIvPjwvc3ZnPicsIHFpID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjU4Mjg0IDE3LjVMMTQuNDQxNCAxMi42NDE0QzE0LjUxOTUgMTIuNTYzMyAxNC41MTk1IDEyLjQzNjcgMTQuNDQxNCAxMi4zNTg2TDkuNTgyODQgNy41XCIvPjwvc3ZnPicsIFppID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDE1TDExLjg1ODYgMTAuMTQxNEMxMS45MzY3IDEwLjA2MzMgMTIuMDYzMyAxMC4wNjMzIDEyLjE0MTQgMTAuMTQxNEwxNyAxNVwiLz48L3N2Zz4nLCBHaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA4TDEyIDEyTTEyIDEyTDE2IDE2TTEyIDEyTDE2IDhNMTIgMTJMOCAxNlwiLz48L3N2Zz4nLCBRaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPicsIEppID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMy4zNCAxMEMxMi40MjIzIDEyLjczMzcgMTEgMTcgMTEgMTdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0LjIxIDdIMTQuMlwiLz48L3N2Zz4nLCBDbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNy42OTk5OCAxMi42TDcuNjc4OTYgMTIuNjJDNi41Mzk5MyAxMy43MDQ4IDYuNTIwMTIgMTUuNTE1NSA3LjYzNTE2IDE2LjYyNVYxNi42MjVDOC43MjI5MyAxNy43MDczIDEwLjQ3OTkgMTcuNzEwMiAxMS41NzEyIDE2LjYzMTRMMTMuMDI2MyAxNS4xOTNDMTQuMDcwMyAxNC4xNjA5IDE0LjIxNDEgMTIuNTI1IDEzLjM2NjIgMTEuMzI2NkwxMy4yMiAxMS4xMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYuMjIgMTEuMTJMMTYuMzU2NCAxMC45ODA1QzE3LjI4OTUgMTAuMDI2NSAxNy4zNDc4IDguNTIwNyAxNi40OTE0IDcuNDk3MzNWNy40OTczM0MxNS41NjkxIDYuMzk1MDkgMTMuOTI2OSA2LjI1MTQzIDEyLjgyNzEgNy4xNzY3NUwxMS4zOTAxIDguMzg1ODhDMTAuMDkzNSA5LjQ3Njc0IDkuOTU3MDYgMTEuNDI0MSAxMS4wODg4IDEyLjY4NTJMMTEuMTIgMTIuNzJcIi8+PC9zdmc+JywgZXMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS40MDk5OSA3LjI5OTk5SDkuNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk0xNC42IDcuMjk5OTlIMTQuNTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS4zMDk5OSAxMkg5LjNcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiAxMkgxNC41OVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk05LjQwOTk5IDE2LjdIOS40XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTYuN0gxNC41OVwiLz48L3N2Zz4nLCB0cyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTIgN1YxMk0xMiAxN1YxMk0xNyAxMkgxMk0xMiAxMkg3XCIvPjwvc3ZnPicsIEdvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMS41IDE3LjVMNSAxMU01IDExVjE1LjVNNSAxMUg5LjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyLjUgNi41TDE5IDEzTTE5IDEzVjguNU0xOSAxM0gxNC41XCIvPjwvc3ZnPicsIG9zID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxjaXJjbGUgY3g9XCIxMC41XCIgY3k9XCIxMC41XCIgcj1cIjUuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxNS40MTQyXCIgeDI9XCIxOVwiIHkxPVwiMTVcIiB5Mj1cIjE4LjU4NThcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nLCBucyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTUuNzc5NSAxMS41QzE1Ljc3OTUgMTEuNSAxNi4wNTMgMTEuMTk2MiAxNi41NDk3IDEwLjY3MjJDMTcuNDQ0MiA5LjcyODU2IDE3LjQ3MDEgOC4yNDc1IDE2LjU3ODEgNy4zMDE0NVY3LjMwMTQ1QzE1LjY0ODIgNi4zMTUyMiAxNC4wODczIDYuMjkyMjcgMTMuMTI4OCA3LjI1MDczTDExLjg3OTYgOC40OTk5OVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOC4yNDUxNyAxMi4zODgzQzguMjQ1MTcgMTIuMzg4MyA3Ljk3MTcxIDEyLjY5MjIgNy40NzUwNCAxMy4yMTYxQzYuNTgwNTEgMTQuMTU5OCA2LjU1NDY3IDE1LjY0MDggNy40NDY2NiAxNi41ODY5VjE2LjU4NjlDOC4zNzY1MyAxNy41NzMxIDkuOTM3NDQgMTcuNTk2MSAxMC44OTU5IDE2LjYzNzZMMTIuMTQ1MiAxNS4zODgzXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNy43ODAyIDE1LjEwMzJMMTYuNTk3IDE0Ljk0MjJDMTYuMDEwOSAxNC44NjI0IDE1LjQ4NDEgMTUuMzA1OSAxNS40NjI3IDE1Ljg5NjlMMTUuNDE5OSAxNy4wODE4XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02LjM5MDY0IDkuMDMyMzhMNy41ODQzMiA5LjA2NjY4QzguMTc1NTEgOS4wODM2NiA4LjY1MjIgOC41ODY2NSA4LjYxMDU2IDcuOTk2NjlMOC41MjcxIDYuODEzOTdcIi8+PGxpbmUgeDE9XCIxMi4xMTQyXCIgeDI9XCIxMS43XCIgeTE9XCIxMi4yXCIgeTI9XCIxMS43ODU4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+JywgaXMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTJcIiB5MT1cIjlcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDE1LjAyVjE1LjAxXCIvPjwvc3ZnPicsIHNzID0gXCJfX1wiLCBycyA9IFwiLS1cIjtcbmZ1bmN0aW9uIG5lKG4pIHtcbiAgcmV0dXJuIChlLCB0KSA9PiBbW24sIGVdLmZpbHRlcigoaSkgPT4gISFpKS5qb2luKHNzKSwgdF0uZmlsdGVyKChpKSA9PiAhIWkpLmpvaW4ocnMpO1xufVxuY29uc3QgeWUgPSBuZShcImNlLWhpbnRcIiksIHdlID0ge1xuICByb290OiB5ZSgpLFxuICBhbGlnbmVkU3RhcnQ6IHllKG51bGwsIFwiYWxpZ24tbGVmdFwiKSxcbiAgYWxpZ25lZENlbnRlcjogeWUobnVsbCwgXCJhbGlnbi1jZW50ZXJcIiksXG4gIHRpdGxlOiB5ZShcInRpdGxlXCIpLFxuICBkZXNjcmlwdGlvbjogeWUoXCJkZXNjcmlwdGlvblwiKVxufTtcbmNsYXNzIGFzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGhpbnQgY29udGVudCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gaGludCBjb250ZW50IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm5vZGVzID0ge1xuICAgICAgcm9vdDogZC5tYWtlKFwiZGl2XCIsIFt3ZS5yb290LCBlLmFsaWdubWVudCA9PT0gXCJjZW50ZXJcIiA/IHdlLmFsaWduZWRDZW50ZXIgOiB3ZS5hbGlnbmVkU3RhcnRdKSxcbiAgICAgIHRpdGxlOiBkLm1ha2UoXCJkaXZcIiwgd2UudGl0bGUsIHsgdGV4dENvbnRlbnQ6IGUudGl0bGUgfSlcbiAgICB9LCB0aGlzLm5vZGVzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy50aXRsZSksIGUuZGVzY3JpcHRpb24gIT09IHZvaWQgMCAmJiAodGhpcy5ub2Rlcy5kZXNjcmlwdGlvbiA9IGQubWFrZShcImRpdlwiLCB3ZS5kZXNjcmlwdGlvbiwgeyB0ZXh0Q29udGVudDogZS5kZXNjcmlwdGlvbiB9KSwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMuZGVzY3JpcHRpb24pKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBoaW50IGNvbnRlbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxufVxuY2xhc3MgeHQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIGluc3RhbmNlIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnBhcmFtcyA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZW0gbmFtZSBpZiBleGlzdHNcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIGlmICh0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwibmFtZVwiIGluIHRoaXMucGFyYW1zKVxuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICAkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjaGlsZHJlbiBwb3BvdmVyIGlzIG9wZW5lZCAoaWYgZXhpc3RzKVxuICAgKi9cbiAgb25DaGlsZHJlbk9wZW4oKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMgJiYgdHlwZW9mICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5vbk9wZW4pID09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLnBhcmFtcy5jaGlsZHJlbi5vbk9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gY2hpbGRyZW4gcG9wb3ZlciBpcyBjbG9zZWQgKGlmIGV4aXN0cylcbiAgICovXG4gIG9uQ2hpbGRyZW5DbG9zZSgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcyAmJiB0eXBlb2YgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLm9uQ2xvc2UpID09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLnBhcmFtcy5jaGlsZHJlbi5vbkNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBwb3BvdmVyIGl0ZW0gY2xpY2tcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHZhciBlLCB0O1xuICAgIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJvbkFjdGl2YXRlXCIgaW4gdGhpcy5wYXJhbXMgJiYgKCh0ID0gKGUgPSB0aGlzLnBhcmFtcykub25BY3RpdmF0ZSkgPT0gbnVsbCB8fCB0LmNhbGwoZSwgdGhpcy5wYXJhbXMpKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBoaW50IHRvIHRoZSBpdGVtIGVsZW1lbnQgaWYgaGludCBkYXRhIGlzIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtRWxlbWVudCAtIHBvcG92ZXIgaXRlbSByb290IGVsZW1lbnQgdG8gYWRkIGhpbnQgdG9cbiAgICogQHBhcmFtIGhpbnREYXRhIC0gaGludCBkYXRhXG4gICAqL1xuICBhZGRIaW50KGUsIHQpIHtcbiAgICBjb25zdCBvID0gbmV3IGFzKHQpO1xuICAgIHplKGUsIG8uZ2V0RWxlbWVudCgpLCB7XG4gICAgICBwbGFjZW1lbnQ6IHQucG9zaXRpb24sXG4gICAgICBoaWRpbmdEZWxheTogMTAwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaXRlbSBjaGlsZHJlbiB0aGF0IGFyZSByZXByZXNlbnRlZCBhcyBwb3BvdmVyIGl0ZW1zXG4gICAqL1xuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zICYmICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5pdGVtcykgIT09IHZvaWQgMCA/IHRoaXMucGFyYW1zLmNoaWxkcmVuLml0ZW1zIDogW107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGhhcyBhbnkgdHlwZSBvZiBjaGlsZHJlblxuICAgKi9cbiAgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGNoaWxkcmVuIHNob3VsZCBiZSBvcGVuIGluc3RhbnRseSBhZnRlciBwb3BvdmVyIGlzIG9wZW5lZCBhbmQgbm90IG9uIGl0ZW0gY2xpY2svaG92ZXJcbiAgICovXG4gIGdldCBpc0NoaWxkcmVuT3BlbigpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMgJiYgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLmlzT3BlbikgPT09ICEwO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGl0ZW0gY2hpbGRyZW4gaXRlbXMgc2hvdWxkIGJlIG5hdmlnYXRhYmxlIHZpYSBrZXlib2FyZFxuICAgKi9cbiAgZ2V0IGlzQ2hpbGRyZW5GbGlwcGFibGUoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICEodGhpcy5wYXJhbXMgPT09IHZvaWQgMCB8fCAhKFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcykgfHwgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLmlzRmxpcHBhYmxlKSA9PT0gITEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBoYXMgY2hpbGRyZW4gdGhhdCBzaG91bGQgYmUgc2VhcmNoYWJsZVxuICAgKi9cbiAgZ2V0IGlzQ2hpbGRyZW5TZWFyY2hhYmxlKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcyAmJiAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VhcmNoYWJsZSkgPT09ICEwO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHBvcG92ZXIgc2hvdWxkIGNsb3NlIG9uY2UgaXRlbSBpcyBhY3RpdmF0ZWRcbiAgICovXG4gIGdldCBjbG9zZU9uQWN0aXZhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjbG9zZU9uQWN0aXZhdGVcIiBpbiB0aGlzLnBhcmFtcyAmJiB0aGlzLnBhcmFtcy5jbG9zZU9uQWN0aXZhdGU7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaXRlbSBpcyBhY3RpdmVcbiAgICovXG4gIGdldCBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMgPT09IHZvaWQgMCB8fCAhKFwiaXNBY3RpdmVcIiBpbiB0aGlzLnBhcmFtcykgPyAhMSA6IHR5cGVvZiB0aGlzLnBhcmFtcy5pc0FjdGl2ZSA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnBhcmFtcy5pc0FjdGl2ZSgpIDogdGhpcy5wYXJhbXMuaXNBY3RpdmUgPT09ICEwO1xuICB9XG59XG5jb25zdCBZID0gbmUoXCJjZS1wb3BvdmVyLWl0ZW1cIiksIEwgPSB7XG4gIGNvbnRhaW5lcjogWSgpLFxuICBhY3RpdmU6IFkobnVsbCwgXCJhY3RpdmVcIiksXG4gIGRpc2FibGVkOiBZKG51bGwsIFwiZGlzYWJsZWRcIiksXG4gIGZvY3VzZWQ6IFkobnVsbCwgXCJmb2N1c2VkXCIpLFxuICBoaWRkZW46IFkobnVsbCwgXCJoaWRkZW5cIiksXG4gIGNvbmZpcm1hdGlvblN0YXRlOiBZKG51bGwsIFwiY29uZmlybWF0aW9uXCIpLFxuICBub0hvdmVyOiBZKG51bGwsIFwibm8taG92ZXJcIiksXG4gIG5vRm9jdXM6IFkobnVsbCwgXCJuby1mb2N1c1wiKSxcbiAgdGl0bGU6IFkoXCJ0aXRsZVwiKSxcbiAgc2Vjb25kYXJ5VGl0bGU6IFkoXCJzZWNvbmRhcnktdGl0bGVcIiksXG4gIGljb246IFkoXCJpY29uXCIpLFxuICBpY29uVG9vbDogWShcImljb25cIiwgXCJ0b29sXCIpLFxuICBpY29uQ2hldnJvblJpZ2h0OiBZKFwiaWNvblwiLCBcImNoZXZyb24tcmlnaHRcIiksXG4gIHdvYmJsZUFuaW1hdGlvbjogbmUoXCJ3b2JibGVcIikoKVxufTtcbmNsYXNzIHJlIGV4dGVuZHMgeHQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBwb3BvdmVyIGl0ZW0gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgaXRlbSBjb25zdHJ1Y3Rpb24gcGFyYW1zXG4gICAqIEBwYXJhbSByZW5kZXJQYXJhbXMgLSBwb3BvdmVyIGl0ZW0gcmVuZGVyIHBhcmFtcy5cbiAgICogVGhlIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNldCBieSB1c2VyIHZpYSBwb3BvdmVyIGFwaSBidXQgcmF0aGVyIGRlcGVuZCBvbiB0ZWNobmljYWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5wYXJhbXMgPSBlLCB0aGlzLm5vZGVzID0ge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIGljb246IG51bGxcbiAgICB9LCB0aGlzLmNvbmZpcm1hdGlvblN0YXRlID0gbnVsbCwgdGhpcy5yZW1vdmVTcGVjaWFsRm9jdXNCZWhhdmlvciA9ICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgby5jbGFzc0xpc3QucmVtb3ZlKEwubm9Gb2N1cyk7XG4gICAgfSwgdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvciA9ICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgKG8gPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgby5jbGFzc0xpc3QucmVtb3ZlKEwubm9Ib3Zlcik7XG4gICAgfSwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgdmFyIG8sIGk7XG4gICAgICAobyA9IHRoaXMubm9kZXMuaWNvbikgPT0gbnVsbCB8fCBvLmNsYXNzTGlzdC5yZW1vdmUoTC53b2JibGVBbmltYXRpb24pLCAoaSA9IHRoaXMubm9kZXMuaWNvbikgPT0gbnVsbCB8fCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kKTtcbiAgICB9LCB0aGlzLm5vZGVzLnJvb3QgPSB0aGlzLm1ha2UoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaXRlbSBpcyBkaXNhYmxlZCBhbmQgaGVuY2Ugbm90IGNsaWNrYWJsZVxuICAgKi9cbiAgZ2V0IGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmlzRGlzYWJsZWQgPT09ICEwO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvc2VzIHBvcG92ZXIgaXRlbSB0b2dnbGUgcGFyYW1ldGVyXG4gICAqL1xuICBnZXQgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy50b2dnbGU7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZW0gdGl0bGVcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgY29uZmlybWF0aW9uIHN0YXRlIGlzIGVuYWJsZWQgZm9yIHBvcG92ZXIgaXRlbVxuICAgKi9cbiAgZ2V0IGlzQ29uZmlybWF0aW9uU3RhdGVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpcm1hdGlvblN0YXRlICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGl0ZW0gaXMgZm9jdXNlZCBpbiBrZXlib2FyZCBuYXZpZ2F0aW9uIHByb2Nlc3NcbiAgICovXG4gIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdCA9PT0gbnVsbCA/ICExIDogdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhMLmZvY3VzZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgaXRlbSByb290IGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIG9uIHBvcG92ZXIgaXRlbSBjbGlja1xuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQgJiYgdGhpcy5jb25maXJtYXRpb25TdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hY3RpdmF0ZU9yRW5hYmxlQ29uZmlybWF0aW9uTW9kZSh0aGlzLmNvbmZpcm1hdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmF0ZU9yRW5hYmxlQ29uZmlybWF0aW9uTW9kZSh0aGlzLnBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgaXRlbSBhY3RpdmUgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIGlzQWN0aXZlIC0gdHJ1ZSBpZiBpdGVtIHNob3VsZCBzdHJpY3RseSBzaG91bGQgYmVjb21lIGFjdGl2ZVxuICAgKi9cbiAgdG9nZ2xlQWN0aXZlKGUpIHtcbiAgICB2YXIgdDtcbiAgICAodCA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC50b2dnbGUoTC5hY3RpdmUsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gaGlkZGVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0hpZGRlbiAtIHRydWUgaWYgaXRlbSBzaG91bGQgYmUgaGlkZGVuXG4gICAqL1xuICB0b2dnbGVIaWRkZW4oZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZShMLmhpZGRlbiwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyBwb3BvdmVyIGl0ZW0gdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmlzQ29uZmlybWF0aW9uU3RhdGVFbmFibGVkICYmIHRoaXMuZGlzYWJsZUNvbmZpcm1hdGlvbk1vZGUoKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCBvbmNlIGl0ZW0gYmVjb21lcyBmb2N1c2VkIGR1cmluZyBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAqL1xuICBvbkZvY3VzKCkge1xuICAgIHRoaXMuZGlzYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBIVE1MIGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBwb3BvdmVyIGl0ZW0gcGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBpdGVtIGNvbnN0cnVjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIHJlbmRlclBhcmFtcyAtIHBvcG92ZXIgaXRlbSByZW5kZXIgcGFyYW1zXG4gICAqL1xuICBtYWtlKGUsIHQpIHtcbiAgICB2YXIgcywgcjtcbiAgICBjb25zdCBvID0gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQud3JhcHBlclRhZykgfHwgXCJkaXZcIiwgaSA9IGQubWFrZShvLCBMLmNvbnRhaW5lciwge1xuICAgICAgdHlwZTogbyA9PT0gXCJidXR0b25cIiA/IFwiYnV0dG9uXCIgOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gZS5uYW1lICYmIChpLmRhdGFzZXQuaXRlbU5hbWUgPSBlLm5hbWUpLCB0aGlzLm5vZGVzLmljb24gPSBkLm1ha2UoXCJkaXZcIiwgW0wuaWNvbiwgTC5pY29uVG9vbF0sIHtcbiAgICAgIGlubmVySFRNTDogZS5pY29uIHx8IFFpXG4gICAgfSksIGkuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pY29uKSwgZS50aXRsZSAhPT0gdm9pZCAwICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIEwudGl0bGUsIHtcbiAgICAgIGlubmVySFRNTDogZS50aXRsZSB8fCBcIlwiXG4gICAgfSkpLCBlLnNlY29uZGFyeUxhYmVsICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIEwuc2Vjb25kYXJ5VGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiBlLnNlY29uZGFyeUxhYmVsXG4gICAgfSkpLCB0aGlzLmhhc0NoaWxkcmVuICYmIGkuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIFtMLmljb24sIEwuaWNvbkNoZXZyb25SaWdodF0sIHtcbiAgICAgIGlubmVySFRNTDogcWlcbiAgICB9KSksIHRoaXMuaXNBY3RpdmUgJiYgaS5jbGFzc0xpc3QuYWRkKEwuYWN0aXZlKSwgZS5pc0Rpc2FibGVkICYmIGkuY2xhc3NMaXN0LmFkZChMLmRpc2FibGVkKSwgZS5oaW50ICE9PSB2b2lkIDAgJiYgKChzID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5oaW50KSA9PSBudWxsID8gdm9pZCAwIDogcy5lbmFibGVkKSAhPT0gITEgJiYgdGhpcy5hZGRIaW50KGksIHtcbiAgICAgIC4uLmUuaGludCxcbiAgICAgIHBvc2l0aW9uOiAoKHIgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmhpbnQpID09IG51bGwgPyB2b2lkIDAgOiByLnBvc2l0aW9uKSB8fCBcInJpZ2h0XCJcbiAgICB9KSwgaTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIGNvbmZpcm1hdGlvbiBtb2RlIGZvciB0aGUgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIG5ld1N0YXRlIC0gbmV3IHBvcG92ZXIgaXRlbSBwYXJhbXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICAgKi9cbiAgZW5hYmxlQ29uZmlybWF0aW9uTW9kZShlKSB7XG4gICAgaWYgKHRoaXMubm9kZXMucm9vdCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAuLi5lLFxuICAgICAgY29uZmlybWF0aW9uOiBcImNvbmZpcm1hdGlvblwiIGluIGUgPyBlLmNvbmZpcm1hdGlvbiA6IHZvaWQgMFxuICAgIH0sIG8gPSB0aGlzLm1ha2UodCk7XG4gICAgdGhpcy5ub2Rlcy5yb290LmlubmVySFRNTCA9IG8uaW5uZXJIVE1MLCB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmFkZChMLmNvbmZpcm1hdGlvblN0YXRlKSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IGUsIHRoaXMuZW5hYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGl0ZW0gdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAqL1xuICBkaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpIHtcbiAgICBpZiAodGhpcy5ub2Rlcy5yb290ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLm1ha2UodGhpcy5wYXJhbXMpO1xuICAgIHRoaXMubm9kZXMucm9vdC5pbm5lckhUTUwgPSBlLmlubmVySFRNTCwgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoTC5jb25maXJtYXRpb25TdGF0ZSksIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBudWxsLCB0aGlzLmRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc3BlY2lhbCBmb2N1cyBhbmQgaG92ZXIgYmVoYXZpb3IgZm9yIGl0ZW0gaW4gY29uZmlybWF0aW9uIHN0YXRlLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IGl0ZW0gZnJvbSBiZWluZyBoaWdobGlnaHRlZCBhcyBob3ZlcmVkL2ZvY3VzZWQganVzdCBhZnRlciBjbGljay5cbiAgICovXG4gIGVuYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKSB7XG4gICAgdmFyIGUsIHQsIG87XG4gICAgKGUgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgZS5jbGFzc0xpc3QuYWRkKEwubm9Ib3ZlciksICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LmFkZChMLm5vRm9jdXMpLCAobyA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IsIHsgb25jZTogITAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHNwZWNpYWwgZm9jdXMgYW5kIGhvdmVyIGJlaGF2aW9yXG4gICAqL1xuICBkaXNhYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnJlbW92ZVNwZWNpYWxGb2N1c0JlaGF2aW9yKCksIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IoKSwgKGUgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgaXRlbSdzIG9uQWN0aXZhdGUgY2FsbGJhY2sgaWYgdGhlIGl0ZW0gaGFzIG5vIGNvbmZpcm1hdGlvbiBjb25maWd1cmVkXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBhY3RpdmF0ZSBvciBicmluZyB0byBjb25maXJtYXRpb24gbW9kZVxuICAgKi9cbiAgYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghKFwiY29uZmlybWF0aW9uXCIgaW4gZSkgfHwgZS5jb25maXJtYXRpb24gPT09IHZvaWQgMClcbiAgICAgIHRyeSB7XG4gICAgICAgICh0ID0gZS5vbkFjdGl2YXRlKSA9PSBudWxsIHx8IHQuY2FsbChlLCBlKSwgdGhpcy5kaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZUVycm9yKCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgdGhpcy5lbmFibGVDb25maXJtYXRpb25Nb2RlKGUuY29uZmlybWF0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgaXRlbSB3aGljaCBzeW1ib2xpemVzIHRoYXQgZXJyb3Igb2NjdXJlZCB3aGlsZSBleGVjdXRpbmcgJ29uQWN0aXZhdGUoKScgY2FsbGJhY2tcbiAgICovXG4gIGFuaW1hdGVFcnJvcigpIHtcbiAgICB2YXIgZSwgdCwgbztcbiAgICAoZSA9IHRoaXMubm9kZXMuaWNvbikgIT0gbnVsbCAmJiBlLmNsYXNzTGlzdC5jb250YWlucyhMLndvYmJsZUFuaW1hdGlvbikgfHwgKCh0ID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LmFkZChMLndvYmJsZUFuaW1hdGlvbiksIChvID0gdGhpcy5ub2Rlcy5pY29uKSA9PSBudWxsIHx8IG8uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCB0aGlzLm9uRXJyb3JBbmltYXRpb25FbmQpKTtcbiAgfVxufVxuY29uc3QgbnQgPSBuZShcImNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3JcIiksIGl0ID0ge1xuICBjb250YWluZXI6IG50KCksXG4gIGxpbmU6IG50KFwibGluZVwiKSxcbiAgaGlkZGVuOiBudChudWxsLCBcImhpZGRlblwiKVxufTtcbmNsYXNzIFFvIGV4dGVuZHMgeHQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBkLm1ha2UoXCJkaXZcIiwgaXQuY29udGFpbmVyKSxcbiAgICAgIGxpbmU6IGQubWFrZShcImRpdlwiLCBpdC5saW5lKVxuICAgIH0sIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmxpbmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgc2VwYXJhdG9yIHJvb3QgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290O1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gaGlkZGVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0hpZGRlbiAtIHRydWUgaWYgaXRlbSBzaG91bGQgYmUgaGlkZGVuXG4gICAqL1xuICB0b2dnbGVIaWRkZW4oZSkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZShpdC5oaWRkZW4sIGUpO1xuICB9XG59XG52YXIgRyA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLkNsb3NlZCA9IFwiY2xvc2VkXCIsIG4uQ2xvc2VkT25BY3RpdmF0ZSA9IFwiY2xvc2VkLW9uLWFjdGl2YXRlXCIsIG4pKShHIHx8IHt9KTtcbmNvbnN0ICQgPSBuZShcImNlLXBvcG92ZXJcIiksIFAgPSB7XG4gIHBvcG92ZXI6ICQoKSxcbiAgcG9wb3ZlckNvbnRhaW5lcjogJChcImNvbnRhaW5lclwiKSxcbiAgcG9wb3Zlck9wZW5Ub3A6ICQobnVsbCwgXCJvcGVuLXRvcFwiKSxcbiAgcG9wb3Zlck9wZW5MZWZ0OiAkKG51bGwsIFwib3Blbi1sZWZ0XCIpLFxuICBwb3BvdmVyT3BlbmVkOiAkKG51bGwsIFwib3BlbmVkXCIpLFxuICBzZWFyY2g6ICQoXCJzZWFyY2hcIiksXG4gIG5vdGhpbmdGb3VuZE1lc3NhZ2U6ICQoXCJub3RoaW5nLWZvdW5kLW1lc3NhZ2VcIiksXG4gIG5vdGhpbmdGb3VuZE1lc3NhZ2VEaXNwbGF5ZWQ6ICQoXCJub3RoaW5nLWZvdW5kLW1lc3NhZ2VcIiwgXCJkaXNwbGF5ZWRcIiksXG4gIGl0ZW1zOiAkKFwiaXRlbXNcIiksXG4gIG92ZXJsYXk6ICQoXCJvdmVybGF5XCIpLFxuICBvdmVybGF5SGlkZGVuOiAkKFwib3ZlcmxheVwiLCBcImhpZGRlblwiKSxcbiAgcG9wb3Zlck5lc3RlZDogJChudWxsLCBcIm5lc3RlZFwiKSxcbiAgZ2V0UG9wb3Zlck5lc3RlZENsYXNzOiAobikgPT4gJChudWxsLCBgbmVzdGVkLWxldmVsLSR7bi50b1N0cmluZygpfWApLFxuICBwb3BvdmVySW5saW5lOiAkKG51bGwsIFwiaW5saW5lXCIpLFxuICBwb3BvdmVySGVhZGVyOiAkKFwiaGVhZGVyXCIpXG59O1xudmFyIGZlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uTmVzdGluZ0xldmVsID0gXCItLW5lc3RpbmctbGV2ZWxcIiwgbi5Qb3BvdmVySGVpZ2h0ID0gXCItLXBvcG92ZXItaGVpZ2h0XCIsIG4uSW5saW5lUG9wb3ZlcldpZHRoID0gXCItLWlubGluZS1wb3BvdmVyLXdpZHRoXCIsIG4uVHJpZ2dlckl0ZW1MZWZ0ID0gXCItLXRyaWdnZXItaXRlbS1sZWZ0XCIsIG4uVHJpZ2dlckl0ZW1Ub3AgPSBcIi0tdHJpZ2dlci1pdGVtLXRvcFwiLCBuKSkoZmUgfHwge30pO1xuY29uc3QgVG8gPSBuZShcImNlLXBvcG92ZXItaXRlbS1odG1sXCIpLCBTbyA9IHtcbiAgcm9vdDogVG8oKSxcbiAgaGlkZGVuOiBUbyhudWxsLCBcImhpZGRlblwiKVxufTtcbmNsYXNzIFNlIGV4dGVuZHMgeHQge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyDigJMgaW5zdGFuY2UgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcmVuZGVyUGFyYW1zIOKAkyBwb3BvdmVyIGl0ZW0gcmVuZGVyIHBhcmFtcy5cbiAgICogVGhlIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNldCBieSB1c2VyIHZpYSBwb3BvdmVyIGFwaSBidXQgcmF0aGVyIGRlcGVuZCBvbiB0ZWNobmljYWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB2YXIgbywgaTtcbiAgICBzdXBlcihlKSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IGQubWFrZShcImRpdlwiLCBTby5yb290KVxuICAgIH0sIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZChlLmVsZW1lbnQpLCBlLm5hbWUgJiYgKHRoaXMubm9kZXMucm9vdC5kYXRhc2V0Lml0ZW1OYW1lID0gZS5uYW1lKSwgZS5oaW50ICE9PSB2b2lkIDAgJiYgKChvID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5oaW50KSA9PSBudWxsID8gdm9pZCAwIDogby5lbmFibGVkKSAhPT0gITEgJiYgdGhpcy5hZGRIaW50KHRoaXMubm9kZXMucm9vdCwge1xuICAgICAgLi4uZS5oaW50LFxuICAgICAgcG9zaXRpb246ICgoaSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGludCkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucG9zaXRpb24pIHx8IFwicmlnaHRcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgaXRlbSByb290IGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGhpZGRlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNIaWRkZW4gLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIGJlIGhpZGRlblxuICAgKi9cbiAgdG9nZ2xlSGlkZGVuKGUpIHtcbiAgICB2YXIgdDtcbiAgICAodCA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC50b2dnbGUoU28uaGlkZGVuLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGJ1dHRvbnMgYW5kIGlucHV0cyBpbnNpZGUgY3VzdG9tIGNvbnRlbnRcbiAgICovXG4gIGdldENvbnRyb2xzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLnJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIGBidXR0b24sICR7ZC5hbGxJbnB1dHNTZWxlY3Rvcn1gXG4gICAgKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbiAgfVxufVxuY2xhc3MgSm8gZXh0ZW5kcyBPZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBjb25zdHJ1Y3Rpb24gcGFyYW1zXG4gICAqIEBwYXJhbSBpdGVtc1JlbmRlclBhcmFtcyAtIHBvcG92ZXIgaXRlbSByZW5kZXIgcGFyYW1zLlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc2V0IGJ5IHVzZXIgdmlhIHBvcG92ZXIgYXBpIGJ1dCByYXRoZXIgZGVwZW5kIG9uIHRlY2huaWNhbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCA9IHt9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5wYXJhbXMgPSBlLCB0aGlzLml0ZW1zUmVuZGVyUGFyYW1zID0gdCwgdGhpcy5saXN0ZW5lcnMgPSBuZXcgX2UoKSwgdGhpcy5tZXNzYWdlcyA9IHtcbiAgICAgIG5vdGhpbmdGb3VuZDogXCJOb3RoaW5nIGZvdW5kXCIsXG4gICAgICBzZWFyY2g6IFwiU2VhcmNoXCJcbiAgICB9LCB0aGlzLml0ZW1zID0gdGhpcy5idWlsZEl0ZW1zKGUuaXRlbXMpLCBlLm1lc3NhZ2VzICYmICh0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgLi4udGhpcy5tZXNzYWdlcyxcbiAgICAgIC4uLmUubWVzc2FnZXNcbiAgICB9KSwgdGhpcy5ub2RlcyA9IHt9LCB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1AucG9wb3ZlckNvbnRhaW5lcl0pLCB0aGlzLm5vZGVzLm5vdGhpbmdGb3VuZE1lc3NhZ2UgPSBkLm1ha2UoXCJkaXZcIiwgW1Aubm90aGluZ0ZvdW5kTWVzc2FnZV0sIHtcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLm1lc3NhZ2VzLm5vdGhpbmdGb3VuZFxuICAgIH0pLCB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlKSwgdGhpcy5ub2Rlcy5pdGVtcyA9IGQubWFrZShcImRpdlwiLCBbUC5pdGVtc10pLCB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBvLmdldEVsZW1lbnQoKTtcbiAgICAgIGkgIT09IG51bGwgJiYgdGhpcy5ub2Rlcy5pdGVtcy5hcHBlbmRDaGlsZChpKTtcbiAgICB9KSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuaXRlbXMpLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIsIFwiY2xpY2tcIiwgKG8pID0+IHRoaXMuaGFuZGxlQ2xpY2sobykpLCB0aGlzLm5vZGVzLnBvcG92ZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgUC5wb3BvdmVyLFxuICAgICAgdGhpcy5wYXJhbXMuY2xhc3NcbiAgICBdKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lcik7XG4gIH1cbiAgLyoqXG4gICAqIExpc3Qgb2YgZGVmYXVsdCBwb3BvdmVyIGl0ZW1zIHRoYXQgYXJlIHNlYXJjaGFibGUgYW5kIG1heSBoYXZlIGNvbmZpcm1hdGlvbiBzdGF0ZVxuICAgKi9cbiAgZ2V0IGl0ZW1zRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoKGUpID0+IGUgaW5zdGFuY2VvZiByZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSFRNTCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBvcG92ZXJcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucG9wb3ZlcjtcbiAgfVxuICAvKipcbiAgICogT3BlbiBwb3BvdmVyXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QuYWRkKFAucG9wb3Zlck9wZW5lZCksIHRoaXMuc2VhcmNoICE9PSB2b2lkIDAgJiYgdGhpcy5zZWFyY2guZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHBvcG92ZXJcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoUC5wb3BvdmVyT3BlbmVkKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoUC5wb3BvdmVyT3BlblRvcCksIHRoaXMuaXRlbXNEZWZhdWx0LmZvckVhY2goKGUpID0+IGUucmVzZXQoKSksIHRoaXMuc2VhcmNoICE9PSB2b2lkIDAgJiYgdGhpcy5zZWFyY2guY2xlYXIoKSwgdGhpcy5lbWl0KEcuQ2xvc2VkKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIG1lbW9yeVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2goKHQpID0+IHQuZGVzdHJveSgpKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLnJlbW92ZSgpLCB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKSwgKGUgPSB0aGlzLnNlYXJjaCkgPT0gbnVsbCB8fCBlLmRlc3Ryb3koKTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgZm9yIHRoZSBpdGVtIGJ5IG5hbWUgYW5kIGltaXRhdGVzIGNsaWNrIG9uIGl0XG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiB0aGUgaXRlbSB0byBhY3RpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGVJdGVtQnlOYW1lKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pdGVtcy5maW5kKChvKSA9PiBvLm5hbWUgPT09IGUpO1xuICAgIHRoaXMuaGFuZGxlSXRlbUNsaWNrKHQpO1xuICB9XG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgcG9wb3ZlciBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0gaXRlbXMgLSBsaXN0IG9mIGl0ZW1zIHBhcmFtc1xuICAgKi9cbiAgYnVpbGRJdGVtcyhlKSB7XG4gICAgcmV0dXJuIGUubWFwKCh0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgICBjYXNlIF8uU2VwYXJhdG9yOlxuICAgICAgICAgIHJldHVybiBuZXcgUW8oKTtcbiAgICAgICAgY2FzZSBfLkh0bWw6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZSh0LCB0aGlzLml0ZW1zUmVuZGVyUGFyYW1zW18uSHRtbF0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuZXcgcmUodCwgdGhpcy5pdGVtc1JlbmRlclBhcmFtc1tfLkRlZmF1bHRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHBvcG92ZXIgaXRlbSB0aGF0IGlzIHRoZSB0YXJnZXQgb2YgdGhlIHNwZWNpZmllZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCB0byByZXRyaWV2ZSBwb3BvdmVyIGl0ZW0gZnJvbVxuICAgKi9cbiAgZ2V0VGFyZ2V0SXRlbShlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKCh0KSA9PiB0IGluc3RhbmNlb2YgcmUgfHwgdCBpbnN0YW5jZW9mIFNlKS5maW5kKCh0KSA9PiB7XG4gICAgICBjb25zdCBvID0gdC5nZXRFbGVtZW50KCk7XG4gICAgICByZXR1cm4gbyA9PT0gbnVsbCA/ICExIDogZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhvKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBwb3BvdmVyIGl0ZW0gY2xpY2tcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGhhbmRsZSBjbGljayBvZlxuICAgKi9cbiAgaGFuZGxlSXRlbUNsaWNrKGUpIHtcbiAgICBpZiAoIShcImlzRGlzYWJsZWRcIiBpbiBlICYmIGUuaXNEaXNhYmxlZCkpIHtcbiAgICAgIGlmIChlLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuc2hvd05lc3RlZEl0ZW1zKGUpLCBcImhhbmRsZUNsaWNrXCIgaW4gZSAmJiB0eXBlb2YgZS5oYW5kbGVDbGljayA9PSBcImZ1bmN0aW9uXCIgJiYgZS5oYW5kbGVDbGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLml0ZW1zRGVmYXVsdC5maWx0ZXIoKHQpID0+IHQgIT09IGUpLmZvckVhY2goKHQpID0+IHQucmVzZXQoKSksIFwiaGFuZGxlQ2xpY2tcIiBpbiBlICYmIHR5cGVvZiBlLmhhbmRsZUNsaWNrID09IFwiZnVuY3Rpb25cIiAmJiBlLmhhbmRsZUNsaWNrKCksIHRoaXMudG9nZ2xlSXRlbUFjdGl2ZW5lc3NJZk5lZWRlZChlKSwgZS5jbG9zZU9uQWN0aXZhdGUgJiYgKHRoaXMuaGlkZSgpLCB0aGlzLmVtaXQoRy5DbG9zZWRPbkFjdGl2YXRlKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrcyBpbnNpZGUgcG9wb3ZlclxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBpdGVtIHRvIGhhbmRsZSBjbGljayBvZlxuICAgKi9cbiAgaGFuZGxlQ2xpY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRhcmdldEl0ZW0oZSk7XG4gICAgdCAhPT0gdm9pZCAwICYmIHRoaXMuaGFuZGxlSXRlbUNsaWNrKHQpO1xuICB9XG4gIC8qKlxuICAgKiAtIFRvZ2dsZXMgaXRlbSBhY3RpdmUgc3RhdGUsIGlmIGNsaWNrZWQgcG9wb3ZlciBpdGVtIGhhcyBwcm9wZXJ0eSAndG9nZ2xlJyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogLSBQZXJmb3JtcyByYWRpb2J1dHRvbi1saWtlIGJlaGF2aW9yIGlmIHRoZSBpdGVtIGhhcyBwcm9wZXJ0eSAndG9nZ2xlJyBzZXQgdG8gc3RyaW5nIGtleS5cbiAgICogKEFsbCB0aGUgb3RoZXIgaXRlbXMgd2l0aCB0aGUgc2FtZSBrZXkgZ2V0IGluYWN0aXZlLCBhbmQgdGhlIGl0ZW0gZ2V0cyBhY3RpdmUpXG4gICAqXG4gICAqIEBwYXJhbSBjbGlja2VkSXRlbSAtIHBvcG92ZXIgaXRlbSB0aGF0IHdhcyBjbGlja2VkXG4gICAqL1xuICB0b2dnbGVJdGVtQWN0aXZlbmVzc0lmTmVlZGVkKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIHJlICYmIChlLnRvZ2dsZSA9PT0gITAgJiYgZS50b2dnbGVBY3RpdmUoKSwgdHlwZW9mIGUudG9nZ2xlID09IFwic3RyaW5nXCIpKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5pdGVtc0RlZmF1bHQuZmlsdGVyKChvKSA9PiBvLnRvZ2dsZSA9PT0gZS50b2dnbGUpO1xuICAgICAgaWYgKHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGUudG9nZ2xlQWN0aXZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHQuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBvLnRvZ2dsZUFjdGl2ZShvID09PSBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxudmFyIFVlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uU2VhcmNoID0gXCJzZWFyY2hcIiwgbikpKFVlIHx8IHt9KTtcbmNvbnN0IHN0ID0gbmUoXCJjZHgtc2VhcmNoLWZpZWxkXCIpLCBydCA9IHtcbiAgd3JhcHBlcjogc3QoKSxcbiAgaWNvbjogc3QoXCJpY29uXCIpLFxuICBpbnB1dDogc3QoXCJpbnB1dFwiKVxufTtcbmNsYXNzIGxzIGV4dGVuZHMgT2Uge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhdmFpbGFibGUgY29uZmlnXG4gICAqIEBwYXJhbSBvcHRpb25zLml0ZW1zIC0gc2VhcmNoYWJsZSBpdGVtcyBsaXN0XG4gICAqIEBwYXJhbSBvcHRpb25zLnBsYWNlaG9sZGVyIC0gaW5wdXQgcGxhY2Vob2xkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgaXRlbXM6IGUsIHBsYWNlaG9sZGVyOiB0IH0pIHtcbiAgICBzdXBlcigpLCB0aGlzLmxpc3RlbmVycyA9IG5ldyBfZSgpLCB0aGlzLml0ZW1zID0gZSwgdGhpcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIHJ0LndyYXBwZXIpO1xuICAgIGNvbnN0IG8gPSBkLm1ha2UoXCJkaXZcIiwgcnQuaWNvbiwge1xuICAgICAgaW5uZXJIVE1MOiBvc1xuICAgIH0pO1xuICAgIHRoaXMuaW5wdXQgPSBkLm1ha2UoXCJpbnB1dFwiLCBydC5pbnB1dCwge1xuICAgICAgcGxhY2Vob2xkZXI6IHQsXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcHJldmVudCBmb2N1c2luZyBvbiB0aGUgaW5wdXQgYnkgVGFiIGtleVxuICAgICAgICogKFBvcG92ZXIgaW4gdGhlIFRvb2xiYXIgbGF5cyBiZWxvdyB0aGUgYmxvY2tzLFxuICAgICAgICogc28gVGFiIGluIHRoZSBsYXN0IGJsb2NrIHdpbGwgZm9jdXMgdGhpcyBoaWRkZW4gaW5wdXQgaWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0KVxuICAgICAgICovXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9KSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG8pLCB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5pbnB1dCksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMuaW5wdXQsIFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zZWFyY2hRdWVyeSA9IHRoaXMuaW5wdXQudmFsdWUsIHRoaXMuZW1pdChVZS5TZWFyY2gsIHtcbiAgICAgICAgcXVlcnk6IHRoaXMuc2VhcmNoUXVlcnksXG4gICAgICAgIGl0ZW1zOiB0aGlzLmZvdW5kSXRlbXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlYXJjaCBmaWVsZCBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgZm9jdXMgdG8gdGhlIGlucHV0XG4gICAqL1xuICBmb2N1cygpIHtcbiAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBzZWFyY2ggcXVlcnkgYW5kIHJlc3VsdHNcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaW5wdXQudmFsdWUgPSBcIlwiLCB0aGlzLnNlYXJjaFF1ZXJ5ID0gXCJcIiwgdGhpcy5lbWl0KFVlLlNlYXJjaCwge1xuICAgICAgcXVlcnk6IFwiXCIsXG4gICAgICBpdGVtczogdGhpcy5mb3VuZEl0ZW1zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBmb3VuZCBpdGVtcyBmb3IgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5XG4gICAqL1xuICBnZXQgZm91bmRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoKGUpID0+IHRoaXMuY2hlY2tJdGVtKGUpKTtcbiAgfVxuICAvKipcbiAgICogQ29udGFpbnMgbG9naWMgZm9yIGNoZWNraW5nIHdoZXRoZXIgcGFzc2VkIGl0ZW0gY29uZm9ybXMgdGhlIHNlYXJjaCBxdWVyeVxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYmUgY2hlY2tlZFxuICAgKi9cbiAgY2hlY2tJdGVtKGUpIHtcbiAgICB2YXIgaSwgcztcbiAgICBjb25zdCB0ID0gKChpID0gZS50aXRsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudG9Mb3dlckNhc2UoKSkgfHwgXCJcIiwgbyA9IChzID0gdGhpcy5zZWFyY2hRdWVyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IHMudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbyAhPT0gdm9pZCAwID8gdC5pbmNsdWRlcyhvKSA6ICExO1xuICB9XG59XG52YXIgY3MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGRzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgdXMgPSAobiwgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gZHMoZSwgdCkgOiBlLCBzID0gbi5sZW5ndGggLSAxLCByOyBzID49IDA7IHMtLSlcbiAgICAociA9IG5bc10pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgY3MoZSwgdCwgaSksIGk7XG59O1xuY29uc3QgZW4gPSBjbGFzcyB0biBleHRlbmRzIEpvIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgcGFyYW1zXG4gICAqIEBwYXJhbSBpdGVtc1JlbmRlclBhcmFtcyDigJPCoHBvcG92ZXIgaXRlbSByZW5kZXIgcGFyYW1zLlxuICAgKiBUaGUgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc2V0IGJ5IHVzZXIgdmlhIHBvcG92ZXIgYXBpIGJ1dCByYXRoZXIgZGVwZW5kIG9uIHRlY2huaWNhbCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLm5lc3RpbmdMZXZlbCA9IDAsIHRoaXMubmVzdGVkUG9wb3ZlclRyaWdnZXJJdGVtID0gbnVsbCwgdGhpcy5wcmV2aW91c2x5SG92ZXJlZEl0ZW0gPSBudWxsLCB0aGlzLnNjb3BlRWxlbWVudCA9IGRvY3VtZW50LmJvZHksIHRoaXMuaGlkZSA9ICgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgc3VwZXIuaGlkZSgpLCB0aGlzLmRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSwgKG8gPSB0aGlzLmZsaXBwZXIpID09IG51bGwgfHwgby5kZWFjdGl2YXRlKCksIHRoaXMucHJldmlvdXNseUhvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB9LCB0aGlzLm9uRmxpcCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLml0ZW1zRGVmYXVsdC5maW5kKChpKSA9PiBpLmlzRm9jdXNlZCk7XG4gICAgICBvID09IG51bGwgfHwgby5vbkZvY3VzKCk7XG4gICAgfSwgdGhpcy5vblNlYXJjaCA9IChvKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIGNvbnN0IGkgPSBvLnF1ZXJ5ID09PSBcIlwiLCBzID0gby5pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgbGV0IGMgPSAhMTtcbiAgICAgICAgbCBpbnN0YW5jZW9mIHJlID8gYyA9ICFvLml0ZW1zLmluY2x1ZGVzKGwpIDogKGwgaW5zdGFuY2VvZiBRbyB8fCBsIGluc3RhbmNlb2YgU2UpICYmIChjID0gcyB8fCAhaSksIGwudG9nZ2xlSGlkZGVuKGMpO1xuICAgICAgfSksIHRoaXMudG9nZ2xlTm90aGluZ0ZvdW5kTWVzc2FnZShzKTtcbiAgICAgIGNvbnN0IHIgPSBvLnF1ZXJ5ID09PSBcIlwiID8gdGhpcy5mbGlwcGFibGVFbGVtZW50cyA6IG8uaXRlbXMubWFwKChsKSA9PiBsLmdldEVsZW1lbnQoKSk7XG4gICAgICAoYSA9IHRoaXMuZmxpcHBlcikgIT0gbnVsbCAmJiBhLmlzQWN0aXZhdGVkICYmICh0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpLCB0aGlzLmZsaXBwZXIuYWN0aXZhdGUocikpO1xuICAgIH0sIGUubmVzdGluZ0xldmVsICE9PSB2b2lkIDAgJiYgKHRoaXMubmVzdGluZ0xldmVsID0gZS5uZXN0aW5nTGV2ZWwpLCB0aGlzLm5lc3RpbmdMZXZlbCA+IDAgJiYgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5hZGQoUC5wb3BvdmVyTmVzdGVkKSwgZS5zY29wZUVsZW1lbnQgIT09IHZvaWQgMCAmJiAodGhpcy5zY29wZUVsZW1lbnQgPSBlLnNjb3BlRWxlbWVudCksIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciAhPT0gbnVsbCAmJiB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIsIFwibW91c2VvdmVyXCIsIChvKSA9PiB0aGlzLmhhbmRsZUhvdmVyKG8pKSwgZS5zZWFyY2hhYmxlICYmIHRoaXMuYWRkU2VhcmNoKCksIGUuZmxpcHBhYmxlICE9PSAhMSAmJiAodGhpcy5mbGlwcGVyID0gbmV3IGNlKHtcbiAgICAgIGl0ZW1zOiB0aGlzLmZsaXBwYWJsZUVsZW1lbnRzLFxuICAgICAgZm9jdXNlZEl0ZW1DbGFzczogTC5mb2N1c2VkLFxuICAgICAgYWxsb3dlZEtleXM6IFtcbiAgICAgICAgeS5UQUIsXG4gICAgICAgIHkuVVAsXG4gICAgICAgIHkuRE9XTixcbiAgICAgICAgeS5FTlRFUlxuICAgICAgXVxuICAgIH0pLCB0aGlzLmZsaXBwZXIub25GbGlwKHRoaXMub25GbGlwKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBzb21lIGl0ZW0gaW5zaWRlIHBvcG92ZXIgaXMgZm9jdXNlZFxuICAgKi9cbiAgaGFzRm9jdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxpcHBlciA9PT0gdm9pZCAwID8gITEgOiB0aGlzLmZsaXBwZXIuaGFzRm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBpdGVtcyBjb250YWluZXIgb2YgdGhlIHBvcG92ZXJcbiAgICovXG4gIGdldCBzY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuaXRlbXMgPT09IG51bGwgPyAwIDogdGhpcy5ub2Rlcy5pdGVtcy5zY3JvbGxUb3A7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdmlzaWJsZSBlbGVtZW50IG9mZnNldCB0b3BcbiAgICovXG4gIGdldCBvZmZzZXRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciA9PT0gbnVsbCA/IDAgOiB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIub2Zmc2V0VG9wO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5ub2Rlcy5wb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KGZlLlBvcG92ZXJIZWlnaHQsIHRoaXMuc2l6ZS5oZWlnaHQgKyBcInB4XCIpLCB0aGlzLnNob3VsZE9wZW5Cb3R0b20gfHwgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5hZGQoUC5wb3BvdmVyT3BlblRvcCksIHRoaXMuc2hvdWxkT3BlblJpZ2h0IHx8IHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QuYWRkKFAucG9wb3Zlck9wZW5MZWZ0KSwgc3VwZXIuc2hvdygpLCAoZSA9IHRoaXMuZmxpcHBlcikgPT0gbnVsbCB8fCBlLmFjdGl2YXRlKHRoaXMuZmxpcHBhYmxlRWxlbWVudHMpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgbWVtb3J5XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaGlkZSgpLCBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGlzcGxheWluZyBuZXN0ZWQgaXRlbXMgZm9yIHRoZSBpdGVtLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSDigJMgaXRlbSB0byBzaG93IG5lc3RlZCBwb3BvdmVyIGZvclxuICAgKi9cbiAgc2hvd05lc3RlZEl0ZW1zKGUpIHtcbiAgICB0aGlzLm5lc3RlZFBvcG92ZXIgIT09IG51bGwgJiYgdGhpcy5uZXN0ZWRQb3BvdmVyICE9PSB2b2lkIDAgfHwgKHRoaXMubmVzdGVkUG9wb3ZlclRyaWdnZXJJdGVtID0gZSwgdGhpcy5zaG93TmVzdGVkUG9wb3ZlckZvckl0ZW0oZSkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGhvdmVyIGV2ZW50cyBpbnNpZGUgcG9wb3ZlciBpdGVtcyBjb250YWluZXJcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gaG92ZXIgZXZlbnQgZGF0YVxuICAgKi9cbiAgaGFuZGxlSG92ZXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldFRhcmdldEl0ZW0oZSk7XG4gICAgdCAhPT0gdm9pZCAwICYmIHRoaXMucHJldmlvdXNseUhvdmVyZWRJdGVtICE9PSB0ICYmICh0aGlzLmRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSwgdGhpcy5wcmV2aW91c2x5SG92ZXJlZEl0ZW0gPSB0LCB0Lmhhc0NoaWxkcmVuICYmIHRoaXMuc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKHQpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBDU1MgdmFyaWFibGUgd2l0aCBwb3NpdGlvbiBvZiBpdGVtIG5lYXIgd2hpY2ggbmVzdGVkIHBvcG92ZXIgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICogSXMgdXNlZCBmb3IgY29ycmVjdCBwb3NpdGlvbmluZyBvZiB0aGUgbmVzdGVkIHBvcG92ZXJcbiAgICpcbiAgICogQHBhcmFtIG5lc3RlZFBvcG92ZXJFbCAtIG5lc3RlZCBwb3BvdmVyIGVsZW1lbnRcbiAgICogQHBhcmFtIGl0ZW0g4oCTIGl0ZW0gbmVhciB3aGljaCBuZXN0ZWQgcG9wb3ZlciBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAqL1xuICBzZXRUcmlnZ2VySXRlbVBvc2l0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdC5nZXRFbGVtZW50KCksIGkgPSAobyA/IG8ub2Zmc2V0VG9wIDogMCkgLSB0aGlzLnNjcm9sbFRvcCwgcyA9IHRoaXMub2Zmc2V0VG9wICsgaTtcbiAgICBlLnN0eWxlLnNldFByb3BlcnR5KGZlLlRyaWdnZXJJdGVtVG9wLCBzICsgXCJweFwiKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgZXhpc3RpbmcgbmVzdGVkIHBvcG92ZXJcbiAgICovXG4gIGRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSB7XG4gICAgdmFyIGUsIHQ7XG4gICAgdGhpcy5uZXN0ZWRQb3BvdmVyID09PSB2b2lkIDAgfHwgdGhpcy5uZXN0ZWRQb3BvdmVyID09PSBudWxsIHx8ICh0aGlzLm5lc3RlZFBvcG92ZXIub2ZmKEcuQ2xvc2VkT25BY3RpdmF0ZSwgdGhpcy5oaWRlKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLmhpZGUoKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLmRlc3Ryb3koKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLmdldEVsZW1lbnQoKS5yZW1vdmUoKSwgdGhpcy5uZXN0ZWRQb3BvdmVyID0gbnVsbCwgKGUgPSB0aGlzLmZsaXBwZXIpID09IG51bGwgfHwgZS5hY3RpdmF0ZSh0aGlzLmZsaXBwYWJsZUVsZW1lbnRzKSwgKHQgPSB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSkgPT0gbnVsbCB8fCB0Lm9uQ2hpbGRyZW5DbG9zZSgpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgbmVzdGVkIHBvcG92ZXIgZm9yIHNwZWNpZmllZCBpdGVtLlxuICAgKiBJcyB1c2VkIG9ubHkgb24gZGVza3RvcFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gZGlzcGxheSBuZXN0ZWQgcG9wb3ZlciBieVxuICAgKi9cbiAgc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpIHtcbiAgICB2YXIgbztcbiAgICB0aGlzLm5lc3RlZFBvcG92ZXIgPSBuZXcgdG4oe1xuICAgICAgc2VhcmNoYWJsZTogZS5pc0NoaWxkcmVuU2VhcmNoYWJsZSxcbiAgICAgIGl0ZW1zOiBlLmNoaWxkcmVuLFxuICAgICAgbmVzdGluZ0xldmVsOiB0aGlzLm5lc3RpbmdMZXZlbCArIDEsXG4gICAgICBmbGlwcGFibGU6IGUuaXNDaGlsZHJlbkZsaXBwYWJsZSxcbiAgICAgIG1lc3NhZ2VzOiB0aGlzLm1lc3NhZ2VzXG4gICAgfSksIGUub25DaGlsZHJlbk9wZW4oKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLm9uKEcuQ2xvc2VkT25BY3RpdmF0ZSwgdGhpcy5oaWRlKTtcbiAgICBjb25zdCB0ID0gdGhpcy5uZXN0ZWRQb3BvdmVyLmdldEVsZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyLmFwcGVuZENoaWxkKHQpLCB0aGlzLnNldFRyaWdnZXJJdGVtUG9zaXRpb24odCwgZSksIHQuc3R5bGUuc2V0UHJvcGVydHkoZmUuTmVzdGluZ0xldmVsLCB0aGlzLm5lc3RlZFBvcG92ZXIubmVzdGluZ0xldmVsLnRvU3RyaW5nKCkpLCB0aGlzLm5lc3RlZFBvcG92ZXIuc2hvdygpLCAobyA9IHRoaXMuZmxpcHBlcikgPT0gbnVsbCB8fCBvLmRlYWN0aXZhdGUoKSwgdGhpcy5uZXN0ZWRQb3BvdmVyO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9wb3ZlciBzaG91bGQgYmUgb3BlbmVkIGJvdHRvbS5cbiAgICogSXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBiZWxvdyBvciBub3QgZW5vdWdoIHNwYWNlIGFib3ZlXG4gICAqL1xuICBnZXQgc2hvdWxkT3BlbkJvdHRvbSgpIHtcbiAgICBpZiAodGhpcy5ub2Rlcy5wb3BvdmVyID09PSB2b2lkIDAgfHwgdGhpcy5ub2Rlcy5wb3BvdmVyID09PSBudWxsKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHQgPSB0aGlzLnNjb3BlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHRoaXMuc2l6ZS5oZWlnaHQsIGkgPSBlLnRvcCArIG8sIHMgPSBlLnRvcCAtIG8sIHIgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHQuYm90dG9tKTtcbiAgICByZXR1cm4gcyA8IHQudG9wIHx8IGkgPD0gcjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvcG92ZXIgc2hvdWxkIGJlIG9wZW5lZCBsZWZ0LlxuICAgKiBJdCBzaG91bGQgaGFwcGVuIHdoZW4gdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGluIHRoZSByaWdodCBvciBub3QgZW5vdWdoIHNwYWNlIGluIHRoZSBsZWZ0XG4gICAqL1xuICBnZXQgc2hvdWxkT3BlblJpZ2h0KCkge1xuICAgIGlmICh0aGlzLm5vZGVzLnBvcG92ZXIgPT09IHZvaWQgMCB8fCB0aGlzLm5vZGVzLnBvcG92ZXIgPT09IG51bGwpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgZSA9IHRoaXMubm9kZXMucG9wb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdCA9IHRoaXMuc2NvcGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0gdGhpcy5zaXplLndpZHRoLCBpID0gZS5yaWdodCArIG8sIHMgPSBlLmxlZnQgLSBvLCByID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHQucmlnaHQpO1xuICAgIHJldHVybiBzIDwgdC5sZWZ0IHx8IGkgPD0gcjtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICB2YXIgaTtcbiAgICBjb25zdCBlID0ge1xuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgd2lkdGg6IDBcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vZGVzLnBvcG92ZXIgPT09IG51bGwpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCB0ID0gdGhpcy5ub2Rlcy5wb3BvdmVyLmNsb25lTm9kZSghMCk7XG4gICAgdC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgdC5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIiwgdC5jbGFzc0xpc3QuYWRkKFAucG9wb3Zlck9wZW5lZCksIChpID0gdC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgUC5wb3BvdmVyTmVzdGVkKSkgPT0gbnVsbCB8fCBpLnJlbW92ZSgpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO1xuICAgIGNvbnN0IG8gPSB0LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBQLnBvcG92ZXJDb250YWluZXIpO1xuICAgIHJldHVybiBlLmhlaWdodCA9IG8ub2Zmc2V0SGVpZ2h0LCBlLndpZHRoID0gby5vZmZzZXRXaWR0aCwgdC5yZW1vdmUoKSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGVsZW1lbnRzIGF2YWlsYWJsZSBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICovXG4gIGdldCBmbGlwcGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoKHQpID0+IHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgcmUpXG4gICAgICAgIHJldHVybiB0LmdldEVsZW1lbnQoKTtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgU2UpXG4gICAgICAgIHJldHVybiB0LmdldENvbnRyb2xzKCk7XG4gICAgfSkuZmxhdCgpLmZpbHRlcigodCkgPT4gdCAhPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBzZWFyY2ggdG8gdGhlIHBvcG92ZXJcbiAgICovXG4gIGFkZFNlYXJjaCgpIHtcbiAgICB0aGlzLnNlYXJjaCA9IG5ldyBscyh7XG4gICAgICBpdGVtczogdGhpcy5pdGVtc0RlZmF1bHQsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5tZXNzYWdlcy5zZWFyY2hcbiAgICB9KSwgdGhpcy5zZWFyY2gub24oVWUuU2VhcmNoLCB0aGlzLm9uU2VhcmNoKTtcbiAgICBjb25zdCBlID0gdGhpcy5zZWFyY2guZ2V0RWxlbWVudCgpO1xuICAgIGUuY2xhc3NMaXN0LmFkZChQLnNlYXJjaCksIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIG5vdGhpbmcgZm91bmQgbWVzc2FnZSB2aXNpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc3BsYXllZCAtIHRydWUgaWYgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgdG9nZ2xlTm90aGluZ0ZvdW5kTWVzc2FnZShlKSB7XG4gICAgdGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlLmNsYXNzTGlzdC50b2dnbGUoUC5ub3RoaW5nRm91bmRNZXNzYWdlRGlzcGxheWVkLCBlKTtcbiAgfVxufTtcbnVzKFtcbiAgbWVcbl0sIGVuLnByb3RvdHlwZSwgXCJzaXplXCIsIDEpO1xubGV0IEJ0ID0gZW47XG5jbGFzcyBocyBleHRlbmRzIEJ0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBpbnN0YW5jZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgdCA9ICFiZSgpO1xuICAgIHN1cGVyKFxuICAgICAge1xuICAgICAgICAuLi5lLFxuICAgICAgICBjbGFzczogUC5wb3BvdmVySW5saW5lXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBbXy5EZWZhdWx0XToge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdlIHVzZSBidXR0b24gaW5zdGVhZCBvZiBkaXYgaGVyZSB0byBmaXggYnVnIGFzc29jaWF0ZWQgd2l0aCBmb2N1cyBsb3NzICh3aGljaCBsZWFkcyB0byBzZWxlY3Rpb24gY2hhbmdlKSBvbiBjbGljayBpbiBzYWZhcmlcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEB0b2RvIGZpZ3VyZSBvdXQgYmV0dGVyIHdheSB0byBzb2x2ZSB0aGUgaXNzdWVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB3cmFwcGVyVGFnOiBcImJ1dHRvblwiLFxuICAgICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBcImNlbnRlclwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW18uSHRtbF06IHtcbiAgICAgICAgICBoaW50OiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICAgICAgICAgIGFsaWdubWVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApLCB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgICEobyBpbnN0YW5jZW9mIHJlKSAmJiAhKG8gaW5zdGFuY2VvZiBTZSkgfHwgby5oYXNDaGlsZHJlbiAmJiBvLmlzQ2hpbGRyZW5PcGVuICYmIHRoaXMuc2hvd05lc3RlZEl0ZW1zKG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZpc2libGUgZWxlbWVudCBvZmZzZXQgdG9wXG4gICAqL1xuICBnZXQgb2Zmc2V0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyID09PSBudWxsID8gMCA6IHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5vZmZzZXRMZWZ0O1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5uZXN0aW5nTGV2ZWwgPT09IDAgJiYgdGhpcy5ub2Rlcy5wb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgZmUuSW5saW5lUG9wb3ZlcldpZHRoLFxuICAgICAgdGhpcy5zaXplLndpZHRoICsgXCJweFwiXG4gICAgKSwgc3VwZXIuc2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIGhvdmVyIGV2ZW50IGhhbmRsaW5nLlxuICAgKiBPdmVycmlkZXMgcGFyZW50J3MgY2xhc3MgYmVoYXZpb3JcbiAgICovXG4gIGhhbmRsZUhvdmVyKCkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIENTUyB2YXJpYWJsZSB3aXRoIHBvc2l0aW9uIG9mIGl0ZW0gbmVhciB3aGljaCBuZXN0ZWQgcG9wb3ZlciBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgKiBJcyB1c2VkIHRvIHBvc2l0aW9uIG5lc3RlZCBwb3BvdmVyIHJpZ2h0IGJlbG93IGNsaWNrZWQgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0gbmVzdGVkUG9wb3ZlckVsIC0gbmVzdGVkIHBvcG92ZXIgZWxlbWVudFxuICAgKiBAcGFyYW0gaXRlbSDigJMgaXRlbSBuZWFyIHdoaWNoIG5lc3RlZCBwb3BvdmVyIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIHNldFRyaWdnZXJJdGVtUG9zaXRpb24oZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0LmdldEVsZW1lbnQoKSwgaSA9IG8gPyBvLm9mZnNldExlZnQgOiAwLCBzID0gdGhpcy5vZmZzZXRMZWZ0ICsgaTtcbiAgICBlLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgZmUuVHJpZ2dlckl0ZW1MZWZ0LFxuICAgICAgcyArIFwicHhcIlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGlzcGxheWluZyBuZXN0ZWQgaXRlbXMgZm9yIHRoZSBpdGVtLlxuICAgKiBPdmVycmlkaW5nIGluIG9yZGVyIHRvIGFkZCB0b2dnbGluZyBiZWhhdmlvdXJcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0g4oCTIGl0ZW0gdG8gdG9nZ2xlIG5lc3RlZCBwb3BvdmVyIGZvclxuICAgKi9cbiAgc2hvd05lc3RlZEl0ZW1zKGUpIHtcbiAgICBpZiAodGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gPT09IGUpIHtcbiAgICAgIHRoaXMuZGVzdHJveU5lc3RlZFBvcG92ZXJJZkV4aXN0cygpLCB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnNob3dOZXN0ZWRJdGVtcyhlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgbmVzdGVkIHBvcG92ZXIgZm9yIHNwZWNpZmllZCBpdGVtLlxuICAgKiBJcyB1c2VkIG9ubHkgb24gZGVza3RvcFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gZGlzcGxheSBuZXN0ZWQgcG9wb3ZlciBieVxuICAgKi9cbiAgc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpIHtcbiAgICBjb25zdCB0ID0gc3VwZXIuc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpO1xuICAgIHJldHVybiB0LmdldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFAuZ2V0UG9wb3Zlck5lc3RlZENsYXNzKHQubmVzdGluZ0xldmVsKSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IGl0ZW0gY2xpY2sgaGFuZGxpbmcuXG4gICAqIEhlbHBzIHRvIGNsb3NlIG5lc3RlZCBwb3BvdmVyIG9uY2Ugb3RoZXIgaXRlbSBpcyBjbGlja2VkLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGNsaWNrZWQgaXRlbVxuICAgKi9cbiAgaGFuZGxlSXRlbUNsaWNrKGUpIHtcbiAgICB2YXIgdDtcbiAgICBlICE9PSB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSAmJiAoKHQgPSB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSkgPT0gbnVsbCB8fCB0LmhhbmRsZUNsaWNrKCksIHN1cGVyLmRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSksIHN1cGVyLmhhbmRsZUl0ZW1DbGljayhlKTtcbiAgfVxufVxuY29uc3Qgb24gPSBjbGFzcyB4ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBMb2NrcyBib2R5IGVsZW1lbnQgc2Nyb2xsXG4gICAqL1xuICBsb2NrKCkge1xuICAgIHB0ID8gdGhpcy5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHhlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIGJvZHkgZWxlbWVudCBzY3JvbGxcbiAgICovXG4gIHVubG9jaygpIHtcbiAgICBwdCA/IHRoaXMudW5sb2NrSGFyZCgpIDogZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHhlLkNTUy5zY3JvbGxMb2NrZWQpO1xuICB9XG4gIC8qKlxuICAgKiBMb2NrcyBzY3JvbGwgaW4gYSBoYXJkIHdheSAodmlhIHNldHRpbmcgZml4ZWQgcG9zaXRpb24gdG8gYm9keSBlbGVtZW50KVxuICAgKi9cbiAgbG9ja0hhcmQoKSB7XG4gICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgXCItLXdpbmRvdy1zY3JvbGwtb2Zmc2V0XCIsXG4gICAgICBgJHt0aGlzLnNjcm9sbFBvc2l0aW9ufXB4YFxuICAgICksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh4ZS5DU1Muc2Nyb2xsTG9ja2VkSGFyZCk7XG4gIH1cbiAgLyoqXG4gICAqIFVubG9ja3MgaGFyZCBzY3JvbGwgbG9ja1xuICAgKi9cbiAgdW5sb2NrSGFyZCgpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoeGUuQ1NTLnNjcm9sbExvY2tlZEhhcmQpLCB0aGlzLnNjcm9sbFBvc2l0aW9uICE9PSBudWxsICYmIHdpbmRvdy5zY3JvbGxUbygwLCB0aGlzLnNjcm9sbFBvc2l0aW9uKSwgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIH1cbn07XG5vbi5DU1MgPSB7XG4gIHNjcm9sbExvY2tlZDogXCJjZS1zY3JvbGwtbG9ja2VkXCIsXG4gIHNjcm9sbExvY2tlZEhhcmQ6IFwiY2Utc2Nyb2xsLWxvY2tlZC0taGFyZFwiXG59O1xubGV0IHBzID0gb247XG5jb25zdCBhdCA9IG5lKFwiY2UtcG9wb3Zlci1oZWFkZXJcIiksIGx0ID0ge1xuICByb290OiBhdCgpLFxuICB0ZXh0OiBhdChcInRleHRcIiksXG4gIGJhY2tCdXR0b246IGF0KFwiYmFjay1idXR0b25cIilcbn07XG5jbGFzcyBmcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBoZWFkZXIgcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IHRleHQ6IGUsIG9uQmFja0J1dHRvbkNsaWNrOiB0IH0pIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBfZSgpLCB0aGlzLnRleHQgPSBlLCB0aGlzLm9uQmFja0J1dHRvbkNsaWNrID0gdCwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IGQubWFrZShcImRpdlwiLCBbbHQucm9vdF0pLFxuICAgICAgYmFja0J1dHRvbjogZC5tYWtlKFwiYnV0dG9uXCIsIFtsdC5iYWNrQnV0dG9uXSksXG4gICAgICB0ZXh0OiBkLm1ha2UoXCJkaXZcIiwgW2x0LnRleHRdKVxuICAgIH0sIHRoaXMubm9kZXMuYmFja0J1dHRvbi5pbm5lckhUTUwgPSBWaSwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMuYmFja0J1dHRvbiksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMuYmFja0J1dHRvbiwgXCJjbGlja1wiLCB0aGlzLm9uQmFja0J1dHRvbkNsaWNrKSwgdGhpcy5ub2Rlcy50ZXh0LmlubmVyVGV4dCA9IHRoaXMudGV4dCwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMudGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcG9wb3ZlciBoZWFkZXIgcm9vdCBodG1sIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm9kZXMucm9vdC5yZW1vdmUoKSwgdGhpcy5saXN0ZW5lcnMuZGVzdHJveSgpO1xuICB9XG59XG5jbGFzcyBncyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIG5ldyBwb3BvdmVyIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIG5ldyBzdGF0ZVxuICAgKi9cbiAgcHVzaChlKSB7XG4gICAgdGhpcy5oaXN0b3J5LnB1c2goZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcCBsYXN0IHBvcG92ZXIgc3RhdGVcbiAgICovXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5LnBvcCgpO1xuICB9XG4gIC8qKlxuICAgKiBUaXRsZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5Lmxlbmd0aCA9PT0gMCA/IFwiXCIgOiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdLnRpdGxlO1xuICB9XG4gIC8qKlxuICAgKiBJdGVtcyBsaXN0IHJldHJpZXZlZCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlXG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnkubGVuZ3RoID09PSAwID8gW10gOiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdLml0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgdG8gaW5pdGlhbCBwb3BvdmVyIHN0YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKDsgdGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDE7IClcbiAgICAgIHRoaXMucG9wKCk7XG4gIH1cbn1cbmNsYXNzIG5uIGV4dGVuZHMgSm8ge1xuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gcG9wb3ZlciBwYXJhbXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlLCB7XG4gICAgICBbXy5EZWZhdWx0XToge1xuICAgICAgICBoaW50OiB7XG4gICAgICAgICAgZW5hYmxlZDogITFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtfLkh0bWxdOiB7XG4gICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICBlbmFibGVkOiAhMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIHRoaXMuc2Nyb2xsTG9ja2VyID0gbmV3IHBzKCksIHRoaXMuaGlzdG9yeSA9IG5ldyBncygpLCB0aGlzLmlzSGlkZGVuID0gITAsIHRoaXMubm9kZXMub3ZlcmxheSA9IGQubWFrZShcImRpdlwiLCBbUC5vdmVybGF5LCBQLm92ZXJsYXlIaWRkZW5dKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmluc2VydEJlZm9yZSh0aGlzLm5vZGVzLm92ZXJsYXksIHRoaXMubm9kZXMucG9wb3Zlci5maXJzdENoaWxkKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5vdmVybGF5LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pLCB0aGlzLmhpc3RvcnkucHVzaCh7IGl0ZW1zOiBlLml0ZW1zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHBvcG92ZXJcbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5ub2Rlcy5vdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoUC5vdmVybGF5SGlkZGVuKSwgc3VwZXIuc2hvdygpLCB0aGlzLnNjcm9sbExvY2tlci5sb2NrKCksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHBvcG92ZXJcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5pc0hpZGRlbiB8fCAoc3VwZXIuaGlkZSgpLCB0aGlzLm5vZGVzLm92ZXJsYXkuY2xhc3NMaXN0LmFkZChQLm92ZXJsYXlIaWRkZW4pLCB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKSwgdGhpcy5oaXN0b3J5LnJlc2V0KCksIHRoaXMuaXNIaWRkZW4gPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBkaXNwbGF5aW5nIG5lc3RlZCBpdGVtcyBmb3IgdGhlIGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0g4oCTwqBpdGVtIHRvIHNob3cgbmVzdGVkIHBvcG92ZXIgZm9yXG4gICAqL1xuICBzaG93TmVzdGVkSXRlbXMoZSkge1xuICAgIHRoaXMudXBkYXRlSXRlbXNBbmRIZWFkZXIoZS5jaGlsZHJlbiwgZS50aXRsZSksIHRoaXMuaGlzdG9yeS5wdXNoKHtcbiAgICAgIHRpdGxlOiBlLnRpdGxlLFxuICAgICAgaXRlbXM6IGUuY2hpbGRyZW5cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyByZW5kZXJlZCBwb3BvdmVyIGl0ZW1zIGFuZCBoZWFkZXIgYW5kIGRpc3BsYXlzIG5ldyBvbmVzXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIG5ldyBwb3BvdmVyIGl0ZW1zXG4gICAqIEBwYXJhbSB0aXRsZSAtIG5ldyBwb3BvdmVyIGhlYWRlciB0ZXh0XG4gICAqL1xuICB1cGRhdGVJdGVtc0FuZEhlYWRlcihlLCB0KSB7XG4gICAgaWYgKHRoaXMuaGVhZGVyICE9PSBudWxsICYmIHRoaXMuaGVhZGVyICE9PSB2b2lkIDAgJiYgKHRoaXMuaGVhZGVyLmRlc3Ryb3koKSwgdGhpcy5oZWFkZXIgPSBudWxsKSwgdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmhlYWRlciA9IG5ldyBmcyh7XG4gICAgICAgIHRleHQ6IHQsXG4gICAgICAgIG9uQmFja0J1dHRvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpLCB0aGlzLnVwZGF0ZUl0ZW1zQW5kSGVhZGVyKHRoaXMuaGlzdG9yeS5jdXJyZW50SXRlbXMsIHRoaXMuaGlzdG9yeS5jdXJyZW50VGl0bGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmhlYWRlci5nZXRFbGVtZW50KCk7XG4gICAgICBvICE9PSBudWxsICYmIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5pbnNlcnRCZWZvcmUobywgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuIChpID0gby5nZXRFbGVtZW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBpLnJlbW92ZSgpO1xuICAgIH0pLCB0aGlzLml0ZW1zID0gdGhpcy5idWlsZEl0ZW1zKGUpLCB0aGlzLml0ZW1zLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgY29uc3QgaSA9IG8uZ2V0RWxlbWVudCgpO1xuICAgICAgaSAhPT0gbnVsbCAmJiAoKHMgPSB0aGlzLm5vZGVzLml0ZW1zKSA9PSBudWxsIHx8IHMuYXBwZW5kQ2hpbGQoaSkpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBtcyBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm9wZW5lZCA9ICExLCB0aGlzLnNlbGVjdGlvbiA9IG5ldyBiKCksIHRoaXMucG9wb3ZlciA9IG51bGwsIHRoaXMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9wZW5lZCAmJiAodGhpcy5vcGVuZWQgPSAhMSwgYi5pc0F0RWRpdG9yIHx8IHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24uY2xlYXJTYXZlZCgpLCAhdGhpcy5FZGl0b3IuQ3Jvc3NCbG9ja1NlbGVjdGlvbi5pc0Nyb3NzQmxvY2tTZWxlY3Rpb25TdGFydGVkICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24udW5zZWxlY3RCbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQodGhpcy5ldmVudHMuY2xvc2VkKSwgdGhpcy5wb3BvdmVyICYmICh0aGlzLnBvcG92ZXIub2ZmKEcuQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5wb3BvdmVyLmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKS5yZW1vdmUoKSwgdGhpcy5wb3BvdmVyID0gbnVsbCkpO1xuICAgIH0sIHRoaXMub25Qb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIEV2ZW50c1xuICAgKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiBcImJsb2NrLXNldHRpbmdzLW9wZW5lZFwiLFxuICAgICAgY2xvc2VkOiBcImJsb2NrLXNldHRpbmdzLWNsb3NlZFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQmxvY2sgU2V0dGluZ3MgQ1NTXG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXR0aW5nczogXCJjZS1zZXR0aW5nc1wiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciBpbm5lciBwb3BvdmVyJ3MgZmxpcHBlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAdG9kbyByZW1vdmUgb25jZSBCbG9ja1NldHRpbmdzIGJlY29tZXMgc3RhbmRhbG9uZSBub24tbW9kdWxlIGNsYXNzXG4gICAqL1xuICBnZXQgZmxpcHBlcigpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAodGhpcy5wb3BvdmVyICE9PSBudWxsKVxuICAgICAgcmV0dXJuIFwiZmxpcHBlclwiIGluIHRoaXMucG9wb3ZlciA/IChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsID8gdm9pZCAwIDogZS5mbGlwcGVyIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBQYW5lbCB3aXRoIGJsb2NrIHNldHRpbmdzIHdpdGggMiBzZWN0aW9uczpcbiAgICogIC0gVG9vbCdzIFNldHRpbmdzXG4gICAqICAtIERlZmF1bHQgU2V0dGluZ3MgW01vdmUsIFJlbW92ZSwgZXRjXVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgW3RoaXMuQ1NTLnNldHRpbmdzXSksIHRoaXMubm9kZXMud3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN5XCIsIFwiYmxvY2stdHVuZXNcIiksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihUZSwgdGhpcy5jbG9zZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIG1vZHVsZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbE5vZGVzKCksIHRoaXMubGlzdGVuZXJzLmRlc3Ryb3koKSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9mZihUZSwgdGhpcy5jbG9zZSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gQmxvY2sgU2V0dGluZ3MgcGFuZVxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0QmxvY2sgLSBuZWFyIHdoaWNoIEJsb2NrIHdlIHNob3VsZCBvcGVuIEJsb2NrU2V0dGluZ3NcbiAgICovXG4gIGFzeW5jIG9wZW4oZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2spIHtcbiAgICB2YXIgcztcbiAgICB0aGlzLm9wZW5lZCA9ICEwLCB0aGlzLnNlbGVjdGlvbi5zYXZlKCksIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnNlbGVjdEJsb2NrKGUpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhckNhY2hlKCk7XG4gICAgY29uc3QgeyB0b29sVHVuZXM6IHQsIGNvbW1vblR1bmVzOiBvIH0gPSBlLmdldFR1bmVzKCk7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQodGhpcy5ldmVudHMub3BlbmVkKTtcbiAgICBjb25zdCBpID0gYmUoKSA/IG5uIDogQnQ7XG4gICAgdGhpcy5wb3BvdmVyID0gbmV3IGkoe1xuICAgICAgc2VhcmNoYWJsZTogITAsXG4gICAgICBpdGVtczogYXdhaXQgdGhpcy5nZXRUdW5lc0l0ZW1zKGUsIG8sIHQpLFxuICAgICAgc2NvcGVFbGVtZW50OiB0aGlzLkVkaXRvci5BUEkubWV0aG9kcy51aS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogei51aShLLnVpLnBvcG92ZXIsIFwiTm90aGluZyBmb3VuZFwiKSxcbiAgICAgICAgc2VhcmNoOiB6LnVpKEsudWkucG9wb3ZlciwgXCJGaWx0ZXJcIilcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5wb3BvdmVyLm9uKEcuQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgKHMgPSB0aGlzLm5vZGVzLndyYXBwZXIpID09IG51bGwgfHwgcy5hcHBlbmQodGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSksIHRoaXMucG9wb3Zlci5zaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcm9vdCBibG9jayBzZXR0aW5ncyBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBpdGVtcyB0byBiZSBkaXNwbGF5ZWQgaW4gYmxvY2sgdHVuZXMgbWVudS5cbiAgICogTWVyZ2VzIHRvb2wgc3BlY2lmaWMgdHVuZXMsIGNvbnZlcnNpb24gbWVudSBhbmQgY29tbW9uIHR1bmVzIGluIG9uZSBsaXN0IGluIHByZWRlZmluZWQgb3JkZXJcbiAgICpcbiAgICogQHBhcmFtIGN1cnJlbnRCbG9jayDigJMgIGJsb2NrIHdlIGFyZSBhYm91dCB0byBvcGVuIGJsb2NrIHR1bmVzIGZvclxuICAgKiBAcGFyYW0gY29tbW9uVHVuZXMg4oCTIGNvbW1vbiB0dW5lc1xuICAgKiBAcGFyYW0gdG9vbFR1bmVzIC0gdG9vbCBzcGVjaWZpYyB0dW5lc1xuICAgKi9cbiAgYXN5bmMgZ2V0VHVuZXNJdGVtcyhlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIG8gIT09IHZvaWQgMCAmJiBvLmxlbmd0aCA+IDAgJiYgKGkucHVzaCguLi5vKSwgaS5wdXNoKHtcbiAgICAgIHR5cGU6IF8uU2VwYXJhdG9yXG4gICAgfSkpO1xuICAgIGNvbnN0IHMgPSBBcnJheS5mcm9tKHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMudmFsdWVzKCkpLCBhID0gKGF3YWl0IFlvKGUsIHMpKS5yZWR1Y2UoKGwsIGMpID0+IChjLnRvb2xib3guZm9yRWFjaCgodSkgPT4ge1xuICAgICAgbC5wdXNoKHtcbiAgICAgICAgaWNvbjogdS5pY29uLFxuICAgICAgICB0aXRsZTogei50KEsudG9vbE5hbWVzLCB1LnRpdGxlKSxcbiAgICAgICAgbmFtZTogYy5uYW1lLFxuICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICBvbkFjdGl2YXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGgsIENhcmV0OiBwLCBUb29sYmFyOiBnIH0gPSB0aGlzLkVkaXRvciwgZiA9IGF3YWl0IGguY29udmVydChlLCBjLm5hbWUsIHUuZGF0YSk7XG4gICAgICAgICAgZy5jbG9zZSgpLCBwLnNldFRvQmxvY2soZiwgcC5wb3NpdGlvbnMuRU5EKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIGwpLCBbXSk7XG4gICAgcmV0dXJuIGEubGVuZ3RoID4gMCAmJiAoaS5wdXNoKHtcbiAgICAgIGljb246IEdvLFxuICAgICAgbmFtZTogXCJjb252ZXJ0LXRvXCIsXG4gICAgICB0aXRsZTogei51aShLLnVpLnBvcG92ZXIsIFwiQ29udmVydCB0b1wiKSxcbiAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgIHNlYXJjaGFibGU6ICEwLFxuICAgICAgICBpdGVtczogYVxuICAgICAgfVxuICAgIH0pLCBpLnB1c2goe1xuICAgICAgdHlwZTogXy5TZXBhcmF0b3JcbiAgICB9KSksIGkucHVzaCguLi50KSwgaS5tYXAoKGwpID0+IHRoaXMucmVzb2x2ZVR1bmVBbGlhc2VzKGwpKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgYWxpYXNlcyBpbiB0dW5lcyBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB3aXRoIHJlc29sdmVkIGFsaWFzZXNcbiAgICovXG4gIHJlc29sdmVUdW5lQWxpYXNlcyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gXy5TZXBhcmF0b3IgfHwgZS50eXBlID09PSBfLkh0bWwpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCB0ID0gWWkoZSwgeyBsYWJlbDogXCJ0aXRsZVwiIH0pO1xuICAgIHJldHVybiBlLmNvbmZpcm1hdGlvbiAmJiAodC5jb25maXJtYXRpb24gPSB0aGlzLnJlc29sdmVUdW5lQWxpYXNlcyhlLmNvbmZpcm1hdGlvbikpLCB0O1xuICB9XG59XG52YXIgc24gPSB7IGV4cG9ydHM6IHt9IH07XG4vKiFcbiAqIExpYnJhcnkgZm9yIGhhbmRsaW5nIGtleWJvYXJkIHNob3J0Y3V0c1xuICogQGNvcHlyaWdodCBDb2RlWCAoaHR0cHM6Ly9jb2RleC5zbylcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBDb2RlWCAoaHR0cHM6Ly9jb2RleC5zbylcbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKi9cbihmdW5jdGlvbihuLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgbi5leHBvcnRzID0gbygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICAgIGlmIChvW3NdKVxuICAgICAgICAgIHJldHVybiBvW3NdLmV4cG9ydHM7XG4gICAgICAgIHZhciByID0gb1tzXSA9IHsgaTogcywgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiB0W3NdLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIGkpLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkubSA9IHQsIGkuYyA9IG8sIGkuZCA9IGZ1bmN0aW9uKHMsIHIsIGEpIHtcbiAgICAgICAgaS5vKHMsIHIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCByLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGEgfSk7XG4gICAgICB9LCBpLnIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIGkudCA9IGZ1bmN0aW9uKHMsIHIpIHtcbiAgICAgICAgaWYgKDEgJiByICYmIChzID0gaShzKSksIDggJiByIHx8IDQgJiByICYmIHR5cGVvZiBzID09IFwib2JqZWN0XCIgJiYgcyAmJiBzLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIHZhciBhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmIChpLnIoYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IHMgfSksIDIgJiByICYmIHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBzKVxuICAgICAgICAgICAgaS5kKGEsIGwsIChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzW2NdO1xuICAgICAgICAgICAgfSkuYmluZChudWxsLCBsKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgaS5uID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgciA9IHMgJiYgcy5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHMuZGVmYXVsdDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaS5kKHIsIFwiYVwiLCByKSwgcjtcbiAgICAgIH0sIGkubyA9IGZ1bmN0aW9uKHMsIHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCByKTtcbiAgICAgIH0sIGkucCA9IFwiXCIsIGkoaS5zID0gMCk7XG4gICAgfShbZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgZnVuY3Rpb24gcyhsLCBjKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgYy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgIHZhciBoID0gY1t1XTtcbiAgICAgICAgICBoLmVudW1lcmFibGUgPSBoLmVudW1lcmFibGUgfHwgITEsIGguY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBoICYmIChoLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobCwgaC5rZXksIGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByKGwsIGMsIHUpIHtcbiAgICAgICAgcmV0dXJuIGMgJiYgcyhsLnByb3RvdHlwZSwgYyksIHUgJiYgcyhsLCB1KSwgbDtcbiAgICAgIH1cbiAgICAgIGkucihvKTtcbiAgICAgIHZhciBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGwoYykge1xuICAgICAgICAgIHZhciB1ID0gdGhpcztcbiAgICAgICAgICAoZnVuY3Rpb24oaCwgcCkge1xuICAgICAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIHApKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH0pKHRoaXMsIGwpLCB0aGlzLmNvbW1hbmRzID0ge30sIHRoaXMua2V5cyA9IHt9LCB0aGlzLm5hbWUgPSBjLm5hbWUsIHRoaXMucGFyc2VTaG9ydGN1dE5hbWUoYy5uYW1lKSwgdGhpcy5lbGVtZW50ID0gYy5vbiwgdGhpcy5jYWxsYmFjayA9IGMuY2FsbGJhY2ssIHRoaXMuZXhlY3V0ZVNob3J0Y3V0ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgdS5leGVjdXRlKGgpO1xuICAgICAgICAgIH0sIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCwgITEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByKGwsIG51bGwsIFt7IGtleTogXCJzdXBwb3J0ZWRDb21tYW5kc1wiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IFNISUZUOiBbXCJTSElGVFwiXSwgQ01EOiBbXCJDTURcIiwgXCJDT05UUk9MXCIsIFwiQ09NTUFORFwiLCBcIldJTkRPV1NcIiwgXCJDVFJMXCJdLCBBTFQ6IFtcIkFMVFwiLCBcIk9QVElPTlwiXSB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcImtleUNvZGVzXCIsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHsgMDogNDgsIDE6IDQ5LCAyOiA1MCwgMzogNTEsIDQ6IDUyLCA1OiA1MywgNjogNTQsIDc6IDU1LCA4OiA1NiwgOTogNTcsIEE6IDY1LCBCOiA2NiwgQzogNjcsIEQ6IDY4LCBFOiA2OSwgRjogNzAsIEc6IDcxLCBIOiA3MiwgSTogNzMsIEo6IDc0LCBLOiA3NSwgTDogNzYsIE06IDc3LCBOOiA3OCwgTzogNzksIFA6IDgwLCBROiA4MSwgUjogODIsIFM6IDgzLCBUOiA4NCwgVTogODUsIFY6IDg2LCBXOiA4NywgWDogODgsIFk6IDg5LCBaOiA5MCwgQkFDS1NQQUNFOiA4LCBFTlRFUjogMTMsIEVTQ0FQRTogMjcsIExFRlQ6IDM3LCBVUDogMzgsIFJJR0hUOiAzOSwgRE9XTjogNDAsIElOU0VSVDogNDUsIERFTEVURTogNDYsIFwiLlwiOiAxOTAgfTtcbiAgICAgICAgfSB9XSksIHIobCwgW3sga2V5OiBcInBhcnNlU2hvcnRjdXROYW1lXCIsIHZhbHVlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgYyA9IGMuc3BsaXQoXCIrXCIpO1xuICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgYy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgY1t1XSA9IGNbdV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBoID0gITE7XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGwuc3VwcG9ydGVkQ29tbWFuZHMpXG4gICAgICAgICAgICAgIGlmIChsLnN1cHBvcnRlZENvbW1hbmRzW3BdLmluY2x1ZGVzKGNbdV0pKSB7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuY29tbWFuZHNbcF0gPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCB8fCAodGhpcy5rZXlzW2NbdV1dID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBnIGluIGwuc3VwcG9ydGVkQ29tbWFuZHMpXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzW2ddIHx8ICh0aGlzLmNvbW1hbmRzW2ddID0gITEpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImV4ZWN1dGVcIiwgdmFsdWU6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICB2YXIgdSwgaCA9IHsgQ01EOiBjLmN0cmxLZXkgfHwgYy5tZXRhS2V5LCBTSElGVDogYy5zaGlmdEtleSwgQUxUOiBjLmFsdEtleSB9LCBwID0gITA7XG4gICAgICAgICAgZm9yICh1IGluIHRoaXMuY29tbWFuZHMpXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzW3VdICE9PSBoW3VdICYmIChwID0gITEpO1xuICAgICAgICAgIHZhciBnLCBmID0gITA7XG4gICAgICAgICAgZm9yIChnIGluIHRoaXMua2V5cylcbiAgICAgICAgICAgIGYgPSBmICYmIGMua2V5Q29kZSA9PT0gbC5rZXlDb2Rlc1tnXTtcbiAgICAgICAgICBwICYmIGYgJiYgdGhpcy5jYWxsYmFjayhjKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJyZW1vdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCk7XG4gICAgICAgIH0gfV0pLCBsO1xuICAgICAgfSgpO1xuICAgICAgby5kZWZhdWx0ID0gYTtcbiAgICB9XSkuZGVmYXVsdDtcbiAgfSk7XG59KShzbik7XG52YXIgYnMgPSBzbi5leHBvcnRzO1xuY29uc3QgdnMgPSAvKiBAX19QVVJFX18gKi8gS2UoYnMpO1xuY2xhc3Mga3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBzaG9ydGN1dFxuICAgKlxuICAgKiBAcGFyYW0gc2hvcnRjdXQgLSBzaG9ydGN1dCBvcHRpb25zXG4gICAqL1xuICBhZGQoZSkge1xuICAgIGlmICh0aGlzLmZpbmRTaG9ydGN1dChlLm9uLCBlLm5hbWUpKVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBTaG9ydGN1dCAke2UubmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciAke2Uub259LiBQbGVhc2UgcmVtb3ZlIGl0IGJlZm9yZSBhZGQgYSBuZXcgaGFuZGxlci5gXG4gICAgICApO1xuICAgIGNvbnN0IG8gPSBuZXcgdnMoe1xuICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgb246IGUub24sXG4gICAgICBjYWxsYmFjazogZS5oYW5kbGVyXG4gICAgfSksIGkgPSB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuZ2V0KGUub24pIHx8IFtdO1xuICAgIHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5zZXQoZS5vbiwgWy4uLmksIG9dKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gRWxlbWVudCBzaG9ydGN1dCBpcyBzZXQgZm9yXG4gICAqIEBwYXJhbSBuYW1lIC0gc2hvcnRjdXQgbmFtZVxuICAgKi9cbiAgcmVtb3ZlKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5maW5kU2hvcnRjdXQoZSwgdCk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuO1xuICAgIG8ucmVtb3ZlKCk7XG4gICAgY29uc3QgaSA9IHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLnNldChlLCBpLmZpbHRlcigocykgPT4gcyAhPT0gbykpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgU2hvcnRjdXQgaW5zdGFuY2UgaWYgZXhpc3RcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHNob3JjdXQgaXMgc2V0IGZvclxuICAgKiBAcGFyYW0gc2hvcnRjdXQgLSBzaG9ydGN1dCBuYW1lXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IC0gc2hvcnRjdXQgaW5kZXggaWYgZXhpc3RcbiAgICovXG4gIGZpbmRTaG9ydGN1dChlLCB0KSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuZ2V0KGUpIHx8IFtdKS5maW5kKCh7IG5hbWU6IGkgfSkgPT4gaSA9PT0gdCk7XG4gIH1cbn1cbmNvbnN0IGdlID0gbmV3IGtzKCk7XG52YXIgeXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHdzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgcm4gPSAobiwgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gd3MoZSwgdCkgOiBlLCBzID0gbi5sZW5ndGggLSAxLCByOyBzID49IDA7IHMtLSlcbiAgICAociA9IG5bc10pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgeXMoZSwgdCwgaSksIGk7XG59LCBMZSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLk9wZW5lZCA9IFwidG9vbGJveC1vcGVuZWRcIiwgbi5DbG9zZWQgPSBcInRvb2xib3gtY2xvc2VkXCIsIG4uQmxvY2tBZGRlZCA9IFwidG9vbGJveC1ibG9jay1hZGRlZFwiLCBuKSkoTGUgfHwge30pO1xuY29uc3QgQ3QgPSBjbGFzcyBhbiBleHRlbmRzIE9lIHtcbiAgLyoqXG4gICAqIFRvb2xib3ggY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhdmFpbGFibGUgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IgQVBJIG1ldGhvZHNcbiAgICogQHBhcmFtIG9wdGlvbnMudG9vbHMgLSBUb29scyBhdmFpbGFibGUgdG8gY2hlY2sgd2hldGhlciBzb21lIG9mIHRoZW0gc2hvdWxkIGJlIGRpc3BsYXllZCBhdCB0aGUgVG9vbGJveCBvciBub3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlLCB0b29sczogdCwgaTE4bkxhYmVsczogbyB9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5saXN0ZW5lcnMgPSBuZXcgX2UoKSwgdGhpcy5wb3BvdmVyID0gbnVsbCwgdGhpcy5oYW5kbGVNb2JpbGVMYXlvdXRUb2dnbGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lQb3BvdmVyKCksIHRoaXMuaW5pdFBvcG92ZXIoKTtcbiAgICB9LCB0aGlzLm9uUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5lbWl0KFxuICAgICAgICBcInRvb2xib3gtY2xvc2VkXCJcbiAgICAgICAgLyogQ2xvc2VkICovXG4gICAgICApO1xuICAgIH0sIHRoaXMuYXBpID0gZSwgdGhpcy50b29scyA9IHQsIHRoaXMuaTE4bkxhYmVscyA9IG8sIHRoaXMuZW5hYmxlU2hvcnRjdXRzKCksIHRoaXMubm9kZXMgPSB7XG4gICAgICB0b29sYm94OiBkLm1ha2UoXCJkaXZcIiwgYW4uQ1NTLnRvb2xib3gpXG4gICAgfSwgdGhpcy5pbml0UG9wb3ZlcigpLCB0aGlzLm5vZGVzLnRvb2xib3guc2V0QXR0cmlidXRlKFwiZGF0YS1jeVwiLCBcInRvb2xib3hcIiksIHRoaXMuYXBpLmV2ZW50cy5vbihUZSwgdGhpcy5oYW5kbGVNb2JpbGVMYXlvdXRUb2dnbGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRydWUgaWYgVG9vbGJveCBpcyBFbXB0eSBhbmQgbm90aGluZyB0byBzaG93XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNUb0JlRGlzcGxheWVkLmxlbmd0aCA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogQ1NTIHN0eWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xib3g6IFwiY2UtdG9vbGJveFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByb290IGJsb2NrIHNldHRpbmdzIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMudG9vbGJveDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUb29sYm94IGhhcyB0aGUgRmxpcHBlciBhY3RpdmF0ZWQgYW5kIHRoZSBGbGlwcGVyIGhhcyBzZWxlY3RlZCBidXR0b25cbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIGlmICh0aGlzLnBvcG92ZXIgIT09IG51bGwpXG4gICAgICByZXR1cm4gXCJoYXNGb2N1c1wiIGluIHRoaXMucG9wb3ZlciA/IHRoaXMucG9wb3Zlci5oYXNGb2N1cygpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IE1vZHVsZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgZTtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy50b29sYm94ICYmIHRoaXMubm9kZXMudG9vbGJveC5yZW1vdmUoKSwgdGhpcy5yZW1vdmVBbGxTaG9ydGN1dHMoKSwgKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgZS5vZmYoRy5DbG9zZWQsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCksIHRoaXMuYXBpLmV2ZW50cy5vZmYoVGUsIHRoaXMuaGFuZGxlTW9iaWxlTGF5b3V0VG9nZ2xlKTtcbiAgfVxuICAvKipcbiAgICogVG9vbGJveCBUb29sJ3MgYnV0dG9uIGNsaWNrIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCB0eXBlIHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gQmxvY2sgZGF0YSBwcmVkZWZpbmVkIGJ5IHRoZSBhY3RpdmF0ZWQgVG9vbGJveCBpdGVtXG4gICAqL1xuICB0b29sQnV0dG9uQWN0aXZhdGVkKGUsIHQpIHtcbiAgICB0aGlzLmluc2VydE5ld0Jsb2NrKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xib3ggd2l0aCBUb29sc1xuICAgKi9cbiAgb3BlbigpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmlzRW1wdHkgfHwgKChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IGUuc2hvdygpLCB0aGlzLm9wZW5lZCA9ICEwLCB0aGlzLmVtaXQoXG4gICAgICBcInRvb2xib3gtb3BlbmVkXCJcbiAgICAgIC8qIE9wZW5lZCAqL1xuICAgICkpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBlLmhpZGUoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5lbWl0KFxuICAgICAgXCJ0b29sYm94LWNsb3NlZFwiXG4gICAgICAvKiBDbG9zZWQgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5vcGVuZWQgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0b29sYm94IHBvcG92ZXIgYW5kIGFwcGVuZHMgaXQgaW5zaWRlIHdyYXBwZXIgZWxlbWVudFxuICAgKi9cbiAgaW5pdFBvcG92ZXIoKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgZSA9IGJlKCkgPyBubiA6IEJ0O1xuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBlKHtcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5hcGkudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBzZWFyY2hhYmxlOiAhMCxcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogdGhpcy5pMThuTGFiZWxzLm5vdGhpbmdGb3VuZCxcbiAgICAgICAgc2VhcmNoOiB0aGlzLmkxOG5MYWJlbHMuZmlsdGVyXG4gICAgICB9LFxuICAgICAgaXRlbXM6IHRoaXMudG9vbGJveEl0ZW1zVG9CZURpc3BsYXllZFxuICAgIH0pLCB0aGlzLnBvcG92ZXIub24oRy5DbG9zZWQsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCAodCA9IHRoaXMubm9kZXMudG9vbGJveCkgPT0gbnVsbCB8fCB0LmFwcGVuZCh0aGlzLnBvcG92ZXIuZ2V0RWxlbWVudCgpKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgcG9wb3ZlciBpbnN0YW5jZSBhbmQgcmVtb3ZlcyBpdCBmcm9tIERPTVxuICAgKi9cbiAgZGVzdHJveVBvcG92ZXIoKSB7XG4gICAgdGhpcy5wb3BvdmVyICE9PSBudWxsICYmICh0aGlzLnBvcG92ZXIuaGlkZSgpLCB0aGlzLnBvcG92ZXIub2ZmKEcuQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5wb3BvdmVyLmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyID0gbnVsbCksIHRoaXMubm9kZXMudG9vbGJveCAhPT0gbnVsbCAmJiAodGhpcy5ub2Rlcy50b29sYm94LmlubmVySFRNTCA9IFwiXCIpO1xuICB9XG4gIGdldCB0b29sc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHJldHVybiB0aGlzLnRvb2xzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQudG9vbGJveCAmJiBlLnB1c2godCk7XG4gICAgfSksIGU7XG4gIH1cbiAgZ2V0IHRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgZSA9ICh0LCBvLCBpID0gITApID0+ICh7XG4gICAgICBpY29uOiB0Lmljb24sXG4gICAgICB0aXRsZTogei50KEsudG9vbE5hbWVzLCB0LnRpdGxlIHx8IGplKG8ubmFtZSkpLFxuICAgICAgbmFtZTogby5uYW1lLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnRvb2xCdXR0b25BY3RpdmF0ZWQoby5uYW1lLCB0LmRhdGEpO1xuICAgICAgfSxcbiAgICAgIHNlY29uZGFyeUxhYmVsOiBvLnNob3J0Y3V0ICYmIGkgPyB2dChvLnNob3J0Y3V0KSA6IFwiXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQucmVkdWNlKCh0LCBvKSA9PiAoQXJyYXkuaXNBcnJheShvLnRvb2xib3gpID8gby50b29sYm94LmZvckVhY2goKGksIHMpID0+IHtcbiAgICAgIHQucHVzaChlKGksIG8sIHMgPT09IDApKTtcbiAgICB9KSA6IG8udG9vbGJveCAhPT0gdm9pZCAwICYmIHQucHVzaChlKG8udG9vbGJveCwgbykpLCB0KSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlIGFsbCB0b29scyBhbmQgZW5hYmxlIHRoZWlycyBzaG9ydGN1dHMgaWYgc3BlY2lmaWVkXG4gICAqL1xuICBlbmFibGVTaG9ydGN1dHMoKSB7XG4gICAgdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IGUuc2hvcnRjdXQ7XG4gICAgICB0ICYmIHRoaXMuZW5hYmxlU2hvcnRjdXRGb3JUb29sKGUubmFtZSwgdCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBzaG9ydGN1dCBCbG9jayBUb29sIGltcGxlbWVudGVkIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sTmFtZSAtIFRvb2wgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnRjdXQgLSBzaG9ydGN1dCBhY2NvcmRpbmcgdG8gdGhlIFNob3J0Y3V0RGF0YSBNb2R1bGUgZm9ybWF0XG4gICAqL1xuICBlbmFibGVTaG9ydGN1dEZvclRvb2woZSwgdCkge1xuICAgIGdlLmFkZCh7XG4gICAgICBuYW1lOiB0LFxuICAgICAgb246IHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgaGFuZGxlcjogYXN5bmMgKG8pID0+IHtcbiAgICAgICAgby5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIHMgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGkpO1xuICAgICAgICBpZiAocylcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMuYXBpLmJsb2Nrcy5jb252ZXJ0KHMuaWQsIGUpO1xuICAgICAgICAgICAgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayhyLCBcImVuZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zZXJ0TmV3QmxvY2soZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGFkZGVkIHNob3J0Y3V0c1xuICAgKiBGaXJlZCB3aGVuIHRoZSBSZWFkLU9ubHkgbW9kZSBpcyBhY3RpdmF0ZWRcbiAgICovXG4gIHJlbW92ZUFsbFNob3J0Y3V0cygpIHtcbiAgICB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gZS5zaG9ydGN1dDtcbiAgICAgIHQgJiYgZ2UucmVtb3ZlKHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLCB0KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgYmxvY2tcbiAgICogQ2FuIGJlIGNhbGxlZCB3aGVuIGJ1dHRvbiBjbGlja2VkIG9uIFRvb2xib3ggb3IgYnkgU2hvcnRjdXREYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sTmFtZSAtIFRvb2wgbmFtZVxuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gcHJlZGVmaW5lZCBCbG9jayBkYXRhXG4gICAqL1xuICBhc3luYyBpbnNlcnROZXdCbG9jayhlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCBpID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChvKTtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IGkuaXNFbXB0eSA/IG8gOiBvICsgMTtcbiAgICBsZXQgcjtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgbCA9IGF3YWl0IHRoaXMuYXBpLmJsb2Nrcy5jb21wb3NlQmxvY2tEYXRhKGUpO1xuICAgICAgciA9IE9iamVjdC5hc3NpZ24obCwgdCk7XG4gICAgfVxuICAgIGNvbnN0IGEgPSB0aGlzLmFwaS5ibG9ja3MuaW5zZXJ0KFxuICAgICAgZSxcbiAgICAgIHIsXG4gICAgICB2b2lkIDAsXG4gICAgICBzLFxuICAgICAgdm9pZCAwLFxuICAgICAgaS5pc0VtcHR5XG4gICAgKTtcbiAgICBhLmNhbGwoZWUuQVBQRU5EX0NBTExCQUNLKSwgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayhzKSwgdGhpcy5lbWl0KFwidG9vbGJveC1ibG9jay1hZGRlZFwiLCB7XG4gICAgICBibG9jazogYVxuICAgIH0pLCB0aGlzLmFwaS50b29sYmFyLmNsb3NlKCk7XG4gIH1cbn07XG5ybihbXG4gIG1lXG5dLCBDdC5wcm90b3R5cGUsIFwidG9vbHNUb0JlRGlzcGxheWVkXCIsIDEpO1xucm4oW1xuICBtZVxuXSwgQ3QucHJvdG90eXBlLCBcInRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWRcIiwgMSk7XG5sZXQgRXMgPSBDdDtcbmNvbnN0IGxuID0gXCJibG9jayBob3ZlcmVkXCI7XG5hc3luYyBmdW5jdGlvbiB4cyhuLCBlKSB7XG4gIGNvbnN0IHQgPSBuYXZpZ2F0b3Iua2V5Ym9hcmQ7XG4gIGlmICghdClcbiAgICByZXR1cm4gZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGF3YWl0IHQuZ2V0TGF5b3V0TWFwKCkpLmdldChuKSB8fCBlO1xuICB9IGNhdGNoIChvKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IobyksIGU7XG4gIH1cbn1cbmNsYXNzIEJzIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24gLSBNb2R1bGUgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5jb25maWcgLSBFZGl0b3IncyBjb25maWdcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uZXZlbnRzRGlzcGF0Y2hlciAtIEVkaXRvcidzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ1NTIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbGJhcjogXCJjZS10b29sYmFyXCIsXG4gICAgICBjb250ZW50OiBcImNlLXRvb2xiYXJfX2NvbnRlbnRcIixcbiAgICAgIGFjdGlvbnM6IFwiY2UtdG9vbGJhcl9fYWN0aW9uc1wiLFxuICAgICAgYWN0aW9uc09wZW5lZDogXCJjZS10b29sYmFyX19hY3Rpb25zLS1vcGVuZWRcIixcbiAgICAgIHRvb2xiYXJPcGVuZWQ6IFwiY2UtdG9vbGJhci0tb3BlbmVkXCIsXG4gICAgICBvcGVuZWRUb29sYm94SG9sZGVyTW9kaWZpZXI6IFwiY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZFwiLFxuICAgICAgcGx1c0J1dHRvbjogXCJjZS10b29sYmFyX19wbHVzXCIsXG4gICAgICBwbHVzQnV0dG9uU2hvcnRjdXQ6IFwiY2UtdG9vbGJhcl9fcGx1cy1zaG9ydGN1dFwiLFxuICAgICAgc2V0dGluZ3NUb2dnbGVyOiBcImNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0blwiLFxuICAgICAgc2V0dGluZ3NUb2dnbGVySGlkZGVuOiBcImNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0taGlkZGVuXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUb29sYmFyIG9wZW5pbmcgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgb3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaWMgaW50ZXJmYWNlIGZvciBhY2Nlc3NpbmcgdGhlIFRvb2xib3hcbiAgICovXG4gIGdldCB0b29sYm94KCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IChlID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBlLm9wZW5lZCxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsIHx8IHQuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBvcGVuOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRvb2xib3hJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIFMoXCJ0b29sYm94Lm9wZW4oKSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uIGlzIGZpbmlzaGVkXCIsIFwid2FyblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayA9IHRoaXMuaG92ZXJlZEJsb2NrLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5vcGVuKCk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRvb2xib3hJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIFMoXCJ0b29sYm94LnRvZ2dsZSgpIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24gaXMgZmluaXNoZWRcIiwgXCJ3YXJuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2xib3hJbnN0YW5jZS50b2dnbGUoKTtcbiAgICAgIH0sXG4gICAgICBoYXNGb2N1czogKCkgPT4ge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgcmV0dXJuICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiB0Lmhhc0ZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQmxvY2sgYWN0aW9ucyBhcHBlYXJhbmNlIG1hbmlwdWxhdGlvbnNcbiAgICovXG4gIGdldCBibG9ja0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5hY3Rpb25zLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuYWN0aW9uc09wZW5lZCk7XG4gICAgICB9LFxuICAgICAgc2hvdzogKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVzLmFjdGlvbnMuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5hY3Rpb25zT3BlbmVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciB3b3JraW5nIHdpdGggQmxvY2sgVHVuZXMgdG9nZ2xlclxuICAgKi9cbiAgZ2V0IGJsb2NrVHVuZXNUb2dnbGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRlOiAoKSA9PiB0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnNldHRpbmdzVG9nZ2xlckhpZGRlbiksXG4gICAgICBzaG93OiAoKSA9PiB0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnNldHRpbmdzVG9nZ2xlckhpZGRlbilcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIHJlYWQtb25seSBtb2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gKHRoaXMuZGVzdHJveSgpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmRlc3Ryb3koKSwgdGhpcy5kaXNhYmxlTW9kdWxlQmluZGluZ3MoKSkgOiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLmRyYXdVSSgpLCB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gICAgfSwgeyB0aW1lb3V0OiAyZTMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgVG9vbGJhciB0byB0aGUgcGFzc2VkIChvciBjdXJyZW50KSBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBtb3ZlIFRvb2xiYXIgbmVhciBpdFxuICAgKi9cbiAgbW92ZUFuZE9wZW4oZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2spIHtcbiAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIFMoXCJDYW4ndCBvcGVuIFRvb2xiYXIgc2luY2UgRWRpdG9yIGluaXRpYWxpemF0aW9uIGlzIG5vdCBmaW5pc2hlZCB5ZXRcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2Uub3BlbmVkICYmIHRoaXMudG9vbGJveEluc3RhbmNlLmNsb3NlKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkICYmIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSwgIWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ob3ZlcmVkQmxvY2sgPSBlO1xuICAgIGNvbnN0IHQgPSBlLmhvbGRlciwgeyBpc01vYmlsZTogbyB9ID0gdGhpcy5FZGl0b3IuVUk7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgcyA9IDIwLCByID0gZS5maXJzdElucHV0LCBhID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbCA9IHIgIT09IHZvaWQgMCA/IHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsLCBjID0gbCAhPT0gbnVsbCA/IGwudG9wIC0gYS50b3AgOiBudWxsLCB1ID0gYyAhPT0gbnVsbCA/IGMgPiBzIDogdm9pZCAwO1xuICAgIGlmIChvKVxuICAgICAgaSA9IHQub2Zmc2V0VG9wICsgdC5vZmZzZXRIZWlnaHQ7XG4gICAgZWxzZSBpZiAociA9PT0gdm9pZCAwIHx8IHUpIHtcbiAgICAgIGNvbnN0IGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLnBsdWdpbnNDb250ZW50KS5wYWRkaW5nVG9wKTtcbiAgICAgIGkgPSB0Lm9mZnNldFRvcCArIGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSBsaShyKSwgcCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZXMucGx1c0J1dHRvbikuaGVpZ2h0LCAxMCksIGcgPSA4O1xuICAgICAgaSA9IHQub2Zmc2V0VG9wICsgaCAtIHAgKyBnICsgYztcbiAgICB9XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLnRvcCA9IGAke01hdGguZmxvb3IoaSl9cHhgLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aCA9PT0gMSAmJiBlLmlzRW1wdHkgPyB0aGlzLmJsb2NrVHVuZXNUb2dnbGVyLmhpZGUoKSA6IHRoaXMuYmxvY2tUdW5lc1RvZ2dsZXIuc2hvdygpLCB0aGlzLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdGhlIFRvb2xiYXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHZhciBlLCB0O1xuICAgIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCB8fCAoKGUgPSB0aGlzLm5vZGVzLndyYXBwZXIpID09IG51bGwgfHwgZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpLCB0aGlzLmJsb2NrQWN0aW9ucy5oaWRlKCksICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgfHwgdC5jbG9zZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCksIHRoaXMucmVzZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBUb29sYmFyIHBvc2l0aW9uIHRvIHByZXZlbnQgRE9NIGhlaWdodCBncm93dGgsIGZvciBleGFtcGxlIGFmdGVyIGJsb2NrcyBkZWxldGlvblxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLnRvcCA9IFwidW5zZXRcIjtcbiAgfVxuICAvKipcbiAgICogT3BlbiBUb29sYmFyIHdpdGggUGx1cyBCdXR0b24gYW5kIEFjdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSB3aXRoQmxvY2tBY3Rpb25zIC0gYnkgZGVmYXVsdCwgVG9vbGJhciBvcGVucyB3aXRoIEJsb2NrIEFjdGlvbnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgZmxhZyBhbGxvd3MgdG8gb3BlbiBUb29sYmFyIHdpdGhvdXQgQWN0aW9ucy5cbiAgICovXG4gIG9wZW4oZSA9ICEwKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MudG9vbGJhck9wZW5lZCksIGUgPyB0aGlzLmJsb2NrQWN0aW9ucy5zaG93KCkgOiB0aGlzLmJsb2NrQWN0aW9ucy5oaWRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIFRvb2xiYXIgZWxlbWVudHNcbiAgICovXG4gIGFzeW5jIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRvb2xiYXIpLCBbXCJjb250ZW50XCIsIFwiYWN0aW9uc1wiXS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0aGlzLm5vZGVzW3NdID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTW3NdKTtcbiAgICB9KSwgZC5hcHBlbmQodGhpcy5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLmNvbnRlbnQpLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmNvbnRlbnQsIHRoaXMubm9kZXMuYWN0aW9ucyksIHRoaXMubm9kZXMucGx1c0J1dHRvbiA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5wbHVzQnV0dG9uLCB7XG4gICAgICBpbm5lckhUTUw6IHRzXG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5ub2Rlcy5wbHVzQnV0dG9uKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5wbHVzQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICRlKCEwKSwgdGhpcy5wbHVzQnV0dG9uQ2xpY2tlZCgpO1xuICAgIH0sICExKTtcbiAgICBjb25zdCBlID0gZC5tYWtlKFwiZGl2XCIpO1xuICAgIGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoei51aShLLnVpLnRvb2xiYXIudG9vbGJveCwgXCJBZGRcIikpKSwgZS5hcHBlbmRDaGlsZChkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MucGx1c0J1dHRvblNob3J0Y3V0LCB7XG4gICAgICB0ZXh0Q29udGVudDogXCIvXCJcbiAgICB9KSksIHplKHRoaXMubm9kZXMucGx1c0J1dHRvbiwgZSwge1xuICAgICAgaGlkaW5nRGVsYXk6IDQwMFxuICAgIH0pLCB0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlciA9IGQubWFrZShcInNwYW5cIiwgdGhpcy5DU1Muc2V0dGluZ3NUb2dnbGVyLCB7XG4gICAgICBpbm5lckhUTUw6IGVzXG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIpO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIiksIG8gPSBkLnRleHQoei51aShLLnVpLmJsb2NrVHVuZXMudG9nZ2xlciwgXCJDbGljayB0byB0dW5lXCIpKSwgaSA9IGF3YWl0IHhzKFwiU2xhc2hcIiwgXCIvXCIpO1xuICAgIHQuYXBwZW5kQ2hpbGQobyksIHQuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnBsdXNCdXR0b25TaG9ydGN1dCwge1xuICAgICAgdGV4dENvbnRlbnQ6IHZ0KGBDTUQgKyAke2l9YClcbiAgICB9KSksIHplKHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLCB0LCB7XG4gICAgICBoaWRpbmdEZWxheTogNDAwXG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5tYWtlVG9vbGJveCgpKSwgZC5hcHBlbmQodGhpcy5ub2Rlcy5hY3Rpb25zLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmdldEVsZW1lbnQoKSksIGQuYXBwZW5kKHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMud3JhcHBlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFRvb2xib3ggaW5zdGFuY2UgYW5kIHJldHVybiBpdCdzIHJlbmRlcmVkIGVsZW1lbnRcbiAgICovXG4gIG1ha2VUb29sYm94KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xib3hJbnN0YW5jZSA9IG5ldyBFcyh7XG4gICAgICBhcGk6IHRoaXMuRWRpdG9yLkFQSS5tZXRob2RzLFxuICAgICAgdG9vbHM6IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMsXG4gICAgICBpMThuTGFiZWxzOiB7XG4gICAgICAgIGZpbHRlcjogei51aShLLnVpLnBvcG92ZXIsIFwiRmlsdGVyXCIpLFxuICAgICAgICBub3RoaW5nRm91bmQ6IHoudWkoSy51aS5wb3BvdmVyLCBcIk5vdGhpbmcgZm91bmRcIilcbiAgICAgIH1cbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oTGUuT3BlbmVkLCAoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1Mub3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyKTtcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oTGUuQ2xvc2VkLCAoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1Mub3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyKTtcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oTGUuQmxvY2tBZGRlZCwgKHsgYmxvY2s6IGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IHQuZ2V0QmxvY2tCeUlkKGUuaWQpO1xuICAgICAgaS5pbnB1dHMubGVuZ3RoID09PSAwICYmIChpID09PSB0Lmxhc3RCbG9jayA/ICh0Lmluc2VydEF0RW5kKCksIG8uc2V0VG9CbG9jayh0Lmxhc3RCbG9jaykpIDogby5zZXRUb0Jsb2NrKHQubmV4dEJsb2NrKSk7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLmdldEVsZW1lbnQoKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlciBmb3IgUGx1cyBCdXR0b25cbiAgICovXG4gIHBsdXNCdXR0b25DbGlja2VkKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgPSB0aGlzLmhvdmVyZWRCbG9jaywgKGUgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCB8fCBlLnRvZ2dsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgYmluZGluZ3NcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLCBcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLnNldHRpbmdzVG9nZ2xlckNsaWNrZWQoKSwgKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgIT0gbnVsbCAmJiB0Lm9wZW5lZCAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5jbG9zZSgpLCAkZSghMCk7XG4gICAgfSwgITApLCBiZSgpIHx8IHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihsbiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgfHwgKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgIT0gbnVsbCAmJiB0Lm9wZW5lZCB8fCB0aGlzLm1vdmVBbmRPcGVuKGUuYmxvY2spO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIGJpbmRpbmdzXG4gICAqL1xuICBkaXNhYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMuY2xlYXJBbGwoKTtcbiAgfVxuICAvKipcbiAgICogQ2xpY2tzIG9uIHRoZSBCbG9jayBTZXR0aW5ncyB0b2dnbGVyXG4gICAqL1xuICBzZXR0aW5nc1RvZ2dsZXJDbGlja2VkKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgPSB0aGlzLmhvdmVyZWRCbG9jaywgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgPyB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW4odGhpcy5ob3ZlcmVkQmxvY2spO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBUb29sYmFyIFVJXG4gICAqXG4gICAqIFRvb2xiYXIgY29udGFpbnMgQmxvY2tTZXR0aW5ncyBhbmQgVG9vbGJveC5cbiAgICogVGhhdCdzIHdoeSBhdCBmaXJzdCB3ZSBkcmF3IGl0cyBjb21wb25lbnRzIGFuZCB0aGVuIFRvb2xiYXIgaXRzZWxmXG4gICAqXG4gICAqIFN0ZXBzOlxuICAgKiAgLSBNYWtlIFRvb2xiYXIgZGVwZW5kZW50IGNvbXBvbmVudHMgbGlrZSBCbG9ja1NldHRpbmdzLCBUb29sYm94IGFuZCBzbyBvblxuICAgKiAgLSBNYWtlIGl0c2VsZiBhbmQgYXBwZW5kIGRlcGVuZGVudCBub2RlcyB0byBpdHNlbGZcbiAgICpcbiAgICovXG4gIGRyYXdVSSgpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm1ha2UoKSwgdGhpcy5tYWtlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNyZWF0ZWQgYW5kIHNhdmVkIEhUTUxFbGVtZW50c1xuICAgKiBJdCBpcyB1c2VkIGluIFJlYWQtT25seSBtb2RlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsTm9kZXMoKSwgdGhpcy50b29sYm94SW5zdGFuY2UgJiYgdGhpcy50b29sYm94SW5zdGFuY2UuZGVzdHJveSgpO1xuICB9XG59XG52YXIgYWUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobltuLkJsb2NrID0gMF0gPSBcIkJsb2NrXCIsIG5bbi5JbmxpbmUgPSAxXSA9IFwiSW5saW5lXCIsIG5bbi5UdW5lID0gMl0gPSBcIlR1bmVcIiwgbikpKGFlIHx8IHt9KSwgUGUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5TaG9ydGN1dCA9IFwic2hvcnRjdXRcIiwgbi5Ub29sYm94ID0gXCJ0b29sYm94XCIsIG4uRW5hYmxlZElubGluZVRvb2xzID0gXCJpbmxpbmVUb29sYmFyXCIsIG4uRW5hYmxlZEJsb2NrVHVuZXMgPSBcInR1bmVzXCIsIG4uQ29uZmlnID0gXCJjb25maWdcIiwgbikpKFBlIHx8IHt9KSwgY24gPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5TaG9ydGN1dCA9IFwic2hvcnRjdXRcIiwgbi5TYW5pdGl6ZUNvbmZpZyA9IFwic2FuaXRpemVcIiwgbikpKGNuIHx8IHt9KSwgcGUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5Jc0VuYWJsZWRMaW5lQnJlYWtzID0gXCJlbmFibGVMaW5lQnJlYWtzXCIsIG4uVG9vbGJveCA9IFwidG9vbGJveFwiLCBuLkNvbnZlcnNpb25Db25maWcgPSBcImNvbnZlcnNpb25Db25maWdcIiwgbi5Jc1JlYWRPbmx5U3VwcG9ydGVkID0gXCJpc1JlYWRPbmx5U3VwcG9ydGVkXCIsIG4uUGFzdGVDb25maWcgPSBcInBhc3RlQ29uZmlnXCIsIG4pKShwZSB8fCB7fSksIFdlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uSXNJbmxpbmUgPSBcImlzSW5saW5lXCIsIG4uVGl0bGUgPSBcInRpdGxlXCIsIG4uSXNSZWFkT25seVN1cHBvcnRlZCA9IFwiaXNSZWFkT25seVN1cHBvcnRlZFwiLCBuKSkoV2UgfHwge30pLCBtdCA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLklzVHVuZSA9IFwiaXNUdW5lXCIsIG4pKShtdCB8fCB7fSk7XG5jbGFzcyBUdCB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogZSxcbiAgICBjb25zdHJ1Y3RhYmxlOiB0LFxuICAgIGNvbmZpZzogbyxcbiAgICBhcGk6IGksXG4gICAgaXNEZWZhdWx0OiBzLFxuICAgIGlzSW50ZXJuYWw6IHIgPSAhMSxcbiAgICBkZWZhdWx0UGxhY2Vob2xkZXI6IGFcbiAgfSkge1xuICAgIHRoaXMuYXBpID0gaSwgdGhpcy5uYW1lID0gZSwgdGhpcy5jb25zdHJ1Y3RhYmxlID0gdCwgdGhpcy5jb25maWcgPSBvLCB0aGlzLmlzRGVmYXVsdCA9IHMsIHRoaXMuaXNJbnRlcm5hbCA9IHIsIHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyID0gYTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHVzZXIgY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IHNldHRpbmdzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbmZpZy5jb25maWcgfHwge307XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZhdWx0ICYmICEoXCJwbGFjZWhvbGRlclwiIGluIGUpICYmIHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyICYmIChlLnBsYWNlaG9sZGVyID0gdGhpcy5kZWZhdWx0UGxhY2Vob2xkZXIpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgcmVzZXQgbWV0aG9kXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBpZiAoQSh0aGlzLmNvbnN0cnVjdGFibGUucmVzZXQpKVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgcHJlcGFyZSBtZXRob2RcbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgaWYgKEEodGhpcy5jb25zdHJ1Y3RhYmxlLnByZXBhcmUpKVxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5wcmVwYXJlKHtcbiAgICAgICAgdG9vbE5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzXG4gICAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzaG9ydGN1dCBmb3IgVG9vbCAoaW50ZXJuYWwgb3Igc3BlY2lmaWVkIGJ5IHVzZXIpXG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29uc3RydWN0YWJsZS5zaG9ydGN1dDtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc2hvcnRjdXQgfHwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sJ3Mgc2FuaXRpemVyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBzYW5pdGl6ZUNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlLnNhbml0aXplIHx8IHt9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbHMgaXMgaW5saW5lXG4gICAqL1xuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBhZS5JbmxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBUb29scyBpcyBibG9ja1xuICAgKi9cbiAgaXNCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBhZS5CbG9jaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIHR1bmVcbiAgICovXG4gIGlzVHVuZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBhZS5UdW5lO1xuICB9XG59XG5jbGFzcyBDcyBleHRlbmRzIEUge1xuICAvKipcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24gLSBNb2R1bGUgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5jb25maWcgLSBFZGl0b3IncyBjb25maWdcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uZXZlbnRzRGlzcGF0Y2hlciAtIEVkaXRvcidzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMuQ1NTID0ge1xuICAgICAgaW5saW5lVG9vbGJhcjogXCJjZS1pbmxpbmUtdG9vbGJhclwiXG4gICAgfSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5wb3BvdmVyID0gbnVsbCwgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW4gPSBiZSgpID8gMjAgOiA2LCB0aGlzLnRvb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5tYWtlKCk7XG4gICAgfSwgeyB0aW1lb3V0OiAyZTMgfSk7XG4gIH1cbiAgLyoqXG4gICAqICBNb3ZpbmcgLyBhcHBlYXJhbmNlXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogU2hvd3MgSW5saW5lIFRvb2xiYXIgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSBbbmVlZFRvQ2xvc2VdIC0gcGFzcyB0cnVlIHRvIGNsb3NlIHRvb2xiYXIgaWYgaXQgaXMgbm90IGFsbG93ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF2b2lkIHRvIHVzZSBpdCBqdXN0IGZvciBjbG9zaW5nIElULCBiZXR0ZXIgY2FsbCAuY2xvc2UoKSBjbGVhcmx5LlxuICAgKi9cbiAgYXN5bmMgdHJ5VG9TaG93KGUgPSAhMSkge1xuICAgIGUgJiYgdGhpcy5jbG9zZSgpLCB0aGlzLmFsbG93ZWRUb1Nob3coKSAmJiAoYXdhaXQgdGhpcy5vcGVuKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIElubGluZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZSwgdDtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW28sIGldIG9mIHRoaXMudG9vbHMpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0VG9vbFNob3J0Y3V0KG8ubmFtZSk7XG4gICAgICAgIHMgIT09IHZvaWQgMCAmJiBnZS5yZW1vdmUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsIHMpLCBBKGkuY2xlYXIpICYmIGkuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9vbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLnJlc2V0KCksIHRoaXMub3BlbmVkID0gITEsIChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IGUuaGlkZSgpLCAodCA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCB0LmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG5vZGUgaXMgY29udGFpbmVkIGJ5IElubGluZSBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSDigJQgbm9kZSB0byBjaGVja1xuICAgKi9cbiAgY29udGFpbnNOb2RlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyID09PSB2b2lkIDAgPyAhMSA6IHRoaXMubm9kZXMud3JhcHBlci5jb250YWlucyhlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBVSSBhbmQgaXRzIGNvbXBvbmVudHNcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBlLmRlc3Ryb3koKSwgdGhpcy5wb3BvdmVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTWFraW5nIERPTVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgdGhpcy5DU1MuaW5saW5lVG9vbGJhcixcbiAgICAgIC4uLnRoaXMuaXNSdGwgPyBbdGhpcy5FZGl0b3IuVUkuQ1NTLmVkaXRvclJ0bEZpeF0gOiBbXVxuICAgIF0pLCB0aGlzLm5vZGVzLndyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jeVwiLCBcImlubGluZS10b29sYmFyXCIpLCBkLmFwcGVuZCh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLndyYXBwZXIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgYXN5bmMgb3BlbigpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAodGhpcy5vcGVuZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5wb3BvdmVyICE9PSBudWxsICYmIHRoaXMucG9wb3Zlci5kZXN0cm95KCksIHRoaXMuY3JlYXRlVG9vbHNJbnN0YW5jZXMoKTtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5nZXRQb3BvdmVySXRlbXMoKTtcbiAgICB0aGlzLnBvcG92ZXIgPSBuZXcgaHMoe1xuICAgICAgaXRlbXM6IGUsXG4gICAgICBzY29wZUVsZW1lbnQ6IHRoaXMuRWRpdG9yLkFQSS5tZXRob2RzLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgbm90aGluZ0ZvdW5kOiB6LnVpKEsudWkucG9wb3ZlciwgXCJOb3RoaW5nIGZvdW5kXCIpLFxuICAgICAgICBzZWFyY2g6IHoudWkoSy51aS5wb3BvdmVyLCBcIkZpbHRlclwiKVxuICAgICAgfVxuICAgIH0pLCB0aGlzLm1vdmUodGhpcy5wb3BvdmVyLnNpemUud2lkdGgpLCAodCA9IHRoaXMubm9kZXMud3JhcHBlcikgPT0gbnVsbCB8fCB0LmFwcGVuZCh0aGlzLnBvcG92ZXIuZ2V0RWxlbWVudCgpKSwgdGhpcy5wb3BvdmVyLnNob3coKTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBUb29sYmFyIHRvIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBwb3BvdmVyV2lkdGggLSB3aWR0aCBvZiB0aGUgdG9vbGJhciBwb3BvdmVyXG4gICAqL1xuICBtb3ZlKGUpIHtcbiAgICBjb25zdCB0ID0gYi5yZWN0LCBvID0gdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaSA9IHtcbiAgICAgIHg6IHQueCAtIG8ueCxcbiAgICAgIHk6IHQueSArIHQuaGVpZ2h0IC0gLy8gKyB3aW5kb3cuc2Nyb2xsWVxuICAgICAgby50b3AgKyB0aGlzLnRvb2xiYXJWZXJ0aWNhbE1hcmdpblxuICAgIH07XG4gICAgaS54ICsgZSArIG8ueCA+IHRoaXMuRWRpdG9yLlVJLmNvbnRlbnRSZWN0LnJpZ2h0ICYmIChpLnggPSB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5yaWdodCAtIGUgLSBvLngpLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IE1hdGguZmxvb3IoaS54KSArIFwicHhcIiwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLnRvcCA9IE1hdGguZmxvb3IoaS55KSArIFwicHhcIjtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgb3JpZW50YXRpb24gY2xhc3NlcyBhbmQgcmVzZXQgcG9zaXRpb25cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gXCIwXCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBcIjBcIjtcbiAgfVxuICAvKipcbiAgICogTmVlZCB0byBzaG93IElubGluZSBUb29sYmFyIG9yIG5vdFxuICAgKi9cbiAgYWxsb3dlZFRvU2hvdygpIHtcbiAgICBjb25zdCBlID0gW1wiSU1HXCIsIFwiSU5QVVRcIl0sIHQgPSBiLmdldCgpLCBvID0gYi50ZXh0O1xuICAgIGlmICghdCB8fCAhdC5hbmNob3JOb2RlIHx8IHQuaXNDb2xsYXBzZWQgfHwgby5sZW5ndGggPCAxKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGkgPSBkLmlzRWxlbWVudCh0LmFuY2hvck5vZGUpID8gdC5hbmNob3JOb2RlIDogdC5hbmNob3JOb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGkgPT09IG51bGwgfHwgdCAhPT0gbnVsbCAmJiBlLmluY2x1ZGVzKGkudGFnTmFtZSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayh0LmFuY2hvck5vZGUpO1xuICAgIHJldHVybiAhcyB8fCB0aGlzLmdldFRvb2xzKCkuc29tZSgoYykgPT4gcy50b29sLmlubGluZVRvb2xzLmhhcyhjLm5hbWUpKSA9PT0gITEgPyAhMSA6IGkuY2xvc2VzdChcIltjb250ZW50ZWRpdGFibGVdXCIpICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiAgV29ya2luZyB3aXRoIFRvb2xzXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogUmV0dXJucyB0b29scyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIGN1cnJlbnQgYmxvY2tcbiAgICpcbiAgICogVXNlZCB0byBjaGVjayBpZiBJbmxpbmUgVG9vbGJhciBjb3VsZCBiZSBzaG93blxuICAgKiBhbmQgdG8gcmVuZGVyIHRvb2xzIGluIHRoZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgZ2V0VG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2s7XG4gICAgcmV0dXJuIGUgPyBBcnJheS5mcm9tKGUudG9vbC5pbmxpbmVUb29scy52YWx1ZXMoKSkuZmlsdGVyKChvKSA9PiAhKHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCAmJiBvLmlzUmVhZE9ubHlTdXBwb3J0ZWQgIT09ICEwKSkgOiBbXTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyB0b29scyBpbnN0YW5jZXMgYW5kIHNhdmVzIHRoZW0gdG8gdGhpcy50b29sc1xuICAgKi9cbiAgY3JlYXRlVG9vbHNJbnN0YW5jZXMoKSB7XG4gICAgdGhpcy50b29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZ2V0VG9vbHMoKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBvID0gdC5jcmVhdGUoKTtcbiAgICAgIHRoaXMudG9vbHMuc2V0KHQsIG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFBvcG92ZXIgSXRlbXMgZm9yIHRvb2xzIHNlZ3JlZ2F0ZWQgYnkgdGhlaXIgYXBwZWFyYW5jZSB0eXBlOiByZWd1bGFyIGl0ZW1zIGFuZCBjdXN0b20gaHRtbCBlbGVtZW50cy5cbiAgICovXG4gIGFzeW5jIGdldFBvcG92ZXJJdGVtcygpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgbGV0IHQgPSAwO1xuICAgIGZvciAoY29uc3QgW28sIGldIG9mIHRoaXMudG9vbHMpIHtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCBpLnJlbmRlcigpLCByID0gdGhpcy5nZXRUb29sU2hvcnRjdXQoby5uYW1lKTtcbiAgICAgIGlmIChyICE9PSB2b2lkIDApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVTaG9ydGN1dHMoby5uYW1lLCByKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgIGNvbnN0IGEgPSByICE9PSB2b2lkIDAgPyB2dChyKSA6IHZvaWQgMCwgbCA9IHoudChcbiAgICAgICAgSy50b29sTmFtZXMsXG4gICAgICAgIG8udGl0bGUgfHwgamUoby5uYW1lKVxuICAgICAgKTtcbiAgICAgIFtzXS5mbGF0KCkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICB2YXIgaCwgcDtcbiAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICBuYW1lOiBvLm5hbWUsXG4gICAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b29sQ2xpY2tlZChpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICAgIHRpdGxlOiBsLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkLmlzRWxlbWVudChjKSkge1xuICAgICAgICAgIGNvbnN0IGcgPSB7XG4gICAgICAgICAgICAuLi51LFxuICAgICAgICAgICAgZWxlbWVudDogYyxcbiAgICAgICAgICAgIHR5cGU6IF8uSHRtbFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKEEoaS5yZW5kZXJBY3Rpb25zKSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IGkucmVuZGVyQWN0aW9ucygpO1xuICAgICAgICAgICAgZy5jaGlsZHJlbiA9IHtcbiAgICAgICAgICAgICAgaXNPcGVuOiAoaCA9IGkuY2hlY2tTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGguY2FsbChpLCBiLmdldCgpKSxcbiAgICAgICAgICAgICAgLyoqIERpc2FibGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBpbiBhY3Rpb25zLCBhcyBpdCBtaWdodCBjb25mbGljdCB3aXRoIGVudGVyIHByZXNzIGhhbmRsaW5nICovXG4gICAgICAgICAgICAgIGlzRmxpcHBhYmxlOiAhMSxcbiAgICAgICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBfLkh0bWwsXG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBmXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKHAgPSBpLmNoZWNrU3RhdGUpID09IG51bGwgfHwgcC5jYWxsKGksIGIuZ2V0KCkpO1xuICAgICAgICAgIGUucHVzaChnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09IF8uSHRtbClcbiAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgLi4udSxcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICB0eXBlOiBfLkh0bWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAoYy50eXBlID09PSBfLlNlcGFyYXRvcilcbiAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXy5TZXBhcmF0b3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgZyA9IHtcbiAgICAgICAgICAgIC4uLnUsXG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHlwZTogXy5EZWZhdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcImNoaWxkcmVuXCIgaW4gZyAmJiB0ICE9PSAwICYmIGUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBfLlNlcGFyYXRvclxuICAgICAgICAgIH0pLCBlLnB1c2goZyksIFwiY2hpbGRyZW5cIiBpbiBnICYmIHQgPCB0aGlzLnRvb2xzLnNpemUgLSAxICYmIGUucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBfLlNlcGFyYXRvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgdCsrO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHNob3J0Y3V0IG5hbWUgZm9yIHRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIOKAlCBUb29sIG5hbWVcbiAgICovXG4gIGdldFRvb2xTaG9ydGN1dChlKSB7XG4gICAgY29uc3QgeyBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSB0LmlubGluZVRvb2xzLmdldChlKSwgaSA9IHQuaW50ZXJuYWwuaW5saW5lVG9vbHM7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaS5rZXlzKCkpLmluY2x1ZGVzKGUpID8gdGhpcy5pbmxpbmVUb29sc1tlXVtjbi5TaG9ydGN1dF0gOiBvID09IG51bGwgPyB2b2lkIDAgOiBvLnNob3J0Y3V0O1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgVG9vbCBzaG9ydGN1dCB3aXRoIEVkaXRvciBTaG9ydGN1dHMgTW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIHRvb2wgbmFtZVxuICAgKiBAcGFyYW0gc2hvcnRjdXQgLSBzaG9ydGN1dCBhY2NvcmRpbmcgdG8gdGhlIFNob3J0Y3V0RGF0YSBNb2R1bGUgZm9ybWF0XG4gICAqL1xuICBlbmFibGVTaG9ydGN1dHMoZSwgdCkge1xuICAgIGdlLmFkZCh7XG4gICAgICBuYW1lOiB0LFxuICAgICAgaGFuZGxlcjogKG8pID0+IHtcbiAgICAgICAgdmFyIHM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiBpIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXI7XG4gICAgICAgIGkgJiYgaS50b29sLmVuYWJsZWRJbmxpbmVUb29scyAmJiAoby5wcmV2ZW50RGVmYXVsdCgpLCAocyA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBzLmFjdGl2YXRlSXRlbUJ5TmFtZShlKSk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBXZSBuZWVkIHRvIGJpbmQgc2hvcnRjdXQgdG8gdGhlIGRvY3VtZW50IHRvIG1ha2UgaXQgd29yayBpbiByZWFkLW9ubHkgbW9kZVxuICAgICAgICovXG4gICAgICBvbjogZG9jdW1lbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5saW5lIFRvb2wgYnV0dG9uIGNsaWNrc1xuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIFRvb2wncyBpbnN0YW5jZVxuICAgKi9cbiAgdG9vbENsaWNrZWQoZSkge1xuICAgIHZhciBvO1xuICAgIGNvbnN0IHQgPSBiLnJhbmdlO1xuICAgIChvID0gZS5zdXJyb3VuZCkgPT0gbnVsbCB8fCBvLmNhbGwoZSwgdCksIHRoaXMuY2hlY2tUb29sc1N0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIFRvb2xzYCBzdGF0ZSBieSBzZWxlY3Rpb25cbiAgICovXG4gIGNoZWNrVG9vbHNTdGF0ZSgpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMudG9vbHMpID09IG51bGwgfHwgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIChvID0gdC5jaGVja1N0YXRlKSA9PSBudWxsIHx8IG8uY2FsbCh0LCBiLmdldCgpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGlubGluZSB0b29scyB0b29sc1xuICAgKiBUb29scyB0aGF0IGhhcyBpc0lubGluZSBpcyB0cnVlXG4gICAqL1xuICBnZXQgaW5saW5lVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuRWRpdG9yLlRvb2xzLmlubGluZVRvb2xzLmVudHJpZXMoKSkuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICBlW3RdID0gby5jcmVhdGUoKTtcbiAgICB9KSwgZTtcbiAgfVxufVxuZnVuY3Rpb24gZG4oKSB7XG4gIGNvbnN0IG4gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChuID09PSBudWxsKVxuICAgIHJldHVybiBbbnVsbCwgMF07XG4gIGxldCBlID0gbi5mb2N1c05vZGUsIHQgPSBuLmZvY3VzT2Zmc2V0O1xuICByZXR1cm4gZSA9PT0gbnVsbCA/IFtudWxsLCAwXSA6IChlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiAoZS5jaGlsZE5vZGVzW3RdID8gKGUgPSBlLmNoaWxkTm9kZXNbdF0sIHQgPSAwKSA6IChlID0gZS5jaGlsZE5vZGVzW3QgLSAxXSwgdCA9IGUudGV4dENvbnRlbnQubGVuZ3RoKSksIFtlLCB0XSk7XG59XG5mdW5jdGlvbiB1bihuLCBlLCB0LCBvKSB7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBvID09PSBcImxlZnRcIiA/IChpLnNldFN0YXJ0KG4sIDApLCBpLnNldEVuZChlLCB0KSkgOiAoaS5zZXRTdGFydChlLCB0KSwgaS5zZXRFbmQobiwgbi5jaGlsZE5vZGVzLmxlbmd0aCkpO1xuICBjb25zdCBzID0gaS5jbG9uZUNvbnRlbnRzKCksIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByLmFwcGVuZENoaWxkKHMpO1xuICBjb25zdCBhID0gci50ZXh0Q29udGVudCB8fCBcIlwiO1xuICByZXR1cm4gYWkoYSk7XG59XG5mdW5jdGlvbiBOZShuKSB7XG4gIGNvbnN0IGUgPSBkLmdldERlZXBlc3ROb2RlKG4pO1xuICBpZiAoZSA9PT0gbnVsbCB8fCBkLmlzRW1wdHkobikpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoZC5pc05hdGl2ZUlucHV0KGUpKVxuICAgIHJldHVybiBlLnNlbGVjdGlvbkVuZCA9PT0gMDtcbiAgaWYgKGQuaXNFbXB0eShuKSlcbiAgICByZXR1cm4gITA7XG4gIGNvbnN0IFt0LCBvXSA9IGRuKCk7XG4gIHJldHVybiB0ID09PSBudWxsID8gITEgOiB1bihuLCB0LCBvLCBcImxlZnRcIik7XG59XG5mdW5jdGlvbiBSZShuKSB7XG4gIGNvbnN0IGUgPSBkLmdldERlZXBlc3ROb2RlKG4sICEwKTtcbiAgaWYgKGUgPT09IG51bGwpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoZC5pc05hdGl2ZUlucHV0KGUpKVxuICAgIHJldHVybiBlLnNlbGVjdGlvbkVuZCA9PT0gZS52YWx1ZS5sZW5ndGg7XG4gIGNvbnN0IFt0LCBvXSA9IGRuKCk7XG4gIHJldHVybiB0ID09PSBudWxsID8gITEgOiB1bihuLCB0LCBvLCBcInJpZ2h0XCIpO1xufVxudmFyIGhuID0ge30sIFN0ID0ge30sIFhlID0ge30sIGRlID0ge30sIEl0ID0ge30sIE90ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbk90LmFsbElucHV0c1NlbGVjdG9yID0gVHM7XG5mdW5jdGlvbiBUcygpIHtcbiAgdmFyIG4gPSBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIiwgXCJlbWFpbFwiLCBcIm51bWJlclwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiXTtcbiAgcmV0dXJuIFwiW2NvbnRlbnRlZGl0YWJsZT10cnVlXSwgdGV4dGFyZWEsIGlucHV0Om5vdChbdHlwZV0pLCBcIiArIG4ubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gJ2lucHV0W3R5cGU9XCInLmNvbmNhdChlLCAnXCJdJyk7XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uYWxsSW5wdXRzU2VsZWN0b3IgPSB2b2lkIDA7XG4gIHZhciBlID0gT3Q7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImFsbElucHV0c1NlbGVjdG9yXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuYWxsSW5wdXRzU2VsZWN0b3I7XG4gIH0gfSk7XG59KShJdCk7XG52YXIgdWUgPSB7fSwgX3QgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuX3QuaXNOYXRpdmVJbnB1dCA9IFNzO1xuZnVuY3Rpb24gU3Mobikge1xuICB2YXIgZSA9IFtcbiAgICBcIklOUFVUXCIsXG4gICAgXCJURVhUQVJFQVwiXG4gIF07XG4gIHJldHVybiBuICYmIG4udGFnTmFtZSA/IGUuaW5jbHVkZXMobi50YWdOYW1lKSA6ICExO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc05hdGl2ZUlucHV0ID0gdm9pZCAwO1xuICB2YXIgZSA9IF90O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc05hdGl2ZUlucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNOYXRpdmVJbnB1dDtcbiAgfSB9KTtcbn0pKHVlKTtcbnZhciBwbiA9IHt9LCBNdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE10LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5NdC5hcHBlbmQgPSBJcztcbmZ1bmN0aW9uIElzKG4sIGUpIHtcbiAgQXJyYXkuaXNBcnJheShlKSA/IGUuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgbi5hcHBlbmRDaGlsZCh0KTtcbiAgfSkgOiBuLmFwcGVuZENoaWxkKGUpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5hcHBlbmQgPSB2b2lkIDA7XG4gIHZhciBlID0gTXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImFwcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmFwcGVuZDtcbiAgfSB9KTtcbn0pKHBuKTtcbnZhciBBdCA9IHt9LCBMdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEx0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5MdC5ibG9ja0VsZW1lbnRzID0gT3M7XG5mdW5jdGlvbiBPcygpIHtcbiAgcmV0dXJuIFtcbiAgICBcImFkZHJlc3NcIixcbiAgICBcImFydGljbGVcIixcbiAgICBcImFzaWRlXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJjYW52YXNcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGxcIixcbiAgICBcImR0XCIsXG4gICAgXCJmaWVsZHNldFwiLFxuICAgIFwiZmlnY2FwdGlvblwiLFxuICAgIFwiZmlndXJlXCIsXG4gICAgXCJmb290ZXJcIixcbiAgICBcImZvcm1cIixcbiAgICBcImgxXCIsXG4gICAgXCJoMlwiLFxuICAgIFwiaDNcIixcbiAgICBcImg0XCIsXG4gICAgXCJoNVwiLFxuICAgIFwiaDZcIixcbiAgICBcImhlYWRlclwiLFxuICAgIFwiaGdyb3VwXCIsXG4gICAgXCJoclwiLFxuICAgIFwibGlcIixcbiAgICBcIm1haW5cIixcbiAgICBcIm5hdlwiLFxuICAgIFwibm9zY3JpcHRcIixcbiAgICBcIm9sXCIsXG4gICAgXCJvdXRwdXRcIixcbiAgICBcInBcIixcbiAgICBcInByZVwiLFxuICAgIFwicnVieVwiLFxuICAgIFwic2VjdGlvblwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRib2R5XCIsXG4gICAgXCJ0aGVhZFwiLFxuICAgIFwidHJcIixcbiAgICBcInRmb290XCIsXG4gICAgXCJ1bFwiLFxuICAgIFwidmlkZW9cIlxuICBdO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5ibG9ja0VsZW1lbnRzID0gdm9pZCAwO1xuICB2YXIgZSA9IEx0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJibG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuYmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbn0pKEF0KTtcbnZhciBmbiA9IHt9LCBQdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFB0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5QdC5jYWxjdWxhdGVCYXNlbGluZSA9IF9zO1xuZnVuY3Rpb24gX3Mobikge1xuICB2YXIgZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG4pLCB0ID0gcGFyc2VGbG9hdChlLmZvbnRTaXplKSwgbyA9IHBhcnNlRmxvYXQoZS5saW5lSGVpZ2h0KSB8fCB0ICogMS4yLCBpID0gcGFyc2VGbG9hdChlLnBhZGRpbmdUb3ApLCBzID0gcGFyc2VGbG9hdChlLmJvcmRlclRvcFdpZHRoKSwgciA9IHBhcnNlRmxvYXQoZS5tYXJnaW5Ub3ApLCBhID0gdCAqIDAuOCwgbCA9IChvIC0gdCkgLyAyLCBjID0gciArIHMgKyBpICsgbCArIGE7XG4gIHJldHVybiBjO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5jYWxjdWxhdGVCYXNlbGluZSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBQdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY2FsY3VsYXRlQmFzZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jYWxjdWxhdGVCYXNlbGluZTtcbiAgfSB9KTtcbn0pKGZuKTtcbnZhciBnbiA9IHt9LCBOdCA9IHt9LCBSdCA9IHt9LCBEdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5EdC5pc0NvbnRlbnRFZGl0YWJsZSA9IE1zO1xuZnVuY3Rpb24gTXMobikge1xuICByZXR1cm4gbi5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0NvbnRlbnRFZGl0YWJsZSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBEdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNDb250ZW50RWRpdGFibGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgfSB9KTtcbn0pKFJ0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTnQuY2FuU2V0Q2FyZXQgPSBQcztcbnZhciBBcyA9IHVlLCBMcyA9IFJ0O1xuZnVuY3Rpb24gUHMobikge1xuICB2YXIgZSA9ICEwO1xuICBpZiAoKDAsIEFzLmlzTmF0aXZlSW5wdXQpKG4pKVxuICAgIHN3aXRjaCAobi50eXBlKSB7XG4gICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInJlc2V0XCI6XG4gICAgICAgIGUgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICBlbHNlXG4gICAgZSA9ICgwLCBMcy5pc0NvbnRlbnRFZGl0YWJsZSkobik7XG4gIHJldHVybiBlO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5jYW5TZXRDYXJldCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBOdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY2FuU2V0Q2FyZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jYW5TZXRDYXJldDtcbiAgfSB9KTtcbn0pKGduKTtcbnZhciBWZSA9IHt9LCBGdCA9IHt9O1xuZnVuY3Rpb24gTnMobiwgZSwgdCkge1xuICBjb25zdCBvID0gdC52YWx1ZSAhPT0gdm9pZCAwID8gXCJ2YWx1ZVwiIDogXCJnZXRcIiwgaSA9IHRbb10sIHMgPSBgIyR7ZX1DYWNoZWA7XG4gIGlmICh0W29dID0gZnVuY3Rpb24oLi4ucikge1xuICAgIHJldHVybiB0aGlzW3NdID09PSB2b2lkIDAgJiYgKHRoaXNbc10gPSBpLmFwcGx5KHRoaXMsIHIpKSwgdGhpc1tzXTtcbiAgfSwgbyA9PT0gXCJnZXRcIiAmJiB0LnNldCkge1xuICAgIGNvbnN0IHIgPSB0LnNldDtcbiAgICB0LnNldCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGRlbGV0ZSBuW3NdLCByLmFwcGx5KHRoaXMsIGEpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBtbigpIHtcbiAgY29uc3QgbiA9IHtcbiAgICB3aW46ICExLFxuICAgIG1hYzogITEsXG4gICAgeDExOiAhMSxcbiAgICBsaW51eDogITFcbiAgfSwgZSA9IE9iamVjdC5rZXlzKG4pLmZpbmQoKHQpID0+IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YodCkgIT09IC0xKTtcbiAgcmV0dXJuIGUgIT09IHZvaWQgMCAmJiAobltlXSA9ICEwKSwgbjtcbn1cbmZ1bmN0aW9uIGp0KG4pIHtcbiAgcmV0dXJuIG4gIT0gbnVsbCAmJiBuICE9PSBcIlwiICYmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8IE9iamVjdC5rZXlzKG4pLmxlbmd0aCA+IDApO1xufVxuZnVuY3Rpb24gUnMobikge1xuICByZXR1cm4gIWp0KG4pO1xufVxuY29uc3QgRHMgPSAoKSA9PiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93Lm5hdmlnYXRvciAhPT0gbnVsbCAmJiBqdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSAmJiAoL2lQKGFkfGhvbmV8b2QpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiTWFjSW50ZWxcIiAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG5mdW5jdGlvbiBGcyhuKSB7XG4gIGNvbnN0IGUgPSBtbigpO1xuICByZXR1cm4gbiA9IG4ucmVwbGFjZSgvc2hpZnQvZ2ksIFwi4oenXCIpLnJlcGxhY2UoL2JhY2tzcGFjZS9naSwgXCLijKtcIikucmVwbGFjZSgvZW50ZXIvZ2ksIFwi4o+OXCIpLnJlcGxhY2UoL3VwL2dpLCBcIuKGkVwiKS5yZXBsYWNlKC9sZWZ0L2dpLCBcIuKGklwiKS5yZXBsYWNlKC9kb3duL2dpLCBcIuKGk1wiKS5yZXBsYWNlKC9yaWdodC9naSwgXCLihpBcIikucmVwbGFjZSgvZXNjYXBlL2dpLCBcIuKOi1wiKS5yZXBsYWNlKC9pbnNlcnQvZ2ksIFwiSW5zXCIpLnJlcGxhY2UoL2RlbGV0ZS9naSwgXCLikKFcIikucmVwbGFjZSgvXFwrL2dpLCBcIitcIiksIGUubWFjID8gbiA9IG4ucmVwbGFjZSgvY3RybHxjbWQvZ2ksIFwi4oyYXCIpLnJlcGxhY2UoL2FsdC9naSwgXCLijKVcIikgOiBuID0gbi5yZXBsYWNlKC9jbWQvZ2ksIFwiQ3RybFwiKS5yZXBsYWNlKC93aW5kb3dzL2dpLCBcIldJTlwiKSwgbjtcbn1cbmZ1bmN0aW9uIGpzKG4pIHtcbiAgcmV0dXJuIG5bMF0udG9VcHBlckNhc2UoKSArIG4uc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBIcyhuKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBlLnN0eWxlLmxlZnQgPSBcIi05OTlweFwiLCBlLnN0eWxlLmJvdHRvbSA9IFwiLTk5OXB4XCIsIGUuaW5uZXJIVE1MID0gbiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcbiAgY29uc3QgdCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgbyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChvLnNlbGVjdE5vZGUoZSksIHQgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvcHkgdGV4dCB0byBjbGlwYm9hcmRcIik7XG4gIHQucmVtb3ZlQWxsUmFuZ2VzKCksIHQuYWRkUmFuZ2UobyksIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKTtcbn1cbmZ1bmN0aW9uICRzKG4sIGUsIHQpIHtcbiAgbGV0IG87XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNvbnN0IHMgPSB0aGlzLCByID0gKCkgPT4ge1xuICAgICAgbyA9IHZvaWQgMCwgdCAhPT0gITAgJiYgbi5hcHBseShzLCBpKTtcbiAgICB9LCBhID0gdCA9PT0gITAgJiYgbyAhPT0gdm9pZCAwO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobyksIG8gPSB3aW5kb3cuc2V0VGltZW91dChyLCBlKSwgYSAmJiBuLmFwcGx5KHMsIGkpO1xuICB9O1xufVxuZnVuY3Rpb24gb2Uobikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB6cyhuKSB7XG4gIHJldHVybiBvZShuKSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBibihuKSB7XG4gIHJldHVybiBvZShuKSA9PT0gXCJmdW5jdGlvblwiIHx8IG9lKG4pID09PSBcImFzeW5jZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIFVzKG4pIHtcbiAgcmV0dXJuIGJuKG4pICYmIC9eXFxzKmNsYXNzXFxzKy8udGVzdChuLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gV3Mobikge1xuICByZXR1cm4gb2UobikgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBEZShuKSB7XG4gIHJldHVybiBvZShuKSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIFlzKG4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuKSA9PT0gbjtcbn1cbmZ1bmN0aW9uIEtzKG4pIHtcbiAgcmV0dXJuIG9lKG4pID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gWHMobikge1xuICByZXR1cm4gb2UobikgPT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBidChuLCAuLi5lKSB7XG4gIGlmICghZS5sZW5ndGgpXG4gICAgcmV0dXJuIG47XG4gIGNvbnN0IHQgPSBlLnNoaWZ0KCk7XG4gIGlmIChEZShuKSAmJiBEZSh0KSlcbiAgICBmb3IgKGNvbnN0IG8gaW4gdClcbiAgICAgIERlKHRbb10pID8gKG5bb10gPT09IHZvaWQgMCAmJiBPYmplY3QuYXNzaWduKG4sIHsgW29dOiB7fSB9KSwgYnQobltvXSwgdFtvXSkpIDogT2JqZWN0LmFzc2lnbihuLCB7IFtvXTogdFtvXSB9KTtcbiAgcmV0dXJuIGJ0KG4sIC4uLmUpO1xufVxuZnVuY3Rpb24gVnMobiwgZSwgdCkge1xuICBjb25zdCBvID0gYMKrJHtlfcK7IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIHRoZSDCqyR7dH3CuyBpbnN0ZWFkLmA7XG4gIG4gJiYgY29uc29sZS53YXJuKG8pO1xufVxuZnVuY3Rpb24gcXMobikge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKG4pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBuLnN1YnN0cmluZygwLCAyKSA9PT0gXCIvL1wiID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgbiA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBuO1xufVxuZnVuY3Rpb24gWnMobikge1xuICByZXR1cm4gbiA+IDQ3ICYmIG4gPCA1OCB8fCBuID09PSAzMiB8fCBuID09PSAxMyB8fCBuID09PSAyMjkgfHwgbiA+IDY0ICYmIG4gPCA5MSB8fCBuID4gOTUgJiYgbiA8IDExMiB8fCBuID4gMTg1ICYmIG4gPCAxOTMgfHwgbiA+IDIxOCAmJiBuIDwgMjIzO1xufVxuY29uc3QgR3MgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQzogMjcsXG4gIFNQQUNFOiAzMixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgRE9XTjogNDAsXG4gIFJJR0hUOiAzOSxcbiAgREVMRVRFOiA0NixcbiAgTUVUQTogOTEsXG4gIFNMQVNIOiAxOTFcbn0sIFFzID0ge1xuICBMRUZUOiAwLFxuICBXSEVFTDogMSxcbiAgUklHSFQ6IDIsXG4gIEJBQ0tXQVJEOiAzLFxuICBGT1JXQVJEOiA0XG59O1xubGV0IEpzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXBsZXRlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb21pc2UgdG8gcXVldWVcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIHByb21pc2Ugc2hvdWxkIGJlIGFkZGVkIHRvIHF1ZXVlXG4gICAqL1xuICBhZGQoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCwgbykgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZC50aGVuKGUpLnRoZW4odCkuY2F0Y2gobyk7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBlcihuLCBlLCB0ID0gdm9pZCAwKSB7XG4gIGxldCBvLCBpLCBzLCByID0gbnVsbCwgYSA9IDA7XG4gIHQgfHwgKHQgPSB7fSk7XG4gIGNvbnN0IGwgPSBmdW5jdGlvbigpIHtcbiAgICBhID0gdC5sZWFkaW5nID09PSAhMSA/IDAgOiBEYXRlLm5vdygpLCByID0gbnVsbCwgcyA9IG4uYXBwbHkobywgaSksIHIgPT09IG51bGwgJiYgKG8gPSBpID0gbnVsbCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjID0gRGF0ZS5ub3coKTtcbiAgICAhYSAmJiB0LmxlYWRpbmcgPT09ICExICYmIChhID0gYyk7XG4gICAgY29uc3QgdSA9IGUgLSAoYyAtIGEpO1xuICAgIHJldHVybiBvID0gdGhpcywgaSA9IGFyZ3VtZW50cywgdSA8PSAwIHx8IHUgPiBlID8gKHIgJiYgKGNsZWFyVGltZW91dChyKSwgciA9IG51bGwpLCBhID0gYywgcyA9IG4uYXBwbHkobywgaSksIHIgPT09IG51bGwgJiYgKG8gPSBpID0gbnVsbCkpIDogIXIgJiYgdC50cmFpbGluZyAhPT0gITEgJiYgKHIgPSBzZXRUaW1lb3V0KGwsIHUpKSwgcztcbiAgfTtcbn1cbmNvbnN0IHRyID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgUHJvbWlzZVF1ZXVlOiBKcyxcbiAgYmVhdXRpZnlTaG9ydGN1dDogRnMsXG4gIGNhY2hlYWJsZTogTnMsXG4gIGNhcGl0YWxpemU6IGpzLFxuICBjb3B5VGV4dFRvQ2xpcGJvYXJkOiBIcyxcbiAgZGVib3VuY2U6ICRzLFxuICBkZWVwTWVyZ2U6IGJ0LFxuICBkZXByZWNhdGlvbkFzc2VydDogVnMsXG4gIGdldFVzZXJPUzogbW4sXG4gIGdldFZhbGlkVXJsOiBxcyxcbiAgaXNCb29sZWFuOiB6cyxcbiAgaXNDbGFzczogVXMsXG4gIGlzRW1wdHk6IFJzLFxuICBpc0Z1bmN0aW9uOiBibixcbiAgaXNJb3NEZXZpY2U6IERzLFxuICBpc051bWJlcjogV3MsXG4gIGlzT2JqZWN0OiBEZSxcbiAgaXNQcmludGFibGVLZXk6IFpzLFxuICBpc1Byb21pc2U6IFlzLFxuICBpc1N0cmluZzogS3MsXG4gIGlzVW5kZWZpbmVkOiBYcyxcbiAga2V5Q29kZXM6IEdzLFxuICBtb3VzZUJ1dHRvbnM6IFFzLFxuICBub3RFbXB0eToganQsXG4gIHRocm90dGxlOiBlcixcbiAgdHlwZU9mOiBvZVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgSHQgPSAvKiBAX19QVVJFX18gKi8gWG4odHIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5GdC5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyA9IGlyO1xudmFyIG9yID0gSHQsIG5yID0gQXQ7XG5mdW5jdGlvbiBpcihuKSB7XG4gIHZhciBlO1xuICAoMCwgb3IuaXNTdHJpbmcpKG4pID8gKGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBlLmlubmVySFRNTCA9IG4pIDogZSA9IG47XG4gIHZhciB0ID0gZnVuY3Rpb24obykge1xuICAgIHJldHVybiAhKDAsIG5yLmJsb2NrRWxlbWVudHMpKCkuaW5jbHVkZXMoby50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIEFycmF5LmZyb20oby5jaGlsZHJlbikuZXZlcnkodCk7XG4gIH07XG4gIHJldHVybiBBcnJheS5mcm9tKGUuY2hpbGRyZW4pLmV2ZXJ5KHQpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBGdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cztcbiAgfSB9KTtcbn0pKFZlKTtcbnZhciB2biA9IHt9LCAkdCA9IHt9LCBxZSA9IHt9LCB6dCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHp0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG56dC5tYWtlID0gc3I7XG5mdW5jdGlvbiBzcihuLCBlLCB0KSB7XG4gIHZhciBvO1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBudWxsKSwgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xuICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobik7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgdmFyIHMgPSBlLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYSAhPT0gdm9pZCAwO1xuICAgIH0pO1xuICAgIChvID0gaS5jbGFzc0xpc3QpLmFkZC5hcHBseShvLCBzKTtcbiAgfSBlbHNlXG4gICAgZSAhPT0gbnVsbCAmJiBpLmNsYXNzTGlzdC5hZGQoZSk7XG4gIGZvciAodmFyIHIgaW4gdClcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgcikgJiYgKGlbcl0gPSB0W3JdKTtcbiAgcmV0dXJuIGk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLm1ha2UgPSB2b2lkIDA7XG4gIHZhciBlID0genQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIm1ha2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5tYWtlO1xuICB9IH0pO1xufSkocWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4kdC5mcmFnbWVudFRvU3RyaW5nID0gYXI7XG52YXIgcnIgPSBxZTtcbmZ1bmN0aW9uIGFyKG4pIHtcbiAgdmFyIGUgPSAoMCwgcnIubWFrZSkoXCJkaXZcIik7XG4gIHJldHVybiBlLmFwcGVuZENoaWxkKG4pLCBlLmlubmVySFRNTDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZnJhZ21lbnRUb1N0cmluZyA9IHZvaWQgMDtcbiAgdmFyIGUgPSAkdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZnJhZ21lbnRUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmZyYWdtZW50VG9TdHJpbmc7XG4gIH0gfSk7XG59KSh2bik7XG52YXIga24gPSB7fSwgVXQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuVXQuZ2V0Q29udGVudExlbmd0aCA9IGNyO1xudmFyIGxyID0gdWU7XG5mdW5jdGlvbiBjcihuKSB7XG4gIHZhciBlLCB0O1xuICByZXR1cm4gKDAsIGxyLmlzTmF0aXZlSW5wdXQpKG4pID8gbi52YWx1ZS5sZW5ndGggOiBuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG4ubGVuZ3RoIDogKHQgPSAoZSA9IG4udGV4dENvbnRlbnQpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubGVuZ3RoKSAhPT0gbnVsbCAmJiB0ICE9PSB2b2lkIDAgPyB0IDogMDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZ2V0Q29udGVudExlbmd0aCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBVdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0Q29udGVudExlbmd0aFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmdldENvbnRlbnRMZW5ndGg7XG4gIH0gfSk7XG59KShrbik7XG52YXIgV3QgPSB7fSwgWXQgPSB7fSwgSW8gPSBDZSAmJiBDZS5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG4sIGUsIHQpIHtcbiAgaWYgKHQgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICBmb3IgKHZhciBvID0gMCwgaSA9IGUubGVuZ3RoLCBzOyBvIDwgaTsgbysrKVxuICAgICAgKHMgfHwgIShvIGluIGUpKSAmJiAocyB8fCAocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsIDAsIG8pKSwgc1tvXSA9IGVbb10pO1xuICByZXR1cm4gbi5jb25jYXQocyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFl0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5ZdC5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IHluO1xudmFyIGRyID0gVmU7XG5mdW5jdGlvbiB5bihuKSB7XG4gIHJldHVybiAoMCwgZHIuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMpKG4pID8gW25dIDogQXJyYXkuZnJvbShuLmNoaWxkcmVuKS5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiBJbyhJbyhbXSwgZSwgITApLCB5bih0KSwgITApO1xuICB9LCBbXSk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzID0gdm9pZCAwO1xuICB2YXIgZSA9IFl0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXREZWVwZXN0QmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzO1xuICB9IH0pO1xufSkoV3QpO1xudmFyIHduID0ge30sIEt0ID0ge30sIFplID0ge30sIFh0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblh0LmlzTGluZUJyZWFrVGFnID0gdXI7XG5mdW5jdGlvbiB1cihuKSB7XG4gIHJldHVybiBbXG4gICAgXCJCUlwiLFxuICAgIFwiV0JSXCJcbiAgXS5pbmNsdWRlcyhuLnRhZ05hbWUpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0xpbmVCcmVha1RhZyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBYdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNMaW5lQnJlYWtUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc0xpbmVCcmVha1RhZztcbiAgfSB9KTtcbn0pKFplKTtcbnZhciBHZSA9IHt9LCBWdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5WdC5pc1NpbmdsZVRhZyA9IGhyO1xuZnVuY3Rpb24gaHIobikge1xuICByZXR1cm4gW1xuICAgIFwiQVJFQVwiLFxuICAgIFwiQkFTRVwiLFxuICAgIFwiQlJcIixcbiAgICBcIkNPTFwiLFxuICAgIFwiQ09NTUFORFwiLFxuICAgIFwiRU1CRURcIixcbiAgICBcIkhSXCIsXG4gICAgXCJJTUdcIixcbiAgICBcIklOUFVUXCIsXG4gICAgXCJLRVlHRU5cIixcbiAgICBcIkxJTktcIixcbiAgICBcIk1FVEFcIixcbiAgICBcIlBBUkFNXCIsXG4gICAgXCJTT1VSQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJXQlJcIlxuICBdLmluY2x1ZGVzKG4udGFnTmFtZSk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmlzU2luZ2xlVGFnID0gdm9pZCAwO1xuICB2YXIgZSA9IFZ0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc1NpbmdsZVRhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzU2luZ2xlVGFnO1xuICB9IH0pO1xufSkoR2UpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEt0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5LdC5nZXREZWVwZXN0Tm9kZSA9IEVuO1xudmFyIHByID0gdWUsIGZyID0gWmUsIGdyID0gR2U7XG5mdW5jdGlvbiBFbihuLCBlKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIHQgPSBlID8gXCJsYXN0Q2hpbGRcIiA6IFwiZmlyc3RDaGlsZFwiLCBvID0gZSA/IFwicHJldmlvdXNTaWJsaW5nXCIgOiBcIm5leHRTaWJsaW5nXCI7XG4gIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuW3RdKSB7XG4gICAgdmFyIGkgPSBuW3RdO1xuICAgIGlmICgoMCwgZ3IuaXNTaW5nbGVUYWcpKGkpICYmICEoMCwgcHIuaXNOYXRpdmVJbnB1dCkoaSkgJiYgISgwLCBmci5pc0xpbmVCcmVha1RhZykoaSkpXG4gICAgICBpZiAoaVtvXSlcbiAgICAgICAgaSA9IGlbb107XG4gICAgICBlbHNlIGlmIChpLnBhcmVudE5vZGUgIT09IG51bGwgJiYgaS5wYXJlbnROb2RlW29dKVxuICAgICAgICBpID0gaS5wYXJlbnROb2RlW29dO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gaS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBFbihpLCBlKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZ2V0RGVlcGVzdE5vZGUgPSB2b2lkIDA7XG4gIHZhciBlID0gS3Q7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImdldERlZXBlc3ROb2RlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuZ2V0RGVlcGVzdE5vZGU7XG4gIH0gfSk7XG59KSh3bik7XG52YXIgeG4gPSB7fSwgcXQgPSB7fSwgTWUgPSBDZSAmJiBDZS5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG4sIGUsIHQpIHtcbiAgaWYgKHQgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICBmb3IgKHZhciBvID0gMCwgaSA9IGUubGVuZ3RoLCBzOyBvIDwgaTsgbysrKVxuICAgICAgKHMgfHwgIShvIGluIGUpKSAmJiAocyB8fCAocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsIDAsIG8pKSwgc1tvXSA9IGVbb10pO1xuICByZXR1cm4gbi5jb25jYXQocyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHF0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5xdC5maW5kQWxsSW5wdXRzID0geXI7XG52YXIgbXIgPSBWZSwgYnIgPSBXdCwgdnIgPSBJdCwga3IgPSB1ZTtcbmZ1bmN0aW9uIHlyKG4pIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obi5xdWVyeVNlbGVjdG9yQWxsKCgwLCB2ci5hbGxJbnB1dHNTZWxlY3RvcikoKSkpLnJlZHVjZShmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuICgwLCBrci5pc05hdGl2ZUlucHV0KSh0KSB8fCAoMCwgbXIuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMpKHQpID8gTWUoTWUoW10sIGUsICEwKSwgW3RdLCAhMSkgOiBNZShNZShbXSwgZSwgITApLCAoMCwgYnIuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMpKHQpLCAhMCk7XG4gIH0sIFtdKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZmluZEFsbElucHV0cyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBxdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZmluZEFsbElucHV0c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmZpbmRBbGxJbnB1dHM7XG4gIH0gfSk7XG59KSh4bik7XG52YXIgQm4gPSB7fSwgWnQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShadCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuWnQuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IHdyO1xuZnVuY3Rpb24gd3Iobikge1xuICByZXR1cm4gIS9bXlxcdFxcblxcciBdLy50ZXN0KG4pO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0NvbGxhcHNlZFdoaXRlc3BhY2VzID0gdm9pZCAwO1xuICB2YXIgZSA9IFp0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NvbGxhcHNlZFdoaXRlc3BhY2VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcztcbiAgfSB9KTtcbn0pKEJuKTtcbnZhciBHdCA9IHt9LCBRdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5RdC5pc0VsZW1lbnQgPSB4cjtcbnZhciBFciA9IEh0O1xuZnVuY3Rpb24geHIobikge1xuICByZXR1cm4gKDAsIEVyLmlzTnVtYmVyKShuKSA/ICExIDogISFuICYmICEhbi5ub2RlVHlwZSAmJiBuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNFbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgZSA9IFF0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0VsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc0VsZW1lbnQ7XG4gIH0gfSk7XG59KShHdCk7XG52YXIgQ24gPSB7fSwgSnQgPSB7fSwgZW8gPSB7fSwgdG8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudG8uaXNMZWFmID0gQnI7XG5mdW5jdGlvbiBCcihuKSB7XG4gIHJldHVybiBuID09PSBudWxsID8gITEgOiBuLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0xlYWYgPSB2b2lkIDA7XG4gIHZhciBlID0gdG87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTGVhZlwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzTGVhZjtcbiAgfSB9KTtcbn0pKGVvKTtcbnZhciBvbyA9IHt9LCBubyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5uby5pc05vZGVFbXB0eSA9IE9yO1xudmFyIENyID0gWmUsIFRyID0gR3QsIFNyID0gdWUsIElyID0gR2U7XG5mdW5jdGlvbiBPcihuLCBlKSB7XG4gIHZhciB0ID0gXCJcIjtcbiAgcmV0dXJuICgwLCBJci5pc1NpbmdsZVRhZykobikgJiYgISgwLCBDci5pc0xpbmVCcmVha1RhZykobikgPyAhMSA6ICgoMCwgVHIuaXNFbGVtZW50KShuKSAmJiAoMCwgU3IuaXNOYXRpdmVJbnB1dCkobikgPyB0ID0gbi52YWx1ZSA6IG4udGV4dENvbnRlbnQgIT09IG51bGwgJiYgKHQgPSBuLnRleHRDb250ZW50LnJlcGxhY2UoXCLigItcIiwgXCJcIikpLCBlICE9PSB2b2lkIDAgJiYgKHQgPSB0LnJlcGxhY2UobmV3IFJlZ0V4cChlLCBcImdcIiksIFwiXCIpKSwgdC50cmltKCkubGVuZ3RoID09PSAwKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNOb2RlRW1wdHkgPSB2b2lkIDA7XG4gIHZhciBlID0gbm87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTm9kZUVtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNOb2RlRW1wdHk7XG4gIH0gfSk7XG59KShvbyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkp0LmlzRW1wdHkgPSBBcjtcbnZhciBfciA9IGVvLCBNciA9IG9vO1xuZnVuY3Rpb24gQXIobiwgZSkge1xuICBuLm5vcm1hbGl6ZSgpO1xuICBmb3IgKHZhciB0ID0gW25dOyB0Lmxlbmd0aCA+IDA7ICkge1xuICAgIHZhciBvID0gdC5zaGlmdCgpO1xuICAgIGlmIChvKSB7XG4gICAgICBpZiAobiA9IG8sICgwLCBfci5pc0xlYWYpKG4pICYmICEoMCwgTXIuaXNOb2RlRW1wdHkpKG4sIGUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB0LnB1c2guYXBwbHkodCwgQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0VtcHR5ID0gdm9pZCAwO1xuICB2YXIgZSA9IEp0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0VtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNFbXB0eTtcbiAgfSB9KTtcbn0pKENuKTtcbnZhciBUbiA9IHt9LCBpbyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGlvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5pby5pc0ZyYWdtZW50ID0gUHI7XG52YXIgTHIgPSBIdDtcbmZ1bmN0aW9uIFByKG4pIHtcbiAgcmV0dXJuICgwLCBMci5pc051bWJlcikobikgPyAhMSA6ICEhbiAmJiAhIW4ubm9kZVR5cGUgJiYgbi5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0ZyYWdtZW50ID0gdm9pZCAwO1xuICB2YXIgZSA9IGlvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNGcmFnbWVudDtcbiAgfSB9KTtcbn0pKFRuKTtcbnZhciBTbiA9IHt9LCBzbyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5zby5pc0hUTUxTdHJpbmcgPSBScjtcbnZhciBOciA9IHFlO1xuZnVuY3Rpb24gUnIobikge1xuICB2YXIgZSA9ICgwLCBOci5tYWtlKShcImRpdlwiKTtcbiAgcmV0dXJuIGUuaW5uZXJIVE1MID0gbiwgZS5jaGlsZEVsZW1lbnRDb3VudCA+IDA7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmlzSFRNTFN0cmluZyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBzbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNIVE1MU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNIVE1MU3RyaW5nO1xuICB9IH0pO1xufSkoU24pO1xudmFyIEluID0ge30sIHJvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocm8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnJvLm9mZnNldCA9IERyO1xuZnVuY3Rpb24gRHIobikge1xuICB2YXIgZSA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIG8gPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgaSA9IGUudG9wICsgbywgcyA9IGUubGVmdCArIHQ7XG4gIHJldHVybiB7XG4gICAgdG9wOiBpLFxuICAgIGxlZnQ6IHMsXG4gICAgYm90dG9tOiBpICsgZS5oZWlnaHQsXG4gICAgcmlnaHQ6IHMgKyBlLndpZHRoXG4gIH07XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLm9mZnNldCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBybztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwib2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUub2Zmc2V0O1xuICB9IH0pO1xufSkoSW4pO1xudmFyIE9uID0ge30sIGFvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYW8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmFvLnByZXBlbmQgPSBGcjtcbmZ1bmN0aW9uIEZyKG4sIGUpIHtcbiAgQXJyYXkuaXNBcnJheShlKSA/IChlID0gZS5yZXZlcnNlKCksIGUuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIG4ucHJlcGVuZCh0KTtcbiAgfSkpIDogbi5wcmVwZW5kKGUpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5wcmVwZW5kID0gdm9pZCAwO1xuICB2YXIgZSA9IGFvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJwcmVwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUucHJlcGVuZDtcbiAgfSB9KTtcbn0pKE9uKTtcbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4ucHJlcGVuZCA9IG4ub2Zmc2V0ID0gbi5tYWtlID0gbi5pc0xpbmVCcmVha1RhZyA9IG4uaXNTaW5nbGVUYWcgPSBuLmlzTm9kZUVtcHR5ID0gbi5pc0xlYWYgPSBuLmlzSFRNTFN0cmluZyA9IG4uaXNGcmFnbWVudCA9IG4uaXNFbXB0eSA9IG4uaXNFbGVtZW50ID0gbi5pc0NvbnRlbnRFZGl0YWJsZSA9IG4uaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IG4uZmluZEFsbElucHV0cyA9IG4uaXNOYXRpdmVJbnB1dCA9IG4uYWxsSW5wdXRzU2VsZWN0b3IgPSBuLmdldERlZXBlc3ROb2RlID0gbi5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IG4uZ2V0Q29udGVudExlbmd0aCA9IG4uZnJhZ21lbnRUb1N0cmluZyA9IG4uY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSBuLmNhblNldENhcmV0ID0gbi5jYWxjdWxhdGVCYXNlbGluZSA9IG4uYmxvY2tFbGVtZW50cyA9IG4uYXBwZW5kID0gdm9pZCAwO1xuICB2YXIgZSA9IEl0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJhbGxJbnB1dHNTZWxlY3RvclwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmFsbElucHV0c1NlbGVjdG9yO1xuICB9IH0pO1xuICB2YXIgdCA9IHVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc05hdGl2ZUlucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNOYXRpdmVJbnB1dDtcbiAgfSB9KTtcbiAgdmFyIG8gPSBwbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiYXBwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG8uYXBwZW5kO1xuICB9IH0pO1xuICB2YXIgaSA9IEF0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJibG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkuYmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIHMgPSBmbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY2FsY3VsYXRlQmFzZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcy5jYWxjdWxhdGVCYXNlbGluZTtcbiAgfSB9KTtcbiAgdmFyIHIgPSBnbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY2FuU2V0Q2FyZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gci5jYW5TZXRDYXJldDtcbiAgfSB9KTtcbiAgdmFyIGEgPSBWZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIGwgPSB2bjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZnJhZ21lbnRUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsLmZyYWdtZW50VG9TdHJpbmc7XG4gIH0gfSk7XG4gIHZhciBjID0ga247XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImdldENvbnRlbnRMZW5ndGhcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYy5nZXRDb250ZW50TGVuZ3RoO1xuICB9IH0pO1xuICB2YXIgdSA9IFd0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXREZWVwZXN0QmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1LmdldERlZXBlc3RCbG9ja0VsZW1lbnRzO1xuICB9IH0pO1xuICB2YXIgaCA9IHduO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXREZWVwZXN0Tm9kZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBoLmdldERlZXBlc3ROb2RlO1xuICB9IH0pO1xuICB2YXIgcCA9IHhuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJmaW5kQWxsSW5wdXRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHAuZmluZEFsbElucHV0cztcbiAgfSB9KTtcbiAgdmFyIGcgPSBCbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNDb2xsYXBzZWRXaGl0ZXNwYWNlc1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXM7XG4gIH0gfSk7XG4gIHZhciBmID0gUnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzQ29udGVudEVkaXRhYmxlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGYuaXNDb250ZW50RWRpdGFibGU7XG4gIH0gfSk7XG4gIHZhciB2ID0gR3Q7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzRWxlbWVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2LmlzRWxlbWVudDtcbiAgfSB9KTtcbiAgdmFyIE8gPSBDbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPLmlzRW1wdHk7XG4gIH0gfSk7XG4gIHZhciBUID0gVG47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVC5pc0ZyYWdtZW50O1xuICB9IH0pO1xuICB2YXIgTSA9IFNuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0hUTUxTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTS5pc0hUTUxTdHJpbmc7XG4gIH0gfSk7XG4gIHZhciBxID0gZW87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTGVhZlwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxLmlzTGVhZjtcbiAgfSB9KTtcbiAgdmFyIEYgPSBvbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNOb2RlRW1wdHlcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRi5pc05vZGVFbXB0eTtcbiAgfSB9KTtcbiAgdmFyIEggPSBaZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNMaW5lQnJlYWtUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSC5pc0xpbmVCcmVha1RhZztcbiAgfSB9KTtcbiAgdmFyIFEgPSBHZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNTaW5nbGVUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUS5pc1NpbmdsZVRhZztcbiAgfSB9KTtcbiAgdmFyIGllID0gcWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIm1ha2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWUubWFrZTtcbiAgfSB9KTtcbiAgdmFyIGsgPSBJbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwib2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGsub2Zmc2V0O1xuICB9IH0pO1xuICB2YXIgbSA9IE9uO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJwcmVwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG0ucHJlcGVuZDtcbiAgfSB9KTtcbn0pKGRlKTtcbnZhciBRZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFFlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5RZS5nZXRDb250ZW50ZWRpdGFibGVTbGljZSA9IEhyO1xudmFyIGpyID0gZGU7XG5mdW5jdGlvbiBIcihuLCBlLCB0LCBvLCBpKSB7XG4gIHZhciBzO1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMSk7XG4gIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgaWYgKG8gPT09IFwibGVmdFwiID8gKHIuc2V0U3RhcnQobiwgMCksIHIuc2V0RW5kKGUsIHQpKSA6IChyLnNldFN0YXJ0KGUsIHQpLCByLnNldEVuZChuLCBuLmNoaWxkTm9kZXMubGVuZ3RoKSksIGkgPT09ICEwKSB7XG4gICAgdmFyIGEgPSByLmV4dHJhY3RDb250ZW50cygpO1xuICAgIHJldHVybiAoMCwganIuZnJhZ21lbnRUb1N0cmluZykoYSk7XG4gIH1cbiAgdmFyIGwgPSByLmNsb25lQ29udGVudHMoKSwgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGMuYXBwZW5kQ2hpbGQobCk7XG4gIHZhciB1ID0gKHMgPSBjLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBzICE9PSB2b2lkIDAgPyBzIDogXCJcIjtcbiAgcmV0dXJuIHU7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblhlLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MgPSBVcjtcbnZhciAkciA9IGRlLCB6ciA9IFFlO1xuZnVuY3Rpb24gVXIobiwgZSwgdCwgbykge1xuICB2YXIgaSA9ICgwLCB6ci5nZXRDb250ZW50ZWRpdGFibGVTbGljZSkobiwgZSwgdCwgbyk7XG4gIHJldHVybiAoMCwgJHIuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcykoaSk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MgPSB2b2lkIDA7XG4gIHZhciBlID0gWGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3NcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzO1xuICB9IH0pO1xufSkoU3QpO1xudmFyIF9uID0ge307XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlID0gdm9pZCAwO1xuICB2YXIgZSA9IFFlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRDb250ZW50ZWRpdGFibGVTbGljZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlO1xuICB9IH0pO1xufSkoX24pO1xudmFyIE1uID0ge30sIGxvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobG8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmxvLmZvY3VzID0gWXI7XG52YXIgV3IgPSBkZTtcbmZ1bmN0aW9uIFlyKG4sIGUpIHtcbiAgdmFyIHQsIG87XG4gIGlmIChlID09PSB2b2lkIDAgJiYgKGUgPSAhMCksICgwLCBXci5pc05hdGl2ZUlucHV0KShuKSkge1xuICAgIG4uZm9jdXMoKTtcbiAgICB2YXIgaSA9IGUgPyAwIDogbi52YWx1ZS5sZW5ndGg7XG4gICAgbi5zZXRTZWxlY3Rpb25SYW5nZShpLCBpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIHIgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBhID0gZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGcgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgIHAuYXBwZW5kQ2hpbGQoZyksIHMuc2V0U3RhcnQoZywgMCksIHMuc2V0RW5kKGcsIDApO1xuICAgIH0sIGwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcCAhPSBudWxsO1xuICAgIH0sIGMgPSBuLmNoaWxkTm9kZXMsIHUgPSBlID8gY1swXSA6IGNbYy5sZW5ndGggLSAxXTtcbiAgICBpZiAobCh1KSkge1xuICAgICAgZm9yICg7IGwodSkgJiYgdS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU7IClcbiAgICAgICAgdSA9IGUgPyB1LmZpcnN0Q2hpbGQgOiB1Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChsKHUpICYmIHUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIHZhciBoID0gKG8gPSAodCA9IHUudGV4dENvbnRlbnQpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQubGVuZ3RoKSAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogMCwgaSA9IGUgPyAwIDogaDtcbiAgICAgICAgcy5zZXRTdGFydCh1LCBpKSwgcy5zZXRFbmQodSwgaSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYShuKTtcbiAgICB9IGVsc2VcbiAgICAgIGEobik7XG4gICAgci5yZW1vdmVBbGxSYW5nZXMoKSwgci5hZGRSYW5nZShzKTtcbiAgfVxufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5mb2N1cyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBsbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZm9jdXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5mb2N1cztcbiAgfSB9KTtcbn0pKE1uKTtcbnZhciBjbyA9IHt9LCBKZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEplLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5KZS5nZXRDYXJldE5vZGVBbmRPZmZzZXQgPSBLcjtcbmZ1bmN0aW9uIEtyKCkge1xuICB2YXIgbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKG4gPT09IG51bGwpXG4gICAgcmV0dXJuIFtudWxsLCAwXTtcbiAgdmFyIGUgPSBuLmZvY3VzTm9kZSwgdCA9IG4uZm9jdXNPZmZzZXQ7XG4gIHJldHVybiBlID09PSBudWxsID8gW251bGwsIDBdIDogKGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFICYmIGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIChlLmNoaWxkTm9kZXNbdF0gIT09IHZvaWQgMCA/IChlID0gZS5jaGlsZE5vZGVzW3RdLCB0ID0gMCkgOiAoZSA9IGUuY2hpbGROb2Rlc1t0IC0gMV0sIGUudGV4dENvbnRlbnQgIT09IG51bGwgJiYgKHQgPSBlLnRleHRDb250ZW50Lmxlbmd0aCkpKSwgW2UsIHRdKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0ID0gdm9pZCAwO1xuICB2YXIgZSA9IEplO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRDYXJldE5vZGVBbmRPZmZzZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5nZXRDYXJldE5vZGVBbmRPZmZzZXQ7XG4gIH0gfSk7XG59KShjbyk7XG52YXIgQW4gPSB7fSwgZXQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZXQuZ2V0UmFuZ2UgPSBYcjtcbmZ1bmN0aW9uIFhyKCkge1xuICB2YXIgbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgcmV0dXJuIG4gJiYgbi5yYW5nZUNvdW50ID8gbi5nZXRSYW5nZUF0KDApIDogbnVsbDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZ2V0UmFuZ2UgPSB2b2lkIDA7XG4gIHZhciBlID0gZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImdldFJhbmdlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuZ2V0UmFuZ2U7XG4gIH0gfSk7XG59KShBbik7XG52YXIgTG4gPSB7fSwgdW8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1bywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudW8uaXNDYXJldEF0RW5kT2ZJbnB1dCA9IFpyO1xudmFyIE9vID0gZGUsIFZyID0gY28sIHFyID0gU3Q7XG5mdW5jdGlvbiBacihuKSB7XG4gIHZhciBlID0gKDAsIE9vLmdldERlZXBlc3ROb2RlKShuLCAhMCk7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKCgwLCBPby5pc05hdGl2ZUlucHV0KShlKSlcbiAgICByZXR1cm4gZS5zZWxlY3Rpb25FbmQgPT09IGUudmFsdWUubGVuZ3RoO1xuICB2YXIgdCA9ICgwLCBWci5nZXRDYXJldE5vZGVBbmRPZmZzZXQpKCksIG8gPSB0WzBdLCBpID0gdFsxXTtcbiAgcmV0dXJuIG8gPT09IG51bGwgPyAhMSA6ICgwLCBxci5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzKShuLCBvLCBpLCBcInJpZ2h0XCIpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0NhcmV0QXRFbmRPZklucHV0ID0gdm9pZCAwO1xuICB2YXIgZSA9IHVvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NhcmV0QXRFbmRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNDYXJldEF0RW5kT2ZJbnB1dDtcbiAgfSB9KTtcbn0pKExuKTtcbnZhciBQbiA9IHt9LCBobyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5oby5pc0NhcmV0QXRTdGFydE9mSW5wdXQgPSBKcjtcbnZhciBBZSA9IGRlLCBHciA9IEplLCBRciA9IFhlO1xuZnVuY3Rpb24gSnIobikge1xuICB2YXIgZSA9ICgwLCBBZS5nZXREZWVwZXN0Tm9kZSkobik7XG4gIGlmIChlID09PSBudWxsIHx8ICgwLCBBZS5pc0VtcHR5KShuKSlcbiAgICByZXR1cm4gITA7XG4gIGlmICgoMCwgQWUuaXNOYXRpdmVJbnB1dCkoZSkpXG4gICAgcmV0dXJuIGUuc2VsZWN0aW9uRW5kID09PSAwO1xuICBpZiAoKDAsIEFlLmlzRW1wdHkpKG4pKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIHQgPSAoMCwgR3IuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0KSgpLCBvID0gdFswXSwgaSA9IHRbMV07XG4gIHJldHVybiBvID09PSBudWxsID8gITEgOiAoMCwgUXIuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcykobiwgbywgaSwgXCJsZWZ0XCIpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0NhcmV0QXRTdGFydE9mSW5wdXQgPSB2b2lkIDA7XG4gIHZhciBlID0gaG87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dDtcbiAgfSB9KTtcbn0pKFBuKTtcbnZhciBObiA9IHt9LCBwbyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5wby5zYXZlID0gb2E7XG52YXIgZWEgPSBkZSwgdGEgPSBldDtcbmZ1bmN0aW9uIG9hKCkge1xuICB2YXIgbiA9ICgwLCB0YS5nZXRSYW5nZSkoKSwgZSA9ICgwLCBlYS5tYWtlKShcInNwYW5cIik7XG4gIGlmIChlLmlkID0gXCJjdXJzb3JcIiwgZS5oaWRkZW4gPSAhMCwgISFuKVxuICAgIHJldHVybiBuLmluc2VydE5vZGUoZSksIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG8gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBvICYmIChuLnNldFN0YXJ0QWZ0ZXIoZSksIG4uc2V0RW5kQWZ0ZXIoZSksIG8ucmVtb3ZlQWxsUmFuZ2VzKCksIG8uYWRkUmFuZ2UobiksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGUucmVtb3ZlKCk7XG4gICAgICB9LCAxNTApKTtcbiAgICB9O1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5zYXZlID0gdm9pZCAwO1xuICB2YXIgZSA9IHBvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJzYXZlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuc2F2ZTtcbiAgfSB9KTtcbn0pKE5uKTtcbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uc2F2ZSA9IG4uaXNDYXJldEF0U3RhcnRPZklucHV0ID0gbi5pc0NhcmV0QXRFbmRPZklucHV0ID0gbi5nZXRSYW5nZSA9IG4uZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0ID0gbi5mb2N1cyA9IG4uZ2V0Q29udGVudGVkaXRhYmxlU2xpY2UgPSBuLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MgPSB2b2lkIDA7XG4gIHZhciBlID0gU3Q7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3NcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzO1xuICB9IH0pO1xuICB2YXIgdCA9IF9uO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRDb250ZW50ZWRpdGFibGVTbGljZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldENvbnRlbnRlZGl0YWJsZVNsaWNlO1xuICB9IH0pO1xuICB2YXIgbyA9IE1uO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJmb2N1c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvLmZvY3VzO1xuICB9IH0pO1xuICB2YXIgaSA9IGNvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRDYXJldE5vZGVBbmRPZmZzZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaS5nZXRDYXJldE5vZGVBbmRPZmZzZXQ7XG4gIH0gfSk7XG4gIHZhciBzID0gQW47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImdldFJhbmdlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMuZ2V0UmFuZ2U7XG4gIH0gfSk7XG4gIHZhciByID0gTG47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzQ2FyZXRBdEVuZE9mSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gci5pc0NhcmV0QXRFbmRPZklucHV0O1xuICB9IH0pO1xuICB2YXIgYSA9IFBuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NhcmV0QXRTdGFydE9mSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5pc0NhcmV0QXRTdGFydE9mSW5wdXQ7XG4gIH0gfSk7XG4gIHZhciBsID0gTm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcInNhdmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbC5zYXZlO1xuICB9IH0pO1xufSkoaG4pO1xuY2xhc3MgbmEgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEFsbCBrZXlkb3ducyBvbiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAga2V5ZG93bihlKSB7XG4gICAgc3dpdGNoICh0aGlzLmJlZm9yZUtleWRvd25Qcm9jZXNzaW5nKGUpLCBlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgeS5CQUNLU1BBQ0U6XG4gICAgICAgIHRoaXMuYmFja3NwYWNlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeS5ERUxFVEU6XG4gICAgICAgIHRoaXMuZGVsZXRlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeS5FTlRFUjpcbiAgICAgICAgdGhpcy5lbnRlcihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuRE9XTjpcbiAgICAgIGNhc2UgeS5SSUdIVDpcbiAgICAgICAgdGhpcy5hcnJvd1JpZ2h0QW5kRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuVVA6XG4gICAgICBjYXNlIHkuTEVGVDpcbiAgICAgICAgdGhpcy5hcnJvd0xlZnRBbmRVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuVEFCOlxuICAgICAgICB0aGlzLnRhYlByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlLmtleSA9PT0gXCIvXCIgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5ICYmIHRoaXMuc2xhc2hQcmVzc2VkKGUpLCBlLmNvZGUgPT09IFwiU2xhc2hcIiAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5jb21tYW5kU2xhc2hQcmVzc2VkKCkpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBrZXlkb3duIGJlZm9yZSBldmVudCBwcm9jZXNzaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBiZWZvcmVLZXlkb3duUHJvY2Vzc2luZyhlKSB7XG4gICAgdGhpcy5uZWVkVG9vbGJhckNsb3NpbmcoZSkgJiYgUG8oZS5rZXlDb2RlKSAmJiAodGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpLCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSkpO1xuICB9XG4gIC8qKlxuICAgKiBLZXkgdXAgb24gQmxvY2s6XG4gICAqIC0gc2hvd3MgSW5saW5lIFRvb2xiYXIgaWYgc29tZXRoaW5nIHNlbGVjdGVkXG4gICAqIC0gc2hvd3MgY29udmVyc2lvbiB0b29sYmFyIHdpdGggODUlIG9mIGJsb2NrIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5dXAgZXZlbnRcbiAgICovXG4gIGtleXVwKGUpIHtcbiAgICBlLnNoaWZ0S2V5IHx8IHRoaXMuRWRpdG9yLlVJLmNoZWNrRW1wdGluZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBkcm9wIHRhcmdldCBzdHlsZXNcbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IC0gZHJhZyBvdmVyIGV2ZW50XG4gICAqL1xuICBkcmFnT3ZlcihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICB0LmRyb3BUYXJnZXQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGRyb3AgdGFyZ2V0IHN0eWxlXG4gICAqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBldmVudCAtIGRyYWcgbGVhdmUgZXZlbnRcbiAgICovXG4gIGRyYWdMZWF2ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICB0LmRyb3BUYXJnZXQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogQ29weWluZyBzZWxlY3RlZCBibG9ja3NcbiAgICogQmVmb3JlIHB1dHRpbmcgdG8gdGhlIGNsaXBib2FyZCB3ZSBzYW5pdGl6ZSBhbGwgYmxvY2tzIGFuZCB0aGVuIGNvcHkgdG8gdGhlIGNsaXBib2FyZFxuICAgKlxuICAgKiBAcGFyYW0ge0NsaXBib2FyZEV2ZW50fSBldmVudCAtIGNsaXBib2FyZCBldmVudFxuICAgKi9cbiAgaGFuZGxlQ29tbWFuZEMoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tTZWxlY3Rpb246IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHQuYW55QmxvY2tTZWxlY3RlZCAmJiB0LmNvcHlTZWxlY3RlZEJsb2NrcyhlKTtcbiAgfVxuICAvKipcbiAgICogQ29weSBhbmQgRGVsZXRlIHNlbGVjdGVkIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0NsaXBib2FyZEV2ZW50fSBldmVudCAtIGNsaXBib2FyZCBldmVudFxuICAgKi9cbiAgaGFuZGxlQ29tbWFuZFgoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tTZWxlY3Rpb246IHQsIEJsb2NrTWFuYWdlcjogbywgQ2FyZXQ6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHQuYW55QmxvY2tTZWxlY3RlZCAmJiB0LmNvcHlTZWxlY3RlZEJsb2NrcyhlKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBvLnJlbW92ZVNlbGVjdGVkQmxvY2tzKCksIHIgPSBvLmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgocywgITApO1xuICAgICAgaS5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLlNUQVJUKSwgdC5jbGVhclNlbGVjdGlvbihlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGFiIHByZXNzZWQgaW5zaWRlIGEgQmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICB0YWJQcmVzc2VkKGUpIHtcbiAgICBjb25zdCB7IElubGluZVRvb2xiYXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAodC5vcGVuZWQpXG4gICAgICByZXR1cm47XG4gICAgKGUuc2hpZnRLZXkgPyBvLm5hdmlnYXRlUHJldmlvdXMoITApIDogby5uYXZpZ2F0ZU5leHQoITApKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgLyoqXG4gICAqICcvJyArICdjb21tYW5kJyBrZXlkb3duIGluc2lkZSBhIEJsb2NrXG4gICAqL1xuICBjb21tYW5kU2xhc2hQcmVzc2VkKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDEgfHwgdGhpcy5hY3RpdmF0ZUJsb2NrU2V0dGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogJy8nIGtleWRvd24gaW5zaWRlIGEgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgc2xhc2hQcmVzc2VkKGUpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLmlzRW1wdHkgJiYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5FZGl0b3IuQ2FyZXQuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihcIi9cIiksIHRoaXMuYWN0aXZhdGVUb29sYm94KCkpO1xuICB9XG4gIC8qKlxuICAgKiBFTlRFUiBwcmVzc2VkIG9uIGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBlbnRlcihlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFVJOiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IHQuY3VycmVudEJsb2NrO1xuICAgIGlmIChpID09PSB2b2lkIDAgfHwgaS50b29sLmlzTGluZUJyZWFrc0VuYWJsZWQgfHwgby5zb21lVG9vbGJhck9wZW5lZCAmJiBvLnNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCB8fCBlLnNoaWZ0S2V5ICYmICFwdClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgcyA9IGk7XG4gICAgaS5jdXJyZW50SW5wdXQgIT09IHZvaWQgMCAmJiBOZShpLmN1cnJlbnRJbnB1dCkgJiYgIWkuaGFzTWVkaWEgPyB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleCh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXgpIDogaS5jdXJyZW50SW5wdXQgJiYgUmUoaS5jdXJyZW50SW5wdXQpID8gcyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCArIDEpIDogcyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zcGxpdCgpLCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHMpLCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKHMpLCBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBiYWNrc3BhY2Uga2V5ZG93biBvbiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgYmFja3NwYWNlKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogaSwgcHJldmlvdXNCbG9jazogcyB9ID0gdDtcbiAgICBpZiAoaSA9PT0gdm9pZCAwIHx8ICFiLmlzQ29sbGFwc2VkIHx8ICFpLmN1cnJlbnRJbnB1dCB8fCAhTmUoaS5jdXJyZW50SW5wdXQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgIShpLmN1cnJlbnRJbnB1dCA9PT0gaS5maXJzdElucHV0KSkge1xuICAgICAgby5uYXZpZ2F0ZVByZXZpb3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2socyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2soaSk7XG4gICAgICBjb25zdCBsID0gdC5jdXJyZW50QmxvY2s7XG4gICAgICBvLnNldFRvQmxvY2sobCwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeG8ocywgaSkgPyB0aGlzLm1lcmdlQmxvY2tzKHMsIGkpIDogby5zZXRUb0Jsb2NrKHMsIG8ucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGVsZXRlIGtleWRvd24gb24gQmxvY2tcbiAgICogUmVtb3ZlcyBjaGFyIGFmdGVyIHRoZSBjYXJldC5cbiAgICogSWYgY2FyZXQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgYmxvY2ssIG1lcmdlIG5leHQgYmxvY2sgd2l0aCBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBkZWxldGUoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBpLCBuZXh0QmxvY2s6IHMgfSA9IHQ7XG4gICAgaWYgKCFiLmlzQ29sbGFwc2VkIHx8ICFSZShpLmN1cnJlbnRJbnB1dCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpLCAhKGkuY3VycmVudElucHV0ID09PSBpLmxhc3RJbnB1dCkpIHtcbiAgICAgIG8ubmF2aWdhdGVOZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2socyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLmlzRW1wdHkpIHtcbiAgICAgIHQucmVtb3ZlQmxvY2soaSksIG8uc2V0VG9CbG9jayhzLCBvLnBvc2l0aW9ucy5TVEFSVCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHhvKGksIHMpID8gdGhpcy5tZXJnZUJsb2NrcyhpLCBzKSA6IG8uc2V0VG9CbG9jayhzLCBvLnBvc2l0aW9ucy5TVEFSVCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHBhc3NlZCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldEJsb2NrIC0gdG8gd2hpY2ggQmxvY2sgd2Ugd2FudCB0byBtZXJnZVxuICAgKiBAcGFyYW0gYmxvY2tUb01lcmdlIC0gd2hhdCBCbG9jayB3ZSB3YW50IHRvIG1lcmdlXG4gICAqL1xuICBtZXJnZUJsb2NrcyhlLCB0KSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIFRvb2xiYXI6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGUubGFzdElucHV0ICE9PSB2b2lkIDAgJiYgKGhuLmZvY3VzKGUubGFzdElucHV0LCAhMSksIG8ubWVyZ2VCbG9ja3MoZSwgdCkudGhlbigoKSA9PiB7XG4gICAgICBpLmNsb3NlKCk7XG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgcmlnaHQgYW5kIGRvd24ga2V5Ym9hcmQga2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGFycm93UmlnaHRBbmREb3duKGUpIHtcbiAgICBjb25zdCB0ID0gY2UudXNlZEtleXMuaW5jbHVkZXMoZS5rZXlDb2RlKSAmJiAoIWUuc2hpZnRLZXkgfHwgZS5rZXlDb2RlID09PSB5LlRBQik7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlVJLnNvbWVUb29sYmFyT3BlbmVkICYmIHQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiBvIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIsIHMgPSAoKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uY3VycmVudElucHV0KSAhPT0gdm9pZCAwID8gUmUoby5jdXJyZW50SW5wdXQpIDogdm9pZCAwKSB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbnlCbG9ja1NlbGVjdGVkO1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0geS5ET1dOICYmIHMpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24udG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgPT09IHkuRE9XTiB8fCBlLmtleUNvZGUgPT09IHkuUklHSFQgJiYgIXRoaXMuaXNSdGwgPyB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZU5leHQoKSA6IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlUHJldmlvdXMoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBGZSgoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sudXBkYXRlQ3VycmVudElucHV0KCk7XG4gICAgfSwgMjApKCksIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbGVmdCBhbmQgdXAga2V5Ym9hcmQga2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGFycm93TGVmdEFuZFVwKGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuVUkuc29tZVRvb2xiYXJPcGVuZWQpIHtcbiAgICAgIGlmIChjZS51c2VkS2V5cy5pbmNsdWRlcyhlLmtleUNvZGUpICYmICghZS5zaGlmdEtleSB8fCBlLmtleUNvZGUgPT09IHkuVEFCKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5FZGl0b3IuVUkuY2xvc2VBbGxUb29sYmFycygpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IHQgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgaSA9ICgodCA9PSBudWxsID8gdm9pZCAwIDogdC5jdXJyZW50SW5wdXQpICE9PSB2b2lkIDAgPyBOZSh0LmN1cnJlbnRJbnB1dCkgOiB2b2lkIDApIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQ7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSB5LlVQICYmIGkpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24udG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PT0geS5VUCB8fCBlLmtleUNvZGUgPT09IHkuTEVGVCAmJiAhdGhpcy5pc1J0bCA/IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlUHJldmlvdXMoKSA6IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlTmV4dCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEZlKCgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCAyMCkoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhc2VzIHdoZW4gd2UgbmVlZCB0byBjbG9zZSBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgbmVlZFRvb2xiYXJDbG9zaW5nKGUpIHtcbiAgICBjb25zdCB0ID0gZS5rZXlDb2RlID09PSB5LkVOVEVSICYmIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQsIG8gPSBlLmtleUNvZGUgPT09IHkuRU5URVIgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQsIGkgPSBlLmtleUNvZGUgPT09IHkuRU5URVIgJiYgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQsIHMgPSBlLmtleUNvZGUgPT09IHkuVEFCO1xuICAgIHJldHVybiAhKGUuc2hpZnRLZXkgfHwgcyB8fCB0IHx8IG8gfHwgaSk7XG4gIH1cbiAgLyoqXG4gICAqIElmIFRvb2xib3ggaXMgbm90IG9wZW4sIHRoZW4ganVzdCBvcGVuIGl0IGFuZCBzaG93IHBsdXMgYnV0dG9uXG4gICAqL1xuICBhY3RpdmF0ZVRvb2xib3goKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5vcGVuZWQgfHwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xiYXIgYW5kIHNob3cgQmxvY2tTZXR0aW5ncyBiZWZvcmUgZmxpcHBpbmcgVG9vbHNcbiAgICovXG4gIGFjdGl2YXRlQmxvY2tTZXR0aW5ncygpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm9wZW5lZCB8fCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbigpO1xuICB9XG59XG5jbGFzcyBjdCB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gd29ya2luZ0FyZWEg4oCUIGVkaXRvcmBzIHdvcmtpbmcgbm9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuYmxvY2tzID0gW10sIHRoaXMud29ya2luZ0FyZWEgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgbGVuZ3RoIG9mIEJsb2NrIGluc3RhbmNlcyBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2VzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrcztcbiAgfVxuICAvKipcbiAgICogR2V0IGJsb2NrcyBodG1sIGVsZW1lbnRzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cbiAgZ2V0IG5vZGVzKCkge1xuICAgIHJldHVybiBObyh0aGlzLndvcmtpbmdBcmVhLmNoaWxkcmVuKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBzZXR0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmxvY2tzWzBdID0gbmV3IEJsb2NrKC4uLilcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIGJsb2NrIGluZGV4IG9yIGFueSBCbG9ja3MgY2xhc3MgcHJvcGVydHkga2V5IHRvIHNldFxuICAgKiBAcGFyYW0ge0Jsb2NrfSB2YWx1ZSDigJQgdmFsdWUgdG8gc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldChlLCB0LCBvKSB7XG4gICAgcmV0dXJuIGlzTmFOKE51bWJlcih0KSkgPyAoUmVmbGVjdC5zZXQoZSwgdCwgbyksICEwKSA6IChlLmluc2VydCgrdCwgbyksICEwKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBnZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIEJsb2NrcyBjbGFzcyBwcm9wZXJ0eSBrZXlcbiAgICogQHJldHVybnMge0Jsb2NrfCp9XG4gICAqL1xuICBzdGF0aWMgZ2V0KGUsIHQpIHtcbiAgICByZXR1cm4gaXNOYU4oTnVtYmVyKHQpKSA/IFJlZmxlY3QuZ2V0KGUsIHQpIDogZS5nZXQoK3QpO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIG5ldyBCbG9jayB0byB0aGUgYmxvY2tzIGFycmF5IGFuZCBhcHBlbmQgaXQgdG8gd29ya2luZyBhcmVhXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gYWRkXG4gICAqL1xuICBwdXNoKGUpIHtcbiAgICB0aGlzLmJsb2Nrcy5wdXNoKGUpLCB0aGlzLmluc2VydFRvRE9NKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwcyBibG9ja3Mgd2l0aCBpbmRleGVzIGZpcnN0IGFuZCBzZWNvbmRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0IC0gZmlyc3QgYmxvY2sgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZCAtIHNlY29uZCBibG9jayBpbmRleFxuICAgKiBAZGVwcmVjYXRlZCDigJQgdXNlICdtb3ZlJyBpbnN0ZWFkXG4gICAqL1xuICBzd2FwKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3NbdF07XG4gICAgZC5zd2FwKHRoaXMuYmxvY2tzW2VdLmhvbGRlciwgby5ob2xkZXIpLCB0aGlzLmJsb2Nrc1t0XSA9IHRoaXMuYmxvY2tzW2VdLCB0aGlzLmJsb2Nrc1tlXSA9IG87XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgYSBibG9jayBmcm9tIG9uZSB0byBhbm90aGVyIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gbmV3IGluZGV4IG9mIHRoZSBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gYmxvY2sgdG8gbW92ZVxuICAgKi9cbiAgbW92ZShlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuYmxvY2tzLnNwbGljZSh0LCAxKVswXSwgaSA9IGUgLSAxLCBzID0gTWF0aC5tYXgoMCwgaSksIHIgPSB0aGlzLmJsb2Nrc1tzXTtcbiAgICBlID4gMCA/IHRoaXMuaW5zZXJ0VG9ET00obywgXCJhZnRlcmVuZFwiLCByKSA6IHRoaXMuaW5zZXJ0VG9ET00obywgXCJiZWZvcmViZWdpblwiLCByKSwgdGhpcy5ibG9ja3Muc3BsaWNlKGUsIDAsIG8pO1xuICAgIGNvbnN0IGEgPSB0aGlzLmNvbXBvc2VCbG9ja0V2ZW50KFwibW92ZVwiLCB7XG4gICAgICBmcm9tSW5kZXg6IHQsXG4gICAgICB0b0luZGV4OiBlXG4gICAgfSk7XG4gICAgby5jYWxsKGVlLk1PVkVELCBhKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBCbG9jayBhdCBwYXNzZWQgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOKAlCBpbmRleCB0byBpbnNlcnQgQmxvY2tcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sg4oCUIEJsb2NrIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2Ug4oCUIGl0IHRydWUsIHJlcGxhY2UgYmxvY2sgb24gZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGluc2VydChlLCB0LCBvID0gITEpIHtcbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnB1c2godCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPiB0aGlzLmxlbmd0aCAmJiAoZSA9IHRoaXMubGVuZ3RoKSwgbyAmJiAodGhpcy5ibG9ja3NbZV0uaG9sZGVyLnJlbW92ZSgpLCB0aGlzLmJsb2Nrc1tlXS5jYWxsKGVlLlJFTU9WRUQpKTtcbiAgICBjb25zdCBpID0gbyA/IDEgOiAwO1xuICAgIGlmICh0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgaSwgdCksIGUgPiAwKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5ibG9ja3NbZSAtIDFdO1xuICAgICAgdGhpcy5pbnNlcnRUb0RPTSh0LCBcImFmdGVyZW5kXCIsIHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5ibG9ja3NbZSArIDFdO1xuICAgICAgcyA/IHRoaXMuaW5zZXJ0VG9ET00odCwgXCJiZWZvcmViZWdpblwiLCBzKSA6IHRoaXMuaW5zZXJ0VG9ET00odCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBibG9jayB1bmRlciBwYXNzZWQgaW5kZXggd2l0aCBwYXNzZWQgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgZXhpc3RlZCBibG9ja1xuICAgKiBAcGFyYW0gYmxvY2sgLSBuZXcgYmxvY2tcbiAgICovXG4gIHJlcGxhY2UoZSwgdCkge1xuICAgIGlmICh0aGlzLmJsb2Nrc1tlXSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJJbmNvcnJlY3QgaW5kZXhcIik7XG4gICAgdGhpcy5ibG9ja3NbZV0uaG9sZGVyLnJlcGxhY2VXaXRoKHQuaG9sZGVyKSwgdGhpcy5ibG9ja3NbZV0gPSB0O1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHNldmVyYWwgYmxvY2tzIGF0IG9uY2VcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrcyAtIGJsb2NrcyB0byBpbnNlcnRcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggdG8gaW5zZXJ0IGJsb2NrcyBhdFxuICAgKi9cbiAgaW5zZXJ0TWFueShlLCB0KSB7XG4gICAgY29uc3QgbyA9IG5ldyBEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yIChjb25zdCBpIG9mIGUpXG4gICAgICBvLmFwcGVuZENoaWxkKGkuaG9sZGVyKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgY29uc3QgaSA9IE1hdGgubWluKHQgLSAxLCB0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmJsb2Nrc1tpXS5ob2xkZXIuYWZ0ZXIobyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdCA9PT0gMCAmJiB0aGlzLndvcmtpbmdBcmVhLnByZXBlbmQobyk7XG4gICAgICB0aGlzLmJsb2Nrcy5zcGxpY2UodCwgMCwgLi4uZSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmJsb2Nrcy5wdXNoKC4uLmUpLCB0aGlzLndvcmtpbmdBcmVhLmFwcGVuZENoaWxkKG8pO1xuICAgIGUuZm9yRWFjaCgoaSkgPT4gaS5jYWxsKGVlLlJFTkRFUkVEKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZShlKSB7XG4gICAgaXNOYU4oZSkgJiYgKGUgPSB0aGlzLmxlbmd0aCAtIDEpLCB0aGlzLmJsb2Nrc1tlXS5ob2xkZXIucmVtb3ZlKCksIHRoaXMuYmxvY2tzW2VdLmNhbGwoZWUuUkVNT1ZFRCksIHRoaXMuYmxvY2tzLnNwbGljZShlLCAxKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBibG9ja3NcbiAgICovXG4gIHJlbW92ZUFsbCgpIHtcbiAgICB0aGlzLndvcmtpbmdBcmVhLmlubmVySFRNTCA9IFwiXCIsIHRoaXMuYmxvY2tzLmZvckVhY2goKGUpID0+IGUuY2FsbChlZS5SRU1PVkVEKSksIHRoaXMuYmxvY2tzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBCbG9jayBhZnRlciBwYXNzZWQgdGFyZ2V0XG4gICAqXG4gICAqIEB0b2RvIGRlY2lkZSBpZiB0aGlzIG1ldGhvZCBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sg4oCUIHRhcmdldCBhZnRlciB3aGljaCBCbG9jayBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICogQHBhcmFtIHtCbG9ja30gbmV3QmxvY2sg4oCUIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmJsb2Nrcy5pbmRleE9mKGUpO1xuICAgIHRoaXMuaW5zZXJ0KG8gKyAxLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IEJsb2NrIGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDigJQgQmxvY2sgaW5kZXhcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBpbmRleCBvZiBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBmaW5kXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBpbmRleE9mKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuaW5kZXhPZihlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBCbG9jayBpbnRvIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0luc2VydFBvc2l0aW9ufSBwb3NpdGlvbiDigJQgaW5zZXJ0IHBvc2l0aW9uIChpZiBzZXQsIHdpbGwgdXNlIGluc2VydEFkamFjZW50RWxlbWVudClcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0IOKAlCBCbG9jayByZWxhdGVkIHRvIHBvc2l0aW9uXG4gICAqL1xuICBpbnNlcnRUb0RPTShlLCB0LCBvKSB7XG4gICAgdCA/IG8uaG9sZGVyLmluc2VydEFkamFjZW50RWxlbWVudCh0LCBlLmhvbGRlcikgOiB0aGlzLndvcmtpbmdBcmVhLmFwcGVuZENoaWxkKGUuaG9sZGVyKSwgZS5jYWxsKGVlLlJFTkRFUkVEKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9zZXMgQmxvY2sgZXZlbnQgd2l0aCBwYXNzZWQgdHlwZSBhbmQgZGV0YWlsc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbCAtIGV2ZW50IGRldGFpbFxuICAgKi9cbiAgY29tcG9zZUJsb2NrRXZlbnQoZSwgdCkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB0XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IF9vID0gXCJibG9jay1yZW1vdmVkXCIsIE1vID0gXCJibG9jay1hZGRlZFwiLCBpYSA9IFwiYmxvY2stbW92ZWRcIiwgQW8gPSBcImJsb2NrLWNoYW5nZWRcIjtcbmNsYXNzIHNhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIG5ldyBwcm9taXNlIHRvIHF1ZXVlXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBwcm9taXNlIHNob3VsZCBiZSBhZGRlZCB0byBxdWV1ZVxuICAgKi9cbiAgYWRkKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIG8pID0+IHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQudGhlbihlKS50aGVuKHQpLmNhdGNoKG8pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyByYSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLl9jdXJyZW50QmxvY2tJbmRleCA9IC0xLCB0aGlzLl9ibG9ja3MgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBjdXJyZW50QmxvY2tJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrSW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBjdXJyZW50IEJsb2NrIGluZGV4IGFuZCBmaXJlIEJsb2NrIGxpZmVjeWNsZSBjYWxsYmFja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4IC0gaW5kZXggb2YgQmxvY2sgdG8gc2V0IGFzIGN1cnJlbnRcbiAgICovXG4gIHNldCBjdXJyZW50QmxvY2tJbmRleChlKSB7XG4gICAgdGhpcy5fY3VycmVudEJsb2NrSW5kZXggPSBlO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIGZpcnN0IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldCBmaXJzdEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbMF07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgbGFzdCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgbGFzdEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgY3VycmVudEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbdGhpcy5jdXJyZW50QmxvY2tJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBwYXNzZWQgQmxvY2sgYXMgYSBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIHNldCBhcyBhIGN1cnJlbnRcbiAgICovXG4gIHNldCBjdXJyZW50QmxvY2soZSkge1xuICAgIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0aGlzLmdldEJsb2NrSW5kZXgoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbmV4dCBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPT09IHRoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxID8gbnVsbCA6IHRoaXMuX2Jsb2Nrc1t0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCBCbG9jayB3aXRoIGlucHV0cyBhZnRlciBjdXJyZW50IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBuZXh0Q29udGVudGZ1bEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5zbGljZSh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgMSkuZmluZCgodCkgPT4gISF0LmlucHV0cy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgQmxvY2sgd2l0aCBpbnB1dHMgYmVmb3JlIGN1cnJlbnQgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IHByZXZpb3VzQ29udGVudGZ1bEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5zbGljZSgwLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KS5yZXZlcnNlKCkuZmluZCgodCkgPT4gISF0LmlucHV0cy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByZXZpb3VzIEJsb2NrIGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja3xudWxsfVxuICAgKi9cbiAgZ2V0IHByZXZpb3VzQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPT09IDAgPyBudWxsIDogdGhpcy5fYmxvY2tzW3RoaXMuY3VycmVudEJsb2NrSW5kZXggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFycmF5IG9mIEJsb2NrIGluc3RhbmNlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tbXX0ge0BsaW5rIEJsb2NrcyNhcnJheX1cbiAgICovXG4gIGdldCBibG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrcy5hcnJheTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZWFjaCBCbG9jayBpcyBlbXB0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0VkaXRvckVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5ldmVyeSgoZSkgPT4gZS5pc0VtcHR5KTtcbiAgfVxuICAvKipcbiAgICogU2hvdWxkIGJlIGNhbGxlZCBhZnRlciBFZGl0b3IuVUkgcHJlcGFyYXRpb25cbiAgICogRGVmaW5lIHRoaXMuX2Jsb2NrcyBwcm9wZXJ0eVxuICAgKi9cbiAgcHJlcGFyZSgpIHtcbiAgICBjb25zdCBlID0gbmV3IGN0KHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yKTtcbiAgICB0aGlzLl9ibG9ja3MgPSBuZXcgUHJveHkoZSwge1xuICAgICAgc2V0OiBjdC5zZXQsXG4gICAgICBnZXQ6IGN0LmdldFxuICAgIH0pLCB0aGlzLmxpc3RlbmVycy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjb3B5XCIsXG4gICAgICAodCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tFdmVudHMuaGFuZGxlQ29tbWFuZEModClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIElmIHJlYWRPbmx5IGlzIHRydWU6XG4gICAqICAtIFVuYmluZCBldmVudCBoYW5kbGVycyBmcm9tIGNyZWF0ZWQgQmxvY2tzXG4gICAqXG4gICAqIGlmIHJlYWRPbmx5IGlzIGZhbHNlOlxuICAgKiAgLSBCaW5kIGV2ZW50IGhhbmRsZXJzIHRvIGFsbCBleGlzdGluZyBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgQmxvY2sgaW5zdGFuY2UgYnkgdG9vbCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYmxvY2sgY3JlYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sIC0gdG9vbHMgcGFzc2VkIGluIGVkaXRvciBjb25maWcge0BsaW5rIEVkaXRvckNvbmZpZyN0b29sc31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXSAtIHVuaXF1ZSBpZCBmb3IgdGhpcyBibG9ja1xuICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IFtvcHRpb25zLmRhdGFdIC0gY29uc3RydWN0b3IgcGFyYW1zXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGNvbXBvc2VCbG9jayh7XG4gICAgdG9vbDogZSxcbiAgICBkYXRhOiB0ID0ge30sXG4gICAgaWQ6IG8gPSB2b2lkIDAsXG4gICAgdHVuZXM6IGkgPSB7fVxuICB9KSB7XG4gICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCwgciA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMuZ2V0KGUpLCBhID0gbmV3IFIoe1xuICAgICAgaWQ6IG8sXG4gICAgICBkYXRhOiB0LFxuICAgICAgdG9vbDogcixcbiAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLFxuICAgICAgcmVhZE9ubHk6IHMsXG4gICAgICB0dW5lc0RhdGE6IGlcbiAgICB9LCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIpO1xuICAgIHJldHVybiBzIHx8IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuYmluZEJsb2NrRXZlbnRzKGEpO1xuICAgIH0sIHsgdGltZW91dDogMmUzIH0pLCBhO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IGJsb2NrIGludG8gX2Jsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGluc2VydCBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gLSBibG9jaydzIHVuaXF1ZSBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9vbF0gLSBwbHVnaW4gbmFtZSwgYnkgZGVmYXVsdCBtZXRob2QgaW5zZXJ0cyB0aGUgZGVmYXVsdCBibG9jayB0eXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5kYXRhXSAtIHBsdWdpbiBkYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gLSBpbmRleCB3aGVyZSB0byBpbnNlcnQgbmV3IEJsb2NrXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubmVlZFRvRm9jdXNdIC0gZmxhZyBzaG93cyBpZiBuZWVkZWQgdG8gdXBkYXRlIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXBsYWNlXSAtIGZsYWcgc2hvd3MgaWYgYmxvY2sgYnkgcGFzc2VkIGluZGV4IHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGluc2VydGVkIG9uZVxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBpbnNlcnQoe1xuICAgIGlkOiBlID0gdm9pZCAwLFxuICAgIHRvb2w6IHQgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgZGF0YTogbyA9IHt9LFxuICAgIGluZGV4OiBpLFxuICAgIG5lZWRUb0ZvY3VzOiBzID0gITAsXG4gICAgcmVwbGFjZTogciA9ICExLFxuICAgIHR1bmVzOiBhID0ge31cbiAgfSA9IHt9KSB7XG4gICAgbGV0IGwgPSBpO1xuICAgIGwgPT09IHZvaWQgMCAmJiAobCA9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggKyAociA/IDAgOiAxKSk7XG4gICAgY29uc3QgYyA9IHRoaXMuY29tcG9zZUJsb2NrKHtcbiAgICAgIGlkOiBlLFxuICAgICAgdG9vbDogdCxcbiAgICAgIGRhdGE6IG8sXG4gICAgICB0dW5lczogYVxuICAgIH0pO1xuICAgIHJldHVybiByICYmIHRoaXMuYmxvY2tEaWRNdXRhdGVkKF9vLCB0aGlzLmdldEJsb2NrQnlJbmRleChsKSwge1xuICAgICAgaW5kZXg6IGxcbiAgICB9KSwgdGhpcy5fYmxvY2tzLmluc2VydChsLCBjLCByKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoTW8sIGMsIHtcbiAgICAgIGluZGV4OiBsXG4gICAgfSksIHMgPyB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gbCA6IGwgPD0gdGhpcy5jdXJyZW50QmxvY2tJbmRleCAmJiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KyssIGM7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgc2V2ZXJhbCBibG9ja3MgYXQgb25jZVxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tzIC0gYmxvY2tzIHRvIGluc2VydFxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCB3aGVyZSB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydE1hbnkoZSwgdCA9IDApIHtcbiAgICB0aGlzLl9ibG9ja3MuaW5zZXJ0TWFueShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIEJsb2NrIGRhdGEuXG4gICAqXG4gICAqIEN1cnJlbnRseSB3ZSBkb24ndCBoYXZlIGFuICd1cGRhdGUnIG1ldGhvZCBpbiB0aGUgVG9vbHMgQVBJLCBzbyB3ZSBqdXN0IGNyZWF0ZSBhIG5ldyBibG9jayB3aXRoIHRoZSBzYW1lIGlkIGFuZCB0eXBlXG4gICAqIFNob3VsZCBub3QgdHJpZ2dlciAnYmxvY2stcmVtb3ZlZCcgb3IgJ2Jsb2NrLWFkZGVkJyBldmVudHMuXG4gICAqXG4gICAqIElmIG5laXRoZXIgZGF0YSBub3IgdHVuZXMgaXMgcHJvdmlkZWQsIHJldHVybiB0aGUgcHJvdmlkZWQgYmxvY2sgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBkYXRhIC0gKG9wdGlvbmFsKSBuZXcgZGF0YVxuICAgKiBAcGFyYW0gdHVuZXMgLSAob3B0aW9uYWwpIHR1bmUgZGF0YVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGUsIHQsIG8pIHtcbiAgICBpZiAoIXQgJiYgIW8pXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCBpID0gYXdhaXQgZS5kYXRhLCBzID0gdGhpcy5jb21wb3NlQmxvY2soe1xuICAgICAgaWQ6IGUuaWQsXG4gICAgICB0b29sOiBlLm5hbWUsXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBpLCB0ID8/IHt9KSxcbiAgICAgIHR1bmVzOiBvID8/IGUudHVuZXNcbiAgICB9KSwgciA9IHRoaXMuZ2V0QmxvY2tJbmRleChlKTtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLnJlcGxhY2UociwgcyksIHRoaXMuYmxvY2tEaWRNdXRhdGVkKEFvLCBzLCB7XG4gICAgICBpbmRleDogclxuICAgIH0pLCBzO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIHBhc3NlZCBCbG9jayB3aXRoIHRoZSBuZXcgb25lIHdpdGggc3BlY2lmaWVkIFRvb2wgYW5kIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gcmVwbGFjZVxuICAgKiBAcGFyYW0gbmV3VG9vbCAtIG5ldyBUb29sIG5hbWVcbiAgICogQHBhcmFtIGRhdGEgLSBuZXcgVG9vbCBkYXRhXG4gICAqL1xuICByZXBsYWNlKGUsIHQsIG8pIHtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRCbG9ja0luZGV4KGUpO1xuICAgIHJldHVybiB0aGlzLmluc2VydCh7XG4gICAgICB0b29sOiB0LFxuICAgICAgZGF0YTogbyxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcmVwbGFjZTogITBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHBhc3RlZCBjb250ZW50LiBDYWxsIG9uUGFzdGUgY2FsbGJhY2sgYWZ0ZXIgaW5zZXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbE5hbWUgLSBuYW1lIG9mIFRvb2wgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gcGFzdGVFdmVudCAtIHBhc3RlZCBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSAtIHNob3VsZCByZXBsYWNlIGN1cnJlbnQgYmxvY2tcbiAgICovXG4gIHBhc3RlKGUsIHQsIG8gPSAhMSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmluc2VydCh7XG4gICAgICB0b29sOiBlLFxuICAgICAgcmVwbGFjZTogb1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGkuY2FsbChlZS5PTl9QQVNURSwgdCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBTKGAke2V9OiBvblBhc3RlIGNhbGxiYWNrIGNhbGwgaXMgZmFpbGVkYCwgXCJlcnJvclwiLCBzKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgZGVmYXVsdCBibG9jayBhdCBwYXNzZWQgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggd2hlcmUgQmxvY2sgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZFRvRm9jdXMgLSBpZiB0cnVlLCB1cGRhdGVzIGN1cnJlbnQgQmxvY2sgaW5kZXhcbiAgICpcbiAgICogVE9ETzogUmVtb3ZlIG1ldGhvZCBhbmQgdXNlIGluc2VydCgpIHdpdGggaW5kZXggaW5zdGVhZCAoPylcbiAgICogQHJldHVybnMge0Jsb2NrfSBpbnNlcnRlZCBCbG9ja1xuICAgKi9cbiAgaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleChlLCB0ID0gITEpIHtcbiAgICBjb25zdCBvID0gdGhpcy5jb21wb3NlQmxvY2soeyB0b29sOiB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tlXSA9IG8sIHRoaXMuYmxvY2tEaWRNdXRhdGVkKE1vLCBvLCB7XG4gICAgICBpbmRleDogZVxuICAgIH0pLCB0ID8gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGUgOiBlIDw9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleCsrLCBvO1xuICB9XG4gIC8qKlxuICAgKiBBbHdheXMgaW5zZXJ0cyBhdCB0aGUgZW5kXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGluc2VydEF0RW5kKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5ibG9ja3MubGVuZ3RoIC0gMSwgdGhpcy5pbnNlcnQoKTtcbiAgfVxuICAvKipcbiAgICogTWVyZ2UgdHdvIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSB0YXJnZXRCbG9jayAtIHByZXZpb3VzIGJsb2NrIHdpbGwgYmUgYXBwZW5kIHRvIHRoaXMgYmxvY2tcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2tUb01lcmdlIC0gYmxvY2sgdGhhdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRhcmdldCBibG9ja1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gLSB0aGUgc2VxdWVuY2UgdGhhdCBjYW4gYmUgY29udGludWVkXG4gICAqL1xuICBhc3luYyBtZXJnZUJsb2NrcyhlLCB0KSB7XG4gICAgbGV0IG87XG4gICAgaWYgKGUubmFtZSA9PT0gdC5uYW1lICYmIGUubWVyZ2VhYmxlKSB7XG4gICAgICBjb25zdCBpID0gYXdhaXQgdC5kYXRhO1xuICAgICAgaWYgKFYoaSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBtZXJnZSBCbG9jay4gRmFpbGVkIHRvIGV4dHJhY3Qgb3JpZ2luYWwgQmxvY2sgZGF0YS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtzXSA9IHl0KFtpXSwgZS50b29sLnNhbml0aXplQ29uZmlnKTtcbiAgICAgIG8gPSBzO1xuICAgIH0gZWxzZSBpZiAoZS5tZXJnZWFibGUgJiYgSGUodCwgXCJleHBvcnRcIikgJiYgSGUoZSwgXCJpbXBvcnRcIikpIHtcbiAgICAgIGNvbnN0IGkgPSBhd2FpdCB0LmV4cG9ydERhdGFBc1N0cmluZygpLCBzID0gWihpLCBlLnRvb2wuc2FuaXRpemVDb25maWcpO1xuICAgICAgbyA9IEJvKHMsIGUudG9vbC5jb252ZXJzaW9uQ29uZmlnKTtcbiAgICB9XG4gICAgbyAhPT0gdm9pZCAwICYmIChhd2FpdCBlLm1lcmdlV2l0aChvKSwgdGhpcy5yZW1vdmVCbG9jayh0KSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBCbG9jayB0byByZW1vdmVcbiAgICogQHBhcmFtIGFkZExhc3RCbG9jayAtIGlmIHRydWUsIGFkZHMgbmV3IGRlZmF1bHQgYmxvY2sgYXQgdGhlIGVuZC4gQHRvZG8gcmVtb3ZlIHRoaXMgbG9naWMgYW5kIHVzZSBldmVudC1idXMgaW5zdGVhZFxuICAgKi9cbiAgcmVtb3ZlQmxvY2soZSwgdCA9ICEwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChvKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fYmxvY2tzLmluZGV4T2YoZSk7XG4gICAgICBpZiAoIXRoaXMudmFsaWRhdGVJbmRleChpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBhIEJsb2NrIHRvIHJlbW92ZVwiKTtcbiAgICAgIGUuZGVzdHJveSgpLCB0aGlzLl9ibG9ja3MucmVtb3ZlKGkpLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChfbywgZSwge1xuICAgICAgICBpbmRleDogaVxuICAgICAgfSksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPj0gaSAmJiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4LS0sIHRoaXMuYmxvY2tzLmxlbmd0aCA/IGkgPT09IDAgJiYgKHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSAwKSA6ICh0aGlzLnVuc2V0Q3VycmVudEJsb2NrKCksIHQgJiYgdGhpcy5pbnNlcnQoKSksIG8oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIG9ubHkgc2VsZWN0ZWQgQmxvY2tzXG4gICAqIGFuZCByZXR1cm5zIGZpcnN0IEJsb2NrIGluZGV4IHdoZXJlIHN0YXJ0ZWQgcmVtb3ZpbmcuLi5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICByZW1vdmVTZWxlY3RlZEJsb2NrcygpIHtcbiAgICBsZXQgZTtcbiAgICBmb3IgKGxldCB0ID0gdGhpcy5ibG9ja3MubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pXG4gICAgICB0aGlzLmJsb2Nrc1t0XS5zZWxlY3RlZCAmJiAodGhpcy5yZW1vdmVCbG9jayh0aGlzLmJsb2Nrc1t0XSksIGUgPSB0KTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW50aW9uIVxuICAgKiBBZnRlciByZW1vdmluZyBpbnNlcnQgdGhlIG5ldyBkZWZhdWx0IHR5cGVkIEJsb2NrIGFuZCBmb2N1cyBvbiBpdFxuICAgKiBSZW1vdmVzIGFsbCBibG9ja3NcbiAgICovXG4gIHJlbW92ZUFsbEJsb2NrcygpIHtcbiAgICBmb3IgKGxldCBlID0gdGhpcy5ibG9ja3MubGVuZ3RoIC0gMTsgZSA+PSAwOyBlLS0pXG4gICAgICB0aGlzLl9ibG9ja3MucmVtb3ZlKGUpO1xuICAgIHRoaXMudW5zZXRDdXJyZW50QmxvY2soKSwgdGhpcy5pbnNlcnQoKSwgdGhpcy5jdXJyZW50QmxvY2suZmlyc3RJbnB1dC5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBjdXJyZW50IEJsb2NrXG4gICAqIDEuIEV4dHJhY3QgY29udGVudCBmcm9tIENhcmV0IHBvc2l0aW9uIHRvIHRoZSBCbG9ja2BzIGVuZFxuICAgKiAyLiBJbnNlcnQgYSBuZXcgQmxvY2sgYmVsb3cgY3VycmVudCBvbmUgd2l0aCBleHRyYWN0ZWQgY29udGVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBzcGxpdCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5FZGl0b3IuQ2FyZXQuZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb24oKSwgdCA9IGQubWFrZShcImRpdlwiKTtcbiAgICB0LmFwcGVuZENoaWxkKGUpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICB0ZXh0OiBkLmlzRW1wdHkodCkgPyBcIlwiIDogdC5pbm5lckhUTUxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmluc2VydCh7IGRhdGE6IG8gfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2sgYnkgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHRvIGdldC4gLTEgdG8gZ2V0IGxhc3RcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUluZGV4KGUpIHtcbiAgICByZXR1cm4gZSA9PT0gLTEgJiYgKGUgPSB0aGlzLl9ibG9ja3MubGVuZ3RoIC0gMSksIHRoaXMuX2Jsb2Nrc1tlXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbmRleCBmb3IgcGFzc2VkIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIGZpbmQgaW5kZXhcbiAgICovXG4gIGdldEJsb2NrSW5kZXgoZSkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MuaW5kZXhPZihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQmxvY2sgYnkgcGFzc2VkIGlkXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGlkIG9mIGJsb2NrIHRvIGdldFxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXRCbG9ja0J5SWQoZSkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MuYXJyYXkuZmluZCgodCkgPT4gdC5pZCA9PT0gZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jayBpbnN0YW5jZSBieSBodG1sIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRvIGdldCBCbG9jayBieVxuICAgKi9cbiAgZ2V0QmxvY2soZSkge1xuICAgIGQuaXNFbGVtZW50KGUpIHx8IChlID0gZS5wYXJlbnROb2RlKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fYmxvY2tzLm5vZGVzLCBvID0gZS5jbG9zZXN0KGAuJHtSLkNTUy53cmFwcGVyfWApLCBpID0gdC5pbmRleE9mKG8pO1xuICAgIGlmIChpID49IDApXG4gICAgICByZXR1cm4gdGhpcy5fYmxvY2tzW2ldO1xuICB9XG4gIC8qKlxuICAgKiAxKSBGaW5kIGZpcnN0LWxldmVsIEJsb2NrIGZyb20gcGFzc2VkIGNoaWxkIE5vZGVcbiAgICogMikgTWFyayBpdCBhcyBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGROb2RlIC0gbG9vayBhaGVhZCBmcm9tIHRoaXMgbm9kZS5cbiAgICogQHJldHVybnMge0Jsb2NrIHwgdW5kZWZpbmVkfSBjYW4gcmV0dXJuIHVuZGVmaW5lZCBpbiBjYXNlIHdoZW4gdGhlIHBhc3NlZCBjaGlsZCBub3RlIGlzIG5vdCBhIHBhcnQgb2YgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICBzZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlKSB7XG4gICAgZC5pc0VsZW1lbnQoZSkgfHwgKGUgPSBlLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHQgPSBlLmNsb3Nlc3QoYC4ke1IuQ1NTLndyYXBwZXJ9YCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0LmNsb3Nlc3QoYC4ke3RoaXMuRWRpdG9yLlVJLkNTUy5lZGl0b3JXcmFwcGVyfWApO1xuICAgIGlmIChvICE9IG51bGwgJiYgby5pc0VxdWFsTm9kZSh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyKSlcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5fYmxvY2tzLm5vZGVzLmluZGV4T2YodCksIHRoaXMuY3VycmVudEJsb2NrLnVwZGF0ZUN1cnJlbnRJbnB1dCgpLCB0aGlzLmN1cnJlbnRCbG9jaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGJsb2NrIHdoaWNoIGNvbnRlbnRzIHBhc3NlZCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGROb2RlIC0gbm9kZSB0byBnZXQgQmxvY2sgYnlcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUNoaWxkTm9kZShlKSB7XG4gICAgaWYgKCFlIHx8ICEoZSBpbnN0YW5jZW9mIE5vZGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGQuaXNFbGVtZW50KGUpIHx8IChlID0gZS5wYXJlbnROb2RlKTtcbiAgICBjb25zdCB0ID0gZS5jbG9zZXN0KGAuJHtSLkNTUy53cmFwcGVyfWApO1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5maW5kKChvKSA9PiBvLmhvbGRlciA9PT0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXAgQmxvY2tzIFBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBpbmRleCBvZiBmaXJzdCBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCAtIGluZGV4IG9mIHNlY29uZCBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCDigJQgdXNlICdtb3ZlJyBpbnN0ZWFkXG4gICAqL1xuICBzd2FwKGUsIHQpIHtcbiAgICB0aGlzLl9ibG9ja3Muc3dhcChlLCB0KSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgYSBibG9jayB0byBhIG5ldyBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCAtIGluZGV4IHdoZXJlIHRvIG1vdmUgQmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIG1vdmVcbiAgICovXG4gIG1vdmUoZSwgdCA9IHRoaXMuY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgICBpZiAoaXNOYU4oZSkgfHwgaXNOYU4odCkpIHtcbiAgICAgIFMoXCJXYXJuaW5nIGR1cmluZyAnbW92ZScgY2FsbDogaW5jb3JyZWN0IGluZGljZXMgcHJvdmlkZWQuXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5kZXgoZSkgfHwgIXRoaXMudmFsaWRhdGVJbmRleCh0KSkge1xuICAgICAgUyhcIldhcm5pbmcgZHVyaW5nICdtb3ZlJyBjYWxsOiBpbmRpY2VzIGNhbm5vdCBiZSBsb3dlciB0aGFuIDAgb3IgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYmxvY2tzLlwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Jsb2Nrcy5tb3ZlKGUsIHQpLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gZSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoaWEsIHRoaXMuY3VycmVudEJsb2NrLCB7XG4gICAgICBmcm9tSW5kZXg6IHQsXG4gICAgICB0b0luZGV4OiBlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHBhc3NlZCBCbG9jayB0byB0aGUgbmV3IFRvb2xcbiAgICogVXNlcyBDb252ZXJzaW9uIENvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tUb0NvbnZlcnQgLSBCbG9jayB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICogQHBhcmFtIHRhcmdldFRvb2xOYW1lIC0gbmFtZSBvZiB0aGUgVG9vbCB0byBjb252ZXJ0IHRvXG4gICAqIEBwYXJhbSBibG9ja0RhdGFPdmVycmlkZXMgLSBvcHRpb25hbCBuZXcgQmxvY2sgZGF0YSBvdmVycmlkZXNcbiAgICovXG4gIGFzeW5jIGNvbnZlcnQoZSwgdCwgbykge1xuICAgIGlmICghYXdhaXQgZS5zYXZlKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBCbG9jay4gRmFpbGVkIHRvIGV4dHJhY3Qgb3JpZ2luYWwgQmxvY2sgZGF0YS5cIik7XG4gICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMuZ2V0KHQpO1xuICAgIGlmICghcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNvbnZlcnQgQmxvY2suIFRvb2wgwqske3R9wrsgbm90IGZvdW5kLmApO1xuICAgIGNvbnN0IHIgPSBhd2FpdCBlLmV4cG9ydERhdGFBc1N0cmluZygpLCBhID0gWihcbiAgICAgIHIsXG4gICAgICBzLnNhbml0aXplQ29uZmlnXG4gICAgKTtcbiAgICBsZXQgbCA9IEJvKGEsIHMuY29udmVyc2lvbkNvbmZpZywgcy5zZXR0aW5ncyk7XG4gICAgcmV0dXJuIG8gJiYgKGwgPSBPYmplY3QuYXNzaWduKGwsIG8pKSwgdGhpcy5yZXBsYWNlKGUsIHMubmFtZSwgbCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3VycmVudCBCbG9jayBJbmRleCAtMSB3aGljaCBtZWFucyB1bmtub3duXG4gICAqIGFuZCBjbGVhciBoaWdobGlnaHRzXG4gICAqL1xuICB1bnNldEN1cnJlbnRCbG9jaygpIHtcbiAgICB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBuZWVkVG9BZGREZWZhdWx0QmxvY2sgLSAxKSBpbiBpbnRlcm5hbCBjYWxscyAoZm9yIGV4YW1wbGUsIGluIGFwaS5ibG9ja3MucmVuZGVyKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlIGRvbid0IG5lZWQgdG8gYWRkIGFuIGVtcHR5IGRlZmF1bHQgYmxvY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMikgaW4gYXBpLmJsb2Nrcy5jbGVhciB3ZSBzaG91bGQgYWRkIGVtcHR5IGJsb2NrXG4gICAqL1xuICBhc3luYyBjbGVhcihlID0gITEpIHtcbiAgICBjb25zdCB0ID0gbmV3IHNhKCk7XG4gICAgdGhpcy5ibG9ja3MuZm9yRWFjaCgobykgPT4ge1xuICAgICAgdC5hZGQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUJsb2NrKG8sICExKTtcbiAgICAgIH0pO1xuICAgIH0pLCBhd2FpdCB0LmNvbXBsZXRlZCwgdGhpcy51bnNldEN1cnJlbnRCbG9jaygpLCBlICYmIHRoaXMuaW5zZXJ0KCksIHRoaXMuRWRpdG9yLlVJLmNoZWNrRW1wdGluZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyB1cCBhbGwgdGhlIGJsb2NrIHRvb2xzJyByZXNvdXJjZXNcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAqL1xuICBhc3luYyBkZXN0cm95KCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYmxvY2tzLm1hcCgoZSkgPT4gZS5kZXN0cm95KCkpKTtcbiAgfVxuICAvKipcbiAgICogQmluZCBCbG9jayBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byB3aGljaCBldmVudCBzaG91bGQgYmUgYm91bmRcbiAgICovXG4gIGJpbmRCbG9ja0V2ZW50cyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja0V2ZW50czogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwia2V5ZG93blwiLCAobykgPT4ge1xuICAgICAgdC5rZXlkb3duKG8pO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLmhvbGRlciwgXCJrZXl1cFwiLCAobykgPT4ge1xuICAgICAgdC5rZXl1cChvKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwiZHJhZ292ZXJcIiwgKG8pID0+IHtcbiAgICAgIHQuZHJhZ092ZXIobyk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImRyYWdsZWF2ZVwiLCAobykgPT4ge1xuICAgICAgdC5kcmFnTGVhdmUobyk7XG4gICAgfSksIGUub24oXCJkaWRNdXRhdGVkXCIsIChvKSA9PiB0aGlzLmJsb2NrRGlkTXV0YXRlZChBbywgbywge1xuICAgICAgaW5kZXg6IHRoaXMuZ2V0QmxvY2tJbmRleChvKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBtdXRhYmxlIGhhbmRsZXJzIGFuZCBiaW5kaW5nc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgYWxsIG1vZHVsZSBoYW5kbGVycyBhbmQgYmluZGluZ3MgZm9yIGFsbCBCbG9ja3NcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImN1dFwiLFxuICAgICAgKGUpID0+IHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmhhbmRsZUNvbW1hbmRYKGUpXG4gICAgKSwgdGhpcy5ibG9ja3MuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5iaW5kQmxvY2tFdmVudHMoZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBnaXZlbiBpbmRleCBpcyBub3QgbG93ZXIgdGhhbiAwIG9yIGhpZ2hlciB0aGFuIHRoZSBhbW91bnQgb2YgYmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIGJsb2NrcyBhcnJheSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlSW5kZXgoZSkge1xuICAgIHJldHVybiAhKGUgPCAwIHx8IGUgPj0gdGhpcy5fYmxvY2tzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIG11dGF0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvblR5cGUgLSB3aGF0IGhhcHBlbmVkIHdpdGggYmxvY2tcbiAgICogQHBhcmFtIGJsb2NrIC0gbXV0YXRlZCBibG9ja1xuICAgKiBAcGFyYW0gZGV0YWlsRGF0YSAtIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggY2hhbmdlIGV2ZW50XG4gICAqL1xuICBibG9ja0RpZE11dGF0ZWQoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIHRhcmdldDogbmV3IEoodCksXG4gICAgICAgIC4uLm9cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQoJG8sIHtcbiAgICAgIGV2ZW50OiBpXG4gICAgfSksIHQ7XG4gIH1cbn1cbmNsYXNzIGFhIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID0gbnVsbCwgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMSwgdGhpcy5uYXRpdmVJbnB1dFNlbGVjdGVkID0gITEsIHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBDb25maWdcbiAgICpcbiAgICogQHJldHVybnMge1Nhbml0aXplckNvbmZpZ31cbiAgICovXG4gIGdldCBzYW5pdGl6ZXJDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHt9LFxuICAgICAgaDE6IHt9LFxuICAgICAgaDI6IHt9LFxuICAgICAgaDM6IHt9LFxuICAgICAgaDQ6IHt9LFxuICAgICAgaDU6IHt9LFxuICAgICAgaDY6IHt9LFxuICAgICAgb2w6IHt9LFxuICAgICAgdWw6IHt9LFxuICAgICAgbGk6IHt9LFxuICAgICAgYnI6ICEwLFxuICAgICAgaW1nOiB7XG4gICAgICAgIHNyYzogITAsXG4gICAgICAgIHdpZHRoOiAhMCxcbiAgICAgICAgaGVpZ2h0OiAhMFxuICAgICAgfSxcbiAgICAgIGE6IHtcbiAgICAgICAgaHJlZjogITBcbiAgICAgIH0sXG4gICAgICBiOiB7fSxcbiAgICAgIGk6IHt9LFxuICAgICAgdToge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGbGFnIHRoYXQgaWRlbnRpZmllcyBhbGwgQmxvY2tzIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBhbGxCbG9ja3NTZWxlY3RlZCgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIGUuYmxvY2tzLmV2ZXJ5KCh0KSA9PiB0LnNlbGVjdGVkID09PSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBhbGwgYmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSBzdGF0ZSB0byBzZXRcbiAgICovXG4gIHNldCBhbGxCbG9ja3NTZWxlY3RlZChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHQuYmxvY2tzLmZvckVhY2goKG8pID0+IHtcbiAgICAgIG8uc2VsZWN0ZWQgPSBlO1xuICAgIH0pLCB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgfVxuICAvKipcbiAgICogRmxhZyB0aGF0IGlkZW50aWZpZXMgYW55IEJsb2NrIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBhbnlCbG9ja1NlbGVjdGVkKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlIH0gPSB0aGlzLkVkaXRvcjtcbiAgICByZXR1cm4gdGhpcy5hbnlCbG9ja1NlbGVjdGVkQ2FjaGUgPT09IG51bGwgJiYgKHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID0gZS5ibG9ja3Muc29tZSgodCkgPT4gdC5zZWxlY3RlZCA9PT0gITApKSwgdGhpcy5hbnlCbG9ja1NlbGVjdGVkQ2FjaGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBzZWxlY3RlZCBCbG9ja3MgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrW119XG4gICAqL1xuICBnZXQgc2VsZWN0ZWRCbG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MuZmlsdGVyKChlKSA9PiBlLnNlbGVjdGVkKTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIFByZXBhcmF0aW9uXG4gICAqIFJlZ2lzdGVycyBTaG9ydGN1dHMgQ01EK0EgYW5kIENNRCtDXG4gICAqIHRvIHNlbGVjdCBhbGwgYW5kIGNvcHkgdGhlbVxuICAgKi9cbiAgcHJlcGFyZSgpIHtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBiKCksIGdlLmFkZCh7XG4gICAgICBuYW1lOiBcIkNNRCtBXCIsXG4gICAgICBoYW5kbGVyOiAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgUmVhZE9ubHk6IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgICBpZiAoby5pc0VuYWJsZWQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuc2VsZWN0QWxsQmxvY2tzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHQuY3VycmVudEJsb2NrICYmIHRoaXMuaGFuZGxlQ29tbWFuZEEoZSk7XG4gICAgICB9LFxuICAgICAgb246IHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogIC0gUmVtb3ZlIGFsbCByYW5nZXNcbiAgICogIC0gVW5zZWxlY3QgYWxsIEJsb2Nrc1xuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoKSB7XG4gICAgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgdGhpcy5hbGxCbG9ja3NTZWxlY3RlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZWN0aW9uIG9mIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gaW5kZXggLSBCbG9jayBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIEJsb2NrTWFuYWdlcidzIGluZGV4ZXNcbiAgICovXG4gIHVuU2VsZWN0QmxvY2tCeUluZGV4KGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgbGV0IG87XG4gICAgaXNOYU4oZSkgPyBvID0gdC5jdXJyZW50QmxvY2sgOiBvID0gdC5nZXRCbG9ja0J5SW5kZXgoZSksIG8uc2VsZWN0ZWQgPSAhMSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIHNlbGVjdGlvbiBmcm9tIEJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSByZWFzb24gLSBldmVudCBjYXVzZWQgY2xlYXIgb2Ygc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzdG9yZVNlbGVjdGlvbiAtIGlmIHRydWUsIHJlc3RvcmUgc2F2ZWQgc2VsZWN0aW9uXG4gICAqL1xuICBjbGVhclNlbGVjdGlvbihlLCB0ID0gITEpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogbywgQ2FyZXQ6IGksIFJlY3RhbmdsZVNlbGVjdGlvbjogcyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMSwgdGhpcy5uYXRpdmVJbnB1dFNlbGVjdGVkID0gITEsIHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uID0gITE7XG4gICAgY29uc3QgciA9IGUgJiYgZSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQsIGEgPSByICYmIFBvKGUua2V5Q29kZSk7XG4gICAgaWYgKHRoaXMuYW55QmxvY2tTZWxlY3RlZCAmJiByICYmIGEgJiYgIWIuaXNTZWxlY3Rpb25FeGlzdHMpIHtcbiAgICAgIGNvbnN0IGwgPSBvLnJlbW92ZVNlbGVjdGVkQmxvY2tzKCk7XG4gICAgICBvLmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgobCwgITApLCBpLnNldFRvQmxvY2soby5jdXJyZW50QmxvY2spLCBGZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBlLmtleTtcbiAgICAgICAgaS5pbnNlcnRDb250ZW50QXRDYXJldFBvc2l0aW9uKGMubGVuZ3RoID4gMSA/IFwiXCIgOiBjKTtcbiAgICAgIH0sIDIwKSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5FZGl0b3IuQ3Jvc3NCbG9ja1NlbGVjdGlvbi5jbGVhcihlKSwgIXRoaXMuYW55QmxvY2tTZWxlY3RlZCB8fCBzLmlzUmVjdEFjdGl2YXRlZCgpKSB7XG4gICAgICB0aGlzLkVkaXRvci5SZWN0YW5nbGVTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCAmJiB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVkdWNlIGVhY2ggQmxvY2sgYW5kIGNvcHkgaXRzIGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZSAtIGNvcHkvY3V0IGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgY29weVNlbGVjdGVkQmxvY2tzKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgdCA9IGQubWFrZShcImRpdlwiKTtcbiAgICB0aGlzLnNlbGVjdGVkQmxvY2tzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBaKHMuaG9sZGVyLmlubmVySFRNTCwgdGhpcy5zYW5pdGl6ZXJDb25maWcpLCBhID0gZC5tYWtlKFwicFwiKTtcbiAgICAgIGEuaW5uZXJIVE1MID0gciwgdC5hcHBlbmRDaGlsZChhKTtcbiAgICB9KTtcbiAgICBjb25zdCBvID0gQXJyYXkuZnJvbSh0LmNoaWxkTm9kZXMpLm1hcCgocykgPT4gcy50ZXh0Q29udGVudCkuam9pbihgXG5cbmApLCBpID0gdC5pbm5lckhUTUw7XG4gICAgcmV0dXJuIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBvKSwgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgaSksIFByb21pc2UuYWxsKHRoaXMuc2VsZWN0ZWRCbG9ja3MubWFwKChzKSA9PiBzLnNhdmUoKSkpLnRoZW4oKHMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKHRoaXMuRWRpdG9yLlBhc3RlLk1JTUVfVFlQRSwgSlNPTi5zdHJpbmdpZnkocykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBCbG9jayBieSBpdHMgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXI/fSBpbmRleCAtIEJsb2NrIGluZGV4IGFjY29yZGluZyB0byB0aGUgQmxvY2tNYW5hZ2VyJ3MgaW5kZXhlc1xuICAgKi9cbiAgc2VsZWN0QmxvY2tCeUluZGV4KGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSB0LmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBvICE9PSB2b2lkIDAgJiYgdGhpcy5zZWxlY3RCbG9jayhvKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIHNlbGVjdFxuICAgKi9cbiAgc2VsZWN0QmxvY2soZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSwgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgZS5zZWxlY3RlZCA9ICEwLCB0aGlzLmNsZWFyQ2FjaGUoKSwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZWN0aW9uIGZyb20gcGFzc2VkIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gdW5zZWxlY3RcbiAgICovXG4gIHVuc2VsZWN0QmxvY2soZSkge1xuICAgIGUuc2VsZWN0ZWQgPSAhMSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFueUJsb2NrU2VsZWN0ZWQgY2FjaGVcbiAgICovXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5hbnlCbG9ja1NlbGVjdGVkQ2FjaGUgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgZGVzdHJ1Y3Rpb25cbiAgICogRGUtcmVnaXN0ZXJzIFNob3J0Y3V0IENNRCtBXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGdlLnJlbW92ZSh0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvciwgXCJDTUQrQVwiKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgQ01EK0Egc2VsZWN0cyBhbGwgaW5wdXQgY29udGVudCBieSBuYXRpdmUgYmVoYXZpb3VyLFxuICAgKiBuZXh0IENNRCtBIGtleXByZXNzIHNlbGVjdHMgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRBKGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCksIGQuaXNOYXRpdmVJbnB1dChlLnRhcmdldCkgJiYgIXRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrKGUudGFyZ2V0KSwgbyA9IHQuaW5wdXRzO1xuICAgIGlmIChvLmxlbmd0aCA+IDEgJiYgIXRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoby5sZW5ndGggPT09IDEgJiYgIXRoaXMubmVlZFRvU2VsZWN0QWxsKSB7XG4gICAgICB0aGlzLm5lZWRUb1NlbGVjdEFsbCA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5lZWRUb1NlbGVjdEFsbCA/IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuc2VsZWN0QWxsQmxvY2tzKCksIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uID0gITEpIDogdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gJiYgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5zZWxlY3RCbG9jayh0KSwgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBBbGwgQmxvY2tzXG4gICAqIEVhY2ggQmxvY2sgaGFzIHNlbGVjdGVkIHNldHRlciB0aGF0IG1ha2VzIEJsb2NrIGNvcHlhYmxlXG4gICAqL1xuICBzZWxlY3RBbGxCbG9ja3MoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpLCBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpLCB0aGlzLmFsbEJsb2Nrc1NlbGVjdGVkID0gITAsIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxufVxuY2xhc3MgWWUgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEFsbG93ZWQgY2FyZXQgcG9zaXRpb25zIGluIGlucHV0XG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybnMge3tTVEFSVDogc3RyaW5nLCBFTkQ6IHN0cmluZywgREVGQVVMVDogc3RyaW5nfX1cbiAgICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFNUQVJUOiBcInN0YXJ0XCIsXG4gICAgICBFTkQ6IFwiZW5kXCIsXG4gICAgICBERUZBVUxUOiBcImRlZmF1bHRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEVsZW1lbnRzIHN0eWxlcyB0aGF0IGNhbiBiZSB1c2VmdWwgZm9yIENhcmV0IE1vZHVsZVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNoYWRvd0NhcmV0OiBcImNkeC1zaGFkb3ctY2FyZXRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBnZXRzIEJsb2NrIGluc3RhbmNlIGFuZCBwdXRzIGNhcmV0IHRvIHRoZSB0ZXh0IG5vZGUgd2l0aCBvZmZzZXRcbiAgICogVGhlcmUgdHdvIHdheXMgdGhhdCBtZXRob2QgYXBwbGllcyBjYXJldCBwb3NpdGlvbjpcbiAgICogICAtIGZpcnN0IGZvdW5kIHRleHQgbm9kZTogc2V0cyBhdCB0aGUgYmVnaW5uaW5nLCBidXQgeW91IGNhbiBwYXNzIGFuIG9mZnNldFxuICAgKiAgIC0gbGFzdCBmb3VuZCB0ZXh0IG5vZGU6IHNldHMgYXQgdGhlIGVuZCBvZiB0aGUgbm9kZS4gQWxzbywgeW91IGNhbiBjdXN0b21pemUgdGhlIGJlaGF2aW91clxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIGNsYXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAtIHBvc2l0aW9uIHdoZXJlIHRvIHNldCBjYXJldC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZGVmYXVsdCAtIGxlYXZlIGRlZmF1bHQgYmVoYXZpb3VyIGFuZCBhcHBseSBvZmZzZXQgaWYgaXQncyBwYXNzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIGNhcmV0IG9mZnNldCByZWdhcmRpbmcgdG8gdGhlIHRleHQgbm9kZVxuICAgKi9cbiAgc2V0VG9CbG9jayhlLCB0ID0gdGhpcy5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApIHtcbiAgICB2YXIgYztcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogaSwgQmxvY2tTZWxlY3Rpb246IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmIChzLmNsZWFyU2VsZWN0aW9uKCksICFlLmZvY3VzYWJsZSkge1xuICAgICAgKGMgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgfHwgYy5yZW1vdmVBbGxSYW5nZXMoKSwgcy5zZWxlY3RCbG9jayhlKSwgaS5jdXJyZW50QmxvY2sgPSBlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcjtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuU1RBUlQ6XG4gICAgICAgIHIgPSBlLmZpcnN0SW5wdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLnBvc2l0aW9ucy5FTkQ6XG4gICAgICAgIHIgPSBlLmxhc3RJbnB1dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByID0gZS5jdXJyZW50SW5wdXQ7XG4gICAgfVxuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gZC5nZXREZWVwZXN0Tm9kZShyLCB0ID09PSB0aGlzLnBvc2l0aW9ucy5FTkQpLCBsID0gZC5nZXRDb250ZW50TGVuZ3RoKGEpO1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgdCA9PT0gdGhpcy5wb3NpdGlvbnMuU1RBUlQ6XG4gICAgICAgIG8gPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdCA9PT0gdGhpcy5wb3NpdGlvbnMuRU5EOlxuICAgICAgY2FzZSBvID4gbDpcbiAgICAgICAgbyA9IGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnNldChhLCBvKSwgaS5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlLmhvbGRlciksIGkuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dCA9IHI7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBjYXJldCB0byB0aGUgY3VycmVudCBpbnB1dCBvZiBjdXJyZW50IEJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCAtIGlucHV0IHdoZXJlIGNhcmV0IHNob3VsZCBiZSBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIC0gcG9zaXRpb24gb2YgdGhlIGNhcmV0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBkZWZhdWx0IC0gbGVhdmUgZGVmYXVsdCBiZWhhdmlvdXIgYW5kIGFwcGx5IG9mZnNldCBpZiBpdCdzIHBhc3NlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gY2FyZXQgb2Zmc2V0IHJlZ2FyZGluZyB0byB0aGUgdGV4dCBub2RlXG4gICAqL1xuICBzZXRUb0lucHV0KGUsIHQgPSB0aGlzLnBvc2l0aW9ucy5ERUZBVUxULCBvID0gMCkge1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiBpIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIsIHMgPSBkLmdldERlZXBlc3ROb2RlKGUpO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSB0aGlzLnBvc2l0aW9ucy5TVEFSVDpcbiAgICAgICAgdGhpcy5zZXQocywgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0aGlzLnBvc2l0aW9ucy5FTkQ6XG4gICAgICAgIHRoaXMuc2V0KHMsIGQuZ2V0Q29udGVudExlbmd0aChzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbyAmJiB0aGlzLnNldChzLCBvKTtcbiAgICB9XG4gICAgaS5jdXJyZW50SW5wdXQgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIERvY3VtZW50IFJhbmdlIGFuZCBzZXRzIGNhcmV0IHRvIHRoZSBlbGVtZW50IHdpdGggb2Zmc2V0XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIG9mZnNldFxuICAgKi9cbiAgc2V0KGUsIHQgPSAwKSB7XG4gICAgY29uc3QgeyB0b3A6IGksIGJvdHRvbTogcyB9ID0gYi5zZXRDdXJzb3IoZSwgdCksIHsgaW5uZXJIZWlnaHQ6IHIgfSA9IHdpbmRvdztcbiAgICBpIDwgMCA/IHdpbmRvdy5zY3JvbGxCeSgwLCBpIC0gMzApIDogcyA+IHIgJiYgd2luZG93LnNjcm9sbEJ5KDAsIHMgLSByICsgMzApO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgQ2FyZXQgdG8gdGhlIGxhc3QgQmxvY2tcbiAgICogSWYgbGFzdCBibG9jayBpcyBub3QgZW1wdHksIGFwcGVuZCBhbm90aGVyIGVtcHR5IGJsb2NrXG4gICAqL1xuICBzZXRUb1RoZUxhc3RCbG9jaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmxhc3RCbG9jaztcbiAgICBpZiAoZSlcbiAgICAgIGlmIChlLnRvb2wuaXNEZWZhdWx0ICYmIGUuaXNFbXB0eSlcbiAgICAgICAgdGhpcy5zZXRUb0Jsb2NrKGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0QXRFbmQoKTtcbiAgICAgICAgdGhpcy5zZXRUb0Jsb2NrKHQpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IGNvbnRlbnQgZnJhZ21lbnQgb2YgY3VycmVudCBCbG9jayBmcm9tIENhcmV0IHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIEJsb2NrXG4gICAqL1xuICBleHRyYWN0RnJhZ21lbnRGcm9tQ2FyZXRQb3NpdGlvbigpIHtcbiAgICBjb25zdCBlID0gYi5nZXQoKTtcbiAgICBpZiAoZS5yYW5nZUNvdW50KSB7XG4gICAgICBjb25zdCB0ID0gZS5nZXRSYW5nZUF0KDApLCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQ7XG4gICAgICBpZiAodC5kZWxldGVDb250ZW50cygpLCBvKVxuICAgICAgICBpZiAoZC5pc05hdGl2ZUlucHV0KG8pKSB7XG4gICAgICAgICAgY29uc3QgaSA9IG8sIHMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHIgPSBpLnZhbHVlLnN1YnN0cmluZygwLCBpLnNlbGVjdGlvblN0YXJ0KSwgYSA9IGkudmFsdWUuc3Vic3RyaW5nKGkuc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgIHJldHVybiBzLnRleHRDb250ZW50ID0gYSwgaS52YWx1ZSA9IHIsIHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaSA9IHQuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgIHJldHVybiBpLnNlbGVjdE5vZGVDb250ZW50cyhvKSwgaS5zZXRTdGFydCh0LmVuZENvbnRhaW5lciwgdC5lbmRPZmZzZXQpLCBpLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQncyBjYXJldCB0byB0aGUgbmV4dCBCbG9jayBvciBUb29sYHMgaW5wdXRcbiAgICogQmVmb3JlIG1vdmluZyBjYXJldCwgd2Ugc2hvdWxkIGNoZWNrIGlmIGNhcmV0IHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2YgUGx1Z2lucyBub2RlXG4gICAqIFVzaW5nIHtAbGluayBEb20jZ2V0RGVlcGVzdE5vZGV9IHRvIGdldCBhIGxhc3Qgbm9kZSBhbmQgbWF0Y2ggd2l0aCBjdXJyZW50IHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gcGFzcyB0cnVlIHRvIHNraXAgY2hlY2sgZm9yIGNhcmV0IHBvc2l0aW9uXG4gICAqL1xuICBuYXZpZ2F0ZU5leHQoZSA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogbywgbmV4dEJsb2NrOiBpIH0gPSB0O1xuICAgIGlmIChvID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgeyBuZXh0SW5wdXQ6IHMsIGN1cnJlbnRJbnB1dDogciB9ID0gbywgYSA9IHIgIT09IHZvaWQgMCA/IFJlKHIpIDogdm9pZCAwO1xuICAgIGxldCBsID0gaTtcbiAgICBjb25zdCBjID0gZSB8fCBhIHx8ICFvLmZvY3VzYWJsZTtcbiAgICBpZiAocyAmJiBjKVxuICAgICAgcmV0dXJuIHRoaXMuc2V0VG9JbnB1dChzLCB0aGlzLnBvc2l0aW9ucy5TVEFSVCksICEwO1xuICAgIGlmIChsID09PSBudWxsKSB7XG4gICAgICBpZiAoby50b29sLmlzRGVmYXVsdCB8fCAhYylcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgbCA9IHQuaW5zZXJ0QXRFbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGMgPyAodGhpcy5zZXRUb0Jsb2NrKGwsIHRoaXMucG9zaXRpb25zLlNUQVJUKSwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCdzIGNhcmV0IHRvIHRoZSBwcmV2aW91cyBUb29sYHMgaW5wdXQgb3IgQmxvY2tcbiAgICogQmVmb3JlIG1vdmluZyBjYXJldCwgd2Ugc2hvdWxkIGNoZWNrIGlmIGNhcmV0IHBvc2l0aW9uIGlzIHN0YXJ0IG9mIHRoZSBQbHVnaW5zIG5vZGVcbiAgICogVXNpbmcge0BsaW5rIERvbSNnZXREZWVwZXN0Tm9kZX0gdG8gZ2V0IGEgbGFzdCBub2RlIGFuZCBtYXRjaCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBwYXNzIHRydWUgdG8gc2tpcCBjaGVjayBmb3IgY2FyZXQgcG9zaXRpb25cbiAgICovXG4gIG5hdmlnYXRlUHJldmlvdXMoZSA9ICExKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IHQsIHByZXZpb3VzQmxvY2s6IG8gfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlcjtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgeyBwcmV2aW91c0lucHV0OiBpLCBjdXJyZW50SW5wdXQ6IHMgfSA9IHQsIHIgPSBzICE9PSB2b2lkIDAgPyBOZShzKSA6IHZvaWQgMCwgYSA9IGUgfHwgciB8fCAhdC5mb2N1c2FibGU7XG4gICAgcmV0dXJuIGkgJiYgYSA/ICh0aGlzLnNldFRvSW5wdXQoaSwgdGhpcy5wb3NpdGlvbnMuRU5EKSwgITApIDogbyAhPT0gbnVsbCAmJiBhID8gKHRoaXMuc2V0VG9CbG9jayhvLCB0aGlzLnBvc2l0aW9ucy5FTkQpLCAhMCkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBzaGFkb3cgZWxlbWVudCBhZnRlciBwYXNzZWQgZWxlbWVudCB3aGVyZSBjYXJldCBjYW4gYmUgcGxhY2VkXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgYWZ0ZXIgd2hpY2ggc2hhZG93IGNhcmV0IHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKi9cbiAgY3JlYXRlU2hhZG93KGUpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdC5jbGFzc0xpc3QuYWRkKFllLkNTUy5zaGFkb3dDYXJldCksIGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlZW5kXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyBjYXJldCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB3aGVyZSBjYXJldCBzaG91bGQgYmUgcmVzdG9yZWRcbiAgICovXG4gIHJlc3RvcmVDYXJldChlKSB7XG4gICAgY29uc3QgdCA9IGUucXVlcnlTZWxlY3RvcihgLiR7WWUuQ1NTLnNoYWRvd0NhcmV0fWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBuZXcgYigpLmV4cGFuZFRvVGFnKHQpO1xuICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGkuc2VsZWN0Tm9kZSh0KSwgaS5leHRyYWN0Q29udGVudHMoKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBwYXNzZWQgY29udGVudCBhdCBjYXJldCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAtIGNvbnRlbnQgdG8gaW5zZXJ0XG4gICAqL1xuICBpbnNlcnRDb250ZW50QXRDYXJldFBvc2l0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgaSA9IGIuZ2V0KCksIHMgPSBiLnJhbmdlO1xuICAgIG8uaW5uZXJIVE1MID0gZSwgQXJyYXkuZnJvbShvLmNoaWxkTm9kZXMpLmZvckVhY2goKGMpID0+IHQuYXBwZW5kQ2hpbGQoYykpLCB0LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwICYmIHQuYXBwZW5kQ2hpbGQobmV3IFRleHQoKSk7XG4gICAgY29uc3QgciA9IHQubGFzdENoaWxkO1xuICAgIHMuZGVsZXRlQ29udGVudHMoKSwgcy5pbnNlcnROb2RlKHQpO1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCBsID0gci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyByIDogci5maXJzdENoaWxkO1xuICAgIGwgIT09IG51bGwgJiYgbC50ZXh0Q29udGVudCAhPT0gbnVsbCAmJiBhLnNldFN0YXJ0KGwsIGwudGV4dENvbnRlbnQubGVuZ3RoKSwgaS5yZW1vdmVBbGxSYW5nZXMoKSwgaS5hZGRSYW5nZShhKTtcbiAgfVxufVxuY2xhc3MgbGEgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5vbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5vZmYoZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHRoaXMub25Nb3VzZU92ZXIpLCB0aGlzLmxpc3RlbmVycy5vZmYoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcCk7XG4gICAgfSwgdGhpcy5vbk1vdXNlT3ZlciA9IChlKSA9PiB7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PT0gbnVsbCAmJiBlLnRhcmdldCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHQuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnJlbGF0ZWRUYXJnZXQpIHx8IHRoaXMubGFzdFNlbGVjdGVkQmxvY2ssIHMgPSB0LmdldEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgICAgaWYgKCEoIWkgfHwgIXMpICYmIHMgIT09IGkpIHtcbiAgICAgICAgaWYgKGkgPT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSB7XG4gICAgICAgICAgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgaS5zZWxlY3RlZCA9ICEwLCBzLnNlbGVjdGVkID0gITAsIG8uY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocyA9PT0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2spIHtcbiAgICAgICAgICBpLnNlbGVjdGVkID0gITEsIHMuc2VsZWN0ZWQgPSAhMSwgby5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgdGhpcy50b2dnbGVCbG9ja3NTZWxlY3RlZFN0YXRlKGksIHMpLCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgcHJlcGFyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5lbmFibGVDcm9zc0Jsb2NrU2VsZWN0aW9uKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHVwIGxpc3RlbmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gbW91c2UgZG93biBldmVudFxuICAgKi9cbiAgd2F0Y2hTZWxlY3Rpb24oZSkge1xuICAgIGlmIChlLmJ1dHRvbiAhPT0gcW4uTEVGVClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPSB0LmdldEJsb2NrKGUudGFyZ2V0KSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdGhpcy5vbk1vdXNlT3ZlciksIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpcyBjcm9zcyBibG9jayBzZWxlY3Rpb24gc3RhcnRlZDpcbiAgICogdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDIgc2VsZWN0ZWQgYmxvY2tzXG4gICAqL1xuICBnZXQgaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayAmJiAhIXRoaXMubGFzdFNlbGVjdGVkQmxvY2sgJiYgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgIT09IHRoaXMubGFzdFNlbGVjdGVkQmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSBzZWxlY3Rpb24gc3RhdGUgb2YgdGhlIG5leHQgQmxvY2tcbiAgICogVXNlZCBmb3IgQ0JTIHZpYSBTaGlmdCArIGFycm93IGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBuZXh0IC0gaWYgdHJ1ZSwgdG9nZ2xlIG5leHQgYmxvY2suIFByZXZpb3VzIG90aGVyd2lzZVxuICAgKi9cbiAgdG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKGUgPSAhMCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayB8fCAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdC5jdXJyZW50QmxvY2spLCB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9PT0gdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayAmJiAodGhpcy5maXJzdFNlbGVjdGVkQmxvY2suc2VsZWN0ZWQgPSAhMCwgby5jbGVhckNhY2hlKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCkpO1xuICAgIGNvbnN0IGkgPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMubGFzdFNlbGVjdGVkQmxvY2spICsgKGUgPyAxIDogLTEpLCBzID0gdC5ibG9ja3NbaV07XG4gICAgcyAmJiAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jay5zZWxlY3RlZCAhPT0gcy5zZWxlY3RlZCA/IChzLnNlbGVjdGVkID0gITAsIG8uY2xlYXJDYWNoZSgpKSA6ICh0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLnNlbGVjdGVkID0gITEsIG8uY2xlYXJDYWNoZSgpKSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHMsIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgcy5ob2xkZXIuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzYXZlZCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSByZWFzb24gLSBldmVudCBjYXVzZWQgY2xlYXIgb2Ygc2VsZWN0aW9uXG4gICAqL1xuICBjbGVhcihlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3IsIHMgPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSwgciA9IHQuYmxvY2tzLmluZGV4T2YodGhpcy5sYXN0U2VsZWN0ZWRCbG9jayk7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiBzID4gLTEgJiYgciA+IC0xICYmIGUgJiYgZSBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICBjYXNlIHkuRE9XTjpcbiAgICAgICAgY2FzZSB5LlJJR0hUOlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1heChzLCByKV0sIGkucG9zaXRpb25zLkVORCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgeS5VUDpcbiAgICAgICAgY2FzZSB5LkxFRlQ6XG4gICAgICAgICAgaS5zZXRUb0Jsb2NrKHQuYmxvY2tzW01hdGgubWluKHMsIHIpXSwgaS5wb3NpdGlvbnMuU1RBUlQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1heChzLCByKV0sIGkucG9zaXRpb25zLkVORCk7XG4gICAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBDcm9zcyBCbG9jayBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIGVuYWJsZUNyb3NzQmxvY2tTZWxlY3Rpb24oZSkge1xuICAgIGNvbnN0IHsgVUk6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGIuaXNDb2xsYXBzZWQgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSksIHQubm9kZXMucmVkYWN0b3IuY29udGFpbnMoZS50YXJnZXQpID8gdGhpcy53YXRjaFNlbGVjdGlvbihlKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgYmxvY2tzIHNlbGVjdGlvbiBzdGF0ZSBiZXR3ZWVuIHBhc3NlZCB0d28gYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBmaXJzdEJsb2NrIC0gZmlyc3QgYmxvY2sgaW4gcmFuZ2VcbiAgICogQHBhcmFtIHtCbG9ja30gbGFzdEJsb2NrIC0gbGFzdCBibG9jayBpbiByYW5nZVxuICAgKi9cbiAgdG9nZ2xlQmxvY2tzU2VsZWN0ZWRTdGF0ZShlLCB0KSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIEJsb2NrU2VsZWN0aW9uOiBpIH0gPSB0aGlzLkVkaXRvciwgcyA9IG8uYmxvY2tzLmluZGV4T2YoZSksIHIgPSBvLmJsb2Nrcy5pbmRleE9mKHQpLCBhID0gZS5zZWxlY3RlZCAhPT0gdC5zZWxlY3RlZDtcbiAgICBmb3IgKGxldCBsID0gTWF0aC5taW4ocywgcik7IGwgPD0gTWF0aC5tYXgocywgcik7IGwrKykge1xuICAgICAgY29uc3QgYyA9IG8uYmxvY2tzW2xdO1xuICAgICAgYyAhPT0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgJiYgYyAhPT0gKGEgPyBlIDogdCkgJiYgKG8uYmxvY2tzW2xdLnNlbGVjdGVkID0gIW8uYmxvY2tzW2xdLnNlbGVjdGVkLCBpLmNsZWFyQ2FjaGUoKSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBjYSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzU3RhcnRlZEF0RWRpdG9yID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogaWYgc3RhdGUgaXMgdHJ1ZTpcbiAgICogIC0gZGlzYWJsZSBhbGwgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogaWYgc3RhdGUgaXMgZmFsc2U6XG4gICAqICAtIHJlc3RvcmUgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBkcmFnIGV2ZW50cyBsaXN0ZW5lcnMgdG8gZWRpdG9yIHpvbmVcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIGNvbnN0IHsgVUk6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUubm9kZXMuaG9sZGVyLCBcImRyb3BcIiwgYXN5bmMgKHQpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0Ryb3AodCk7XG4gICAgfSwgITApLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcmFnc3RhcnRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzRHJhZ1N0YXJ0KCk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUubm9kZXMuaG9sZGVyLCBcImRyYWdvdmVyXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NEcmFnT3Zlcih0KTtcbiAgICB9LCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuYmluZCBkcmFnLW4tZHJvcCBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBkcm9wIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBkcm9wRXZlbnQgLSBkcm9wIGV2ZW50XG4gICAqL1xuICBhc3luYyBwcm9jZXNzRHJvcChlKSB7XG4gICAgY29uc3Qge1xuICAgICAgQmxvY2tNYW5hZ2VyOiB0LFxuICAgICAgUGFzdGU6IG8sXG4gICAgICBDYXJldDogaVxuICAgIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCksIHQuYmxvY2tzLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHIuZHJvcFRhcmdldCA9ICExO1xuICAgIH0pLCBiLmlzQXRFZGl0b3IgJiYgIWIuaXNDb2xsYXBzZWQgJiYgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciAmJiBkb2N1bWVudC5leGVjQ29tbWFuZChcImRlbGV0ZVwiKSwgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciA9ICExO1xuICAgIGNvbnN0IHMgPSB0LnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICBpZiAocylcbiAgICAgIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2socywgaS5wb3NpdGlvbnMuRU5EKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHIgPSB0LnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKHQubGFzdEJsb2NrLmhvbGRlcik7XG4gICAgICB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLkVORCk7XG4gICAgfVxuICAgIGF3YWl0IG8ucHJvY2Vzc0RhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2ZlciwgITApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0RyYWdTdGFydCgpIHtcbiAgICBiLmlzQXRFZGl0b3IgJiYgIWIuaXNDb2xsYXBzZWQgJiYgKHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgPSAhMCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGRyYWdFdmVudCAtIGRyYWcgZXZlbnRcbiAgICovXG4gIHByb2Nlc3NEcmFnT3ZlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5jb25zdCBkYSA9IDE4MCwgdWEgPSA0MDA7XG5jbGFzcyBoYSBleHRlbmRzIEUge1xuICAvKipcbiAgICogUHJlcGFyZSB0aGUgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyB1c2VkIGJ5IHRoZSBtb2RpZmljYXRpb24gb2JzZXJ2ZXIgbW9kdWxlXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIEVkaXRvciBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudHNEaXNwYXRjaGVyIC0gY29tbW9uIEVkaXRvciBldmVudCBidXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMuZGlzYWJsZWQgPSAhMSwgdGhpcy5iYXRjaGluZ1RpbWVvdXQgPSBudWxsLCB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuYmF0Y2hUaW1lID0gdWEsIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChvKSA9PiB7XG4gICAgICB0aGlzLnJlZGFjdG9yQ2hhbmdlZChvKTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKCRvLCAobykgPT4ge1xuICAgICAgdGhpcy5wYXJ0aWN1bGFyQmxvY2tDaGFuZ2VkKG8uZXZlbnQpO1xuICAgIH0pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oem8sICgpID0+IHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oVW8sICgpID0+IHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb25DaGFuZ2UgZXZlbnRcbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShcbiAgICAgIHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yLFxuICAgICAge1xuICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICBzdWJ0cmVlOiAhMCxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogITAsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICEwXG4gICAgICB9XG4gICAgKSwgdGhpcy5kaXNhYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBvbkNoYW5nZSBldmVudFxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCB0aGlzLmRpc2FibGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgb25DaGFuZ2UgZXZlbnQgcGFzc2VkIHRvIEVkaXRvci5qcyBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIHNvbWUgb2Ygb3VyIGN1c3RvbSBjaGFuZ2UgZXZlbnRzXG4gICAqL1xuICBwYXJ0aWN1bGFyQmxvY2tDaGFuZ2VkKGUpIHtcbiAgICB0aGlzLmRpc2FibGVkIHx8ICFBKHRoaXMuY29uZmlnLm9uQ2hhbmdlKSB8fCAodGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUuc2V0KGBibG9jazoke2UuZGV0YWlsLnRhcmdldC5pZH06ZXZlbnQ6JHtlLnR5cGV9YCwgZSksIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLmJhdGNoaW5nVGltZW91dCksIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgdDtcbiAgICAgIHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnNpemUgPT09IDEgPyB0ID0gdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUudmFsdWVzKCkubmV4dCgpLnZhbHVlIDogdCA9IEFycmF5LmZyb20odGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUudmFsdWVzKCkpLCB0aGlzLmNvbmZpZy5vbkNoYW5nZSAmJiB0aGlzLmNvbmZpZy5vbkNoYW5nZSh0aGlzLkVkaXRvci5BUEkubWV0aG9kcywgdCksIHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLmNsZWFyKCk7XG4gICAgfSwgdGhpcy5iYXRjaFRpbWUpKTtcbiAgfVxuICAvKipcbiAgICogRmlyZWQgb24gZXZlcnkgYmxvY2tzIHdyYXBwZXIgZG9tIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb25zIC0gbXV0YXRpb25zIGhhcHBlbmVkXG4gICAqL1xuICByZWRhY3RvckNoYW5nZWQoZSkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KGZ0LCB7XG4gICAgICBtdXRhdGlvbnM6IGVcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgUm4gPSBjbGFzcyBEbiBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLk1JTUVfVFlQRSA9IFwiYXBwbGljYXRpb24veC1lZGl0b3ItanNcIiwgdGhpcy50b29sc1RhZ3MgPSB7fSwgdGhpcy50YWdzQnlUb29sID0ge30sIHRoaXMudG9vbHNQYXR0ZXJucyA9IFtdLCB0aGlzLnRvb2xzRmlsZXMgPSB7fSwgdGhpcy5leGNlcHRpb25MaXN0ID0gW10sIHRoaXMucHJvY2Vzc1Rvb2wgPSAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdCA9IGUuY3JlYXRlKHt9LCB7fSwgITEpO1xuICAgICAgICBpZiAoZS5wYXN0ZUNvbmZpZyA9PT0gITEpIHtcbiAgICAgICAgICB0aGlzLmV4Y2VwdGlvbkxpc3QucHVzaChlLm5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUEodC5vblBhc3RlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZ2V0VGFnc0NvbmZpZyhlKSwgdGhpcy5nZXRGaWxlc0NvbmZpZyhlKSwgdGhpcy5nZXRQYXR0ZXJuc0NvbmZpZyhlKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgUyhcbiAgICAgICAgICBgUGFzdGUgaGFuZGxpbmcgZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBoYXNuJ3QgYmVlbiBzZXQgdXAgYmVjYXVzZSBvZiB0aGUgZXJyb3JgLFxuICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgIHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmhhbmRsZVBhc3RlRXZlbnQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFRvb2xiYXI6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gdC5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgICAhaSB8fCB0aGlzLmlzTmF0aXZlQmVoYXZpb3VyKGUudGFyZ2V0KSAmJiAhZS5jbGlwYm9hcmREYXRhLnR5cGVzLmluY2x1ZGVzKFwiRmlsZXNcIikgfHwgaSAmJiB0aGlzLmV4Y2VwdGlvbkxpc3QuaW5jbHVkZXMoaS5uYW1lKSB8fCAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnByb2Nlc3NEYXRhVHJhbnNmZXIoZS5jbGlwYm9hcmREYXRhKSwgby5jbG9zZSgpKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb25QYXN0ZSBjYWxsYmFjayBhbmQgY29sbGVjdCB0b29sc2AgcGFzdGUgY29uZmlndXJhdGlvbnNcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgdGhpcy5wcm9jZXNzVG9vbHMoKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHJlYWQtb25seSBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIHJlYWQgb25seSBmbGFnIHZhbHVlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMudW5zZXRDYWxsYmFjaygpIDogdGhpcy5zZXRDYWxsYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgcGFzdGVkIG9yIGRyb3BwZWQgZGF0YSB0cmFuc2ZlciBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtEYXRhVHJhbnNmZXJ9IGRhdGFUcmFuc2ZlciAtIHBhc3RlZCBvciBkcm9wcGVkIGRhdGEgdHJhbnNmZXIgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEcmFnTkRyb3AgLSB0cnVlIGlmIGRhdGEgdHJhbnNmZXIgY29tZXMgZnJvbSBkcmFnJ24nZHJvcCBldmVudHNcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NEYXRhVHJhbnNmZXIoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBUb29sczogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSBlLnR5cGVzO1xuICAgIGlmICgoaS5pbmNsdWRlcyA/IGkuaW5jbHVkZXMoXCJGaWxlc1wiKSA6IGkuY29udGFpbnMoXCJGaWxlc1wiKSkgJiYgIVYodGhpcy50b29sc0ZpbGVzKSkge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZXMoZS5maWxlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSBlLmdldERhdGEodGhpcy5NSU1FX1RZUEUpLCBhID0gZS5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICBsZXQgbCA9IGUuZ2V0RGF0YShcInRleHQvaHRtbFwiKTtcbiAgICBpZiAocilcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0RWRpdG9ySlNEYXRhKEpTT04ucGFyc2UocikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB0ICYmIGEudHJpbSgpICYmIGwudHJpbSgpICYmIChsID0gXCI8cD5cIiArIChsLnRyaW0oKSA/IGwgOiBhKSArIFwiPC9wPlwiKTtcbiAgICBjb25zdCBjID0gT2JqZWN0LmtleXModGhpcy50b29sc1RhZ3MpLnJlZHVjZSgocCwgZykgPT4gKHBbZy50b0xvd2VyQ2FzZSgpXSA9IHRoaXMudG9vbHNUYWdzW2ddLnNhbml0aXphdGlvbkNvbmZpZyA/PyB7fSwgcCksIHt9KSwgdSA9IE9iamVjdC5hc3NpZ24oe30sIGMsIG8uZ2V0QWxsSW5saW5lVG9vbHNTYW5pdGl6ZUNvbmZpZygpLCB7IGJyOiB7fSB9KSwgaCA9IFoobCwgdSk7XG4gICAgIWgudHJpbSgpIHx8IGgudHJpbSgpID09PSBhIHx8ICFkLmlzSFRNTFN0cmluZyhoKSA/IGF3YWl0IHRoaXMucHJvY2Vzc1RleHQoYSkgOiBhd2FpdCB0aGlzLnByb2Nlc3NUZXh0KGgsICEwKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZWQgdGV4dCBhbmQgZGl2aWRlIHRoZW0gaW50byBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSB0ZXh0IHRvIHByb2Nlc3MuIENhbiBiZSBIVE1MIG9yIHBsYWluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSFRNTCAtIGlmIHBhc3NlZCBzdHJpbmcgaXMgSFRNTCwgdGhpcyBwYXJhbWV0ZXIgc2hvdWxkIGJlIHRydWVcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NUZXh0KGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IHsgQ2FyZXQ6IG8sIEJsb2NrTWFuYWdlcjogaSB9ID0gdGhpcy5FZGl0b3IsIHMgPSB0ID8gdGhpcy5wcm9jZXNzSFRNTChlKSA6IHRoaXMucHJvY2Vzc1BsYWluKGUpO1xuICAgIGlmICghcy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzWzBdLmlzQmxvY2sgPyB0aGlzLnByb2Nlc3NTaW5nbGVCbG9jayhzLnBvcCgpKSA6IHRoaXMucHJvY2Vzc0lubGluZVBhc3RlKHMucG9wKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhID0gaS5jdXJyZW50QmxvY2sgJiYgaS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgaS5jdXJyZW50QmxvY2suaXNFbXB0eTtcbiAgICBzLm1hcChcbiAgICAgIGFzeW5jIChsLCBjKSA9PiB0aGlzLmluc2VydEJsb2NrKGwsIGMgPT09IDAgJiYgYSlcbiAgICApLCBpLmN1cnJlbnRCbG9jayAmJiBvLnNldFRvQmxvY2soaS5jdXJyZW50QmxvY2ssIG8ucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvblBhc3RlIGNhbGxiYWNrIGhhbmRsZXJcbiAgICovXG4gIHNldENhbGxiYWNrKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMuRWRpdG9yLlVJLm5vZGVzLmhvbGRlciwgXCJwYXN0ZVwiLCB0aGlzLmhhbmRsZVBhc3RlRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNldCBvblBhc3RlIGNhbGxiYWNrIGhhbmRsZXJcbiAgICovXG4gIHVuc2V0Q2FsbGJhY2soKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMub2ZmKHRoaXMuRWRpdG9yLlVJLm5vZGVzLmhvbGRlciwgXCJwYXN0ZVwiLCB0aGlzLmhhbmRsZVBhc3RlRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYW5kIHByb2Nlc3MgdG9vbGBzIHBhc3RlIGNvbmZpZ3NcbiAgICovXG4gIHByb2Nlc3NUb29scygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5FZGl0b3IuVG9vbHMuYmxvY2tUb29scztcbiAgICBBcnJheS5mcm9tKGUudmFsdWVzKCkpLmZvckVhY2godGhpcy5wcm9jZXNzVG9vbCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWdzIG5hbWUgbGlzdCBmcm9tIGVpdGhlciB0YWcgbmFtZSBvciBzYW5pdGl6YXRpb24gY29uZmlnLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gdGFnT3JTYW5pdGl6ZUNvbmZpZyAtIHRhZyBuYW1lIG9yIHNhbml0aXplIGNvbmZpZyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gYXJyYXkgb2YgdGFncy5cbiAgICovXG4gIGNvbGxlY3RUYWdOYW1lcyhlKSB7XG4gICAgcmV0dXJuIHRlKGUpID8gW2VdIDogRChlKSA/IE9iamVjdC5rZXlzKGUpIDogW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWdzIHRvIHN1YnN0aXR1dGUgYnkgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrVG9vbCBvYmplY3RcbiAgICovXG4gIGdldFRhZ3NDb25maWcoZSkge1xuICAgIGlmIChlLnBhc3RlQ29uZmlnID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS5wYXN0ZUNvbmZpZy50YWdzIHx8IFtdLCBvID0gW107XG4gICAgdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5jb2xsZWN0VGFnTmFtZXMoaSk7XG4gICAgICBvLnB1c2goLi4ucyksIHMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudG9vbHNUYWdzLCByKSkge1xuICAgICAgICAgIFMoXG4gICAgICAgICAgICBgUGFzdGUgaGFuZGxlciBmb3Igwqske2UubmFtZX3CuyBUb29sIG9uIMKrJHtyfcK7IHRhZyBpcyBza2lwcGVkIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSB1c2VkIGJ5IMKrJHt0aGlzLnRvb2xzVGFnc1tyXS50b29sLm5hbWV9wrsgVG9vbC5gLFxuICAgICAgICAgICAgXCJ3YXJuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhID0gRChpKSA/IGlbcl0gOiBudWxsO1xuICAgICAgICB0aGlzLnRvb2xzVGFnc1tyLnRvVXBwZXJDYXNlKCldID0ge1xuICAgICAgICAgIHRvb2w6IGUsXG4gICAgICAgICAgc2FuaXRpemF0aW9uQ29uZmlnOiBhXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy50YWdzQnlUb29sW2UubmFtZV0gPSBvLm1hcCgoaSkgPT4gaS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzYCB0eXBlcyBhbmQgZXh0ZW5zaW9ucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRGaWxlc0NvbmZpZyhlKSB7XG4gICAgaWYgKGUucGFzdGVDb25maWcgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZmlsZXM6IHQgPSB7fSB9ID0gZS5wYXN0ZUNvbmZpZztcbiAgICBsZXQgeyBleHRlbnNpb25zOiBvLCBtaW1lVHlwZXM6IGkgfSA9IHQ7XG4gICAgIW8gJiYgIWkgfHwgKG8gJiYgIUFycmF5LmlzQXJyYXkobykgJiYgKFMoYMKrZXh0ZW5zaW9uc8K7IHByb3BlcnR5IG9mIHRoZSBvbkRyb3AgY29uZmlnIGZvciDCqyR7ZS5uYW1lfcK7IFRvb2wgc2hvdWxkIGJlIGFuIGFycmF5YCksIG8gPSBbXSksIGkgJiYgIUFycmF5LmlzQXJyYXkoaSkgJiYgKFMoYMKrbWltZVR5cGVzwrsgcHJvcGVydHkgb2YgdGhlIG9uRHJvcCBjb25maWcgZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBzaG91bGQgYmUgYW4gYXJyYXlgKSwgaSA9IFtdKSwgaSAmJiAoaSA9IGkuZmlsdGVyKChzKSA9PiBlaShzKSA/ICEwIDogKFMoYE1JTUUgdHlwZSB2YWx1ZSDCqyR7c33CuyBmb3IgdGhlIMKrJHtlLm5hbWV9wrsgVG9vbCBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGVgLCBcIndhcm5cIiksICExKSkpLCB0aGlzLnRvb2xzRmlsZXNbZS5uYW1lXSA9IHtcbiAgICAgIGV4dGVuc2lvbnM6IG8gfHwgW10sXG4gICAgICBtaW1lVHlwZXM6IGkgfHwgW11cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IFJlZ0V4cCBwYXR0ZXJucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRQYXR0ZXJuc0NvbmZpZyhlKSB7XG4gICAgZS5wYXN0ZUNvbmZpZyA9PT0gITEgfHwgIWUucGFzdGVDb25maWcucGF0dGVybnMgfHwgVihlLnBhc3RlQ29uZmlnLnBhdHRlcm5zKSB8fCBPYmplY3QuZW50cmllcyhlLnBhc3RlQ29uZmlnLnBhdHRlcm5zKS5mb3JFYWNoKChbdCwgb10pID0+IHtcbiAgICAgIG8gaW5zdGFuY2VvZiBSZWdFeHAgfHwgUyhcbiAgICAgICAgYFBhdHRlcm4gJHtvfSBmb3Igwqske2UubmFtZX3CuyBUb29sIGlzIHNraXBwZWQgYmVjYXVzZSBpdCBzaG91bGQgYmUgYSBSZWdleHAgaW5zdGFuY2UuYCxcbiAgICAgICAgXCJ3YXJuXCJcbiAgICAgICksIHRoaXMudG9vbHNQYXR0ZXJucy5wdXNoKHtcbiAgICAgICAga2V5OiB0LFxuICAgICAgICBwYXR0ZXJuOiBvLFxuICAgICAgICB0b29sOiBlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBiZWhhdmlvciBzdWl0cyBiZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY29udGVudCBoYXMgYmVlbiBwYXN0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc05hdGl2ZUJlaGF2aW91cihlKSB7XG4gICAgcmV0dXJuIGQuaXNOYXRpdmVJbnB1dChlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzIGZyb20gZGF0YSB0cmFuc2ZlciBvYmplY3QgYW5kIGluc2VydCByZWxhdGVkIFRvb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZUxpc3R9IGl0ZW1zIC0gcGFzdGVkIG9yIGRyb3BwZWQgaXRlbXNcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlcyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBvO1xuICAgIG8gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20oZSkubWFwKChyKSA9PiB0aGlzLnByb2Nlc3NGaWxlKHIpKVxuICAgICksIG8gPSBvLmZpbHRlcigocikgPT4gISFyKTtcbiAgICBjb25zdCBzID0gdC5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgdC5jdXJyZW50QmxvY2suaXNFbXB0eTtcbiAgICBvLmZvckVhY2goXG4gICAgICAociwgYSkgPT4ge1xuICAgICAgICB0LnBhc3RlKHIudHlwZSwgci5ldmVudCwgYSA9PT0gMCAmJiBzKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgZmlsZSBhbmQgZmluZCBUb29sIHRvIGhhbmRsZSBpdFxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBmaWxlIHRvIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlKGUpIHtcbiAgICBjb25zdCB0ID0gSm4oZSksIG8gPSBPYmplY3QuZW50cmllcyh0aGlzLnRvb2xzRmlsZXMpLmZpbmQoKFtyLCB7IG1pbWVUeXBlczogYSwgZXh0ZW5zaW9uczogbCB9XSkgPT4ge1xuICAgICAgY29uc3QgW2MsIHVdID0gZS50eXBlLnNwbGl0KFwiL1wiKSwgaCA9IGwuZmluZCgoZykgPT4gZy50b0xvd2VyQ2FzZSgpID09PSB0LnRvTG93ZXJDYXNlKCkpLCBwID0gYS5maW5kKChnKSA9PiB7XG4gICAgICAgIGNvbnN0IFtmLCB2XSA9IGcuc3BsaXQoXCIvXCIpO1xuICAgICAgICByZXR1cm4gZiA9PT0gYyAmJiAodiA9PT0gdSB8fCB2ID09PSBcIipcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIWggfHwgISFwO1xuICAgIH0pO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbaV0gPSBvO1xuICAgIHJldHVybiB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcImZpbGVcIiwge1xuICAgICAgICBmaWxlOiBlXG4gICAgICB9KSxcbiAgICAgIHR5cGU6IGlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBIVE1MIHN0cmluZyB0byBibG9ja3MgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbm5lckhUTUwgLSBodG1sIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NIVE1MKGUpIHtcbiAgICBjb25zdCB7IFRvb2xzOiB0IH0gPSB0aGlzLkVkaXRvciwgbyA9IGQubWFrZShcIkRJVlwiKTtcbiAgICByZXR1cm4gby5pbm5lckhUTUwgPSBlLCB0aGlzLmdldE5vZGVzKG8pLm1hcCgocykgPT4ge1xuICAgICAgbGV0IHIsIGEgPSB0LmRlZmF1bHRUb29sLCBsID0gITE7XG4gICAgICBzd2l0Y2ggKHMubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgciA9IGQubWFrZShcImRpdlwiKSwgci5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICByID0gcywgbCA9ICEwLCB0aGlzLnRvb2xzVGFnc1tyLnRhZ05hbWVdICYmIChhID0gdGhpcy50b29sc1RhZ3Nbci50YWdOYW1lXS50b29sKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGFnczogYyB9ID0gYS5wYXN0ZUNvbmZpZyB8fCB7IHRhZ3M6IFtdIH0sIHUgPSBjLnJlZHVjZSgoZywgZikgPT4gKHRoaXMuY29sbGVjdFRhZ05hbWVzKGYpLmZvckVhY2goKE8pID0+IHtcbiAgICAgICAgY29uc3QgVCA9IEQoZikgPyBmW09dIDogbnVsbDtcbiAgICAgICAgZ1tPLnRvTG93ZXJDYXNlKCldID0gVCB8fCB7fTtcbiAgICAgIH0pLCBnKSwge30pLCBoID0gT2JqZWN0LmFzc2lnbih7fSwgdSwgYS5iYXNlU2FuaXRpemVDb25maWcpO1xuICAgICAgaWYgKHIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgY29uc3QgZyA9IFooci5vdXRlckhUTUwsIGgpO1xuICAgICAgICByID0gZC5tYWtlKFwiZGl2XCIsIHZvaWQgMCwge1xuICAgICAgICAgIGlubmVySFRNTDogZ1xuICAgICAgICB9KS5maXJzdENoaWxkO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHIuaW5uZXJIVE1MID0gWihyLmlubmVySFRNTCwgaCk7XG4gICAgICBjb25zdCBwID0gdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInRhZ1wiLCB7XG4gICAgICAgIGRhdGE6IHJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogcixcbiAgICAgICAgaXNCbG9jazogbCxcbiAgICAgICAgdG9vbDogYS5uYW1lLFxuICAgICAgICBldmVudDogcFxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoKHMpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBkLmlzRW1wdHkocy5jb250ZW50KSwgYSA9IGQuaXNTaW5nbGVUYWcocy5jb250ZW50KTtcbiAgICAgIHJldHVybiAhciB8fCBhO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBwbGFpbiB0ZXh0IGJ5IG5ldyBsaW5lIHN5bWJvbHMgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFpbiAtIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NQbGFpbihlKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QmxvY2s6IHQgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBvID0gdDtcbiAgICByZXR1cm4gZS5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcigoaSkgPT4gaS50cmltKCkpLm1hcCgoaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IGQubWFrZShcImRpdlwiKTtcbiAgICAgIHMudGV4dENvbnRlbnQgPSBpO1xuICAgICAgY29uc3QgciA9IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJ0YWdcIiwge1xuICAgICAgICBkYXRhOiBzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHMsXG4gICAgICAgIHRvb2w6IG8sXG4gICAgICAgIGlzQmxvY2s6ICExLFxuICAgICAgICBldmVudDogclxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSBvZiBzaW5nbGUgQmxvY2sgdG9vbCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVEYXRhfSBkYXRhVG9JbnNlcnQgLSBkYXRhIG9mIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1NpbmdsZUJsb2NrKGUpIHtcbiAgICBjb25zdCB7IENhcmV0OiB0LCBCbG9ja01hbmFnZXI6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogaSB9ID0gbztcbiAgICBpZiAoIWkgfHwgZS50b29sICE9PSBpLm5hbWUgfHwgIWQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMoZS5jb250ZW50LmlubmVySFRNTCkpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QmxvY2soZSwgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudG9vbC5pc0RlZmF1bHQpICYmIGkuaXNFbXB0eSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihlLmNvbnRlbnQuaW5uZXJIVE1MKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSB0byBzaW5nbGUgQmxvY2s6XG4gICAqIDEuIEZpbmQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICogMi4gSW5zZXJ0IG5ldyBibG9jayBpZiBpdCBpcyBub3QgdGhlIHNhbWUgdHlwZSBhcyBjdXJyZW50IG9uZVxuICAgKiAzLiBKdXN0IGluc2VydCB0ZXh0IGlmIHRoZXJlIGlzIG5vIHN1YnN0aXR1dGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZURhdGF9IGRhdGFUb0luc2VydCAtIGRhdGEgb2YgQmxvY2sgdG8gaW5zZXJ0XG4gICAqL1xuICBhc3luYyBwcm9jZXNzSW5saW5lUGFzdGUoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIHsgY29udGVudDogaSB9ID0gZTtcbiAgICBpZiAodC5jdXJyZW50QmxvY2sgJiYgdC5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgaS50ZXh0Q29udGVudC5sZW5ndGggPCBEbi5QQVRURVJOX1BST0NFU1NJTkdfTUFYX0xFTkdUSCkge1xuICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhdHRlcm4oaS50ZXh0Q29udGVudCk7XG4gICAgICBpZiAocikge1xuICAgICAgICBjb25zdCBhID0gdC5jdXJyZW50QmxvY2sgJiYgdC5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgdC5jdXJyZW50QmxvY2suaXNFbXB0eSwgbCA9IHQucGFzdGUoci50b29sLCByLmV2ZW50LCBhKTtcbiAgICAgICAgby5zZXRUb0Jsb2NrKGwsIG8ucG9zaXRpb25zLkVORCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dCkge1xuICAgICAgY29uc3QgciA9IHQuY3VycmVudEJsb2NrLnRvb2wuYmFzZVNhbml0aXplQ29uZmlnO1xuICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXG4gICAgICAgIFwiaW5zZXJ0SFRNTFwiLFxuICAgICAgICAhMSxcbiAgICAgICAgWihpLmlubmVySFRNTCwgcilcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmluc2VydEJsb2NrKGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHByb2Nlc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8e2V2ZW50OiBQYXN0ZUV2ZW50LCB0b29sOiBzdHJpbmd9Pn1cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NQYXR0ZXJuKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50b29sc1BhdHRlcm5zLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBpLnBhdHRlcm4uZXhlYyhlKTtcbiAgICAgIHJldHVybiBzID8gZSA9PT0gcy5zaGlmdCgpIDogITE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHQgPyB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICBkYXRhOiBlXG4gICAgICB9KSxcbiAgICAgIHRvb2w6IHQudG9vbC5uYW1lXG4gICAgfSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHBhc3RlZCBCbG9jayBjb250ZW50IHRvIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRGF0YX0gZGF0YSAtIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuUmVwbGFjZUN1cnJlbnRCbG9jayAtIGlmIHRydWUgYW5kIGlzIGN1cnJlbnQgQmxvY2sgaXMgZW1wdHksIHdpbGwgcmVwbGFjZSBjdXJyZW50IEJsb2NrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaW5zZXJ0QmxvY2soZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IHMgfSA9IG87XG4gICAgbGV0IHI7XG4gICAgaWYgKHQgJiYgcyAmJiBzLmlzRW1wdHkpIHtcbiAgICAgIHIgPSBvLnBhc3RlKGUudG9vbCwgZS5ldmVudCwgITApLCBpLnNldFRvQmxvY2sociwgaS5wb3NpdGlvbnMuRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgciA9IG8ucGFzdGUoZS50b29sLCBlLmV2ZW50KSwgaS5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBkYXRhIHBhc3NlZCBhcyBhcHBsaWNhdGlvbi94LWVkaXRvci1qcyBKU09OXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrcyDigJQgQmxvY2tzJyBkYXRhIHRvIGluc2VydFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGluc2VydEVkaXRvckpTRGF0YShlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvLCBUb29sczogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgeXQoXG4gICAgICBlLFxuICAgICAgKHIpID0+IGkuYmxvY2tUb29scy5nZXQocikuc2FuaXRpemVDb25maWdcbiAgICApLmZvckVhY2goKHsgdG9vbDogciwgZGF0YTogYSB9LCBsKSA9PiB7XG4gICAgICBsZXQgYyA9ICExO1xuICAgICAgbCA9PT0gMCAmJiAoYyA9IHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIHQuY3VycmVudEJsb2NrLmlzRW1wdHkpO1xuICAgICAgY29uc3QgdSA9IHQuaW5zZXJ0KHtcbiAgICAgICAgdG9vbDogcixcbiAgICAgICAgZGF0YTogYSxcbiAgICAgICAgcmVwbGFjZTogY1xuICAgICAgfSk7XG4gICAgICBvLnNldFRvQmxvY2sodSwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbm9kZXMgZnJvbSBFbGVtZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gY3VycmVudCBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyAtIHByb2Nlc3NlZCBub2Rlc1xuICAgKiBAcGFyYW0ge05vZGV9IGRlc3ROb2RlIC0gZGVzdGluYXRpb24gbm9kZVxuICAgKi9cbiAgcHJvY2Vzc0VsZW1lbnROb2RlKGUsIHQsIG8pIHtcbiAgICBjb25zdCBpID0gT2JqZWN0LmtleXModGhpcy50b29sc1RhZ3MpLCBzID0gZSwgeyB0b29sOiByIH0gPSB0aGlzLnRvb2xzVGFnc1tzLnRhZ05hbWVdIHx8IHt9LCBhID0gdGhpcy50YWdzQnlUb29sW3IgPT0gbnVsbCA/IHZvaWQgMCA6IHIubmFtZV0gfHwgW10sIGwgPSBpLmluY2x1ZGVzKHMudGFnTmFtZSksIGMgPSBkLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMocy50YWdOYW1lLnRvTG93ZXJDYXNlKCkpLCB1ID0gQXJyYXkuZnJvbShzLmNoaWxkcmVuKS5zb21lKFxuICAgICAgKHsgdGFnTmFtZTogcCB9KSA9PiBpLmluY2x1ZGVzKHApICYmICFhLmluY2x1ZGVzKHApXG4gICAgKSwgaCA9IEFycmF5LmZyb20ocy5jaGlsZHJlbikuc29tZShcbiAgICAgICh7IHRhZ05hbWU6IHAgfSkgPT4gZC5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKHAudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICAgIGlmICghYyAmJiAhbCAmJiAhdSlcbiAgICAgIHJldHVybiBvLmFwcGVuZENoaWxkKHMpLCBbLi4udCwgb107XG4gICAgaWYgKGwgJiYgIXUgfHwgYyAmJiAhaCAmJiAhdSlcbiAgICAgIHJldHVybiBbLi4udCwgbywgc107XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGRpdmlkZSBIVE1MIHN0cmluZyB0byB0d28gdHlwZXMgb2Ygbm9kZXM6XG4gICAqIDEuIEJsb2NrIGVsZW1lbnRcbiAgICogMi4gRG9jdW1lbnQgRnJhZ21lbnRzIGNvbnRhaW5lZCB0ZXh0IGFuZCBtYXJrdXAgdGFncyBsaWtlIGEsIGIsIGkgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHdyYXBwZXIgLSB3cmFwcGVyIG9mIHBhc3RlciBIVE1MIGNvbnRlbnRcbiAgICogQHJldHVybnMge05vZGVbXX1cbiAgICovXG4gIGdldE5vZGVzKGUpIHtcbiAgICBjb25zdCB0ID0gQXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpO1xuICAgIGxldCBvO1xuICAgIGNvbnN0IGkgPSAocywgcikgPT4ge1xuICAgICAgaWYgKGQuaXNFbXB0eShyKSAmJiAhZC5pc1NpbmdsZVRhZyhyKSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICBjb25zdCBhID0gc1tzLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IGwgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgc3dpdGNoIChhICYmIGQuaXNGcmFnbWVudChhKSAmJiAobCA9IHMucG9wKCkpLCByLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgaWYgKG8gPSB0aGlzLnByb2Nlc3NFbGVtZW50Tm9kZShyLCBzLCBsKSwgbylcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgIHJldHVybiBsLmFwcGVuZENoaWxkKHIpLCBbLi4ucywgbF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFsuLi5zLCBsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLi4ucywgLi4uQXJyYXkuZnJvbShyLmNoaWxkTm9kZXMpLnJlZHVjZShpLCBbXSldO1xuICAgIH07XG4gICAgcmV0dXJuIHQucmVkdWNlKGksIFtdKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9zZSBwYXN0ZSBldmVudCB3aXRoIHBhc3NlZCB0eXBlIGFuZCBkZXRhaWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudERldGFpbH0gZGV0YWlsIC0gZXZlbnQgZGV0YWlsXG4gICAqL1xuICBjb21wb3NlUGFzdGVFdmVudChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChlLCB7XG4gICAgICBkZXRhaWw6IHRcbiAgICB9KTtcbiAgfVxufTtcblJuLlBBVFRFUk5fUFJPQ0VTU0lOR19NQVhfTEVOR1RIID0gNDUwO1xubGV0IHBhID0gUm47XG5jbGFzcyBmYSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seSA9IFtdLCB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXRlIG9mIHJlYWQgb25seSBtb2RlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogU2V0IGluaXRpYWwgc3RhdGVcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgY29uc3QgeyBUb29sczogZSB9ID0gdGhpcy5FZGl0b3IsIHsgYmxvY2tUb29sczogdCB9ID0gZSwgbyA9IFtdO1xuICAgIEFycmF5LmZyb20odC5lbnRyaWVzKCkpLmZvckVhY2goKFtpLCBzXSkgPT4ge1xuICAgICAgcy5pc1JlYWRPbmx5U3VwcG9ydGVkIHx8IG8ucHVzaChpKTtcbiAgICB9KSwgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkgPSBvLCB0aGlzLmNvbmZpZy5yZWFkT25seSAmJiBvLmxlbmd0aCA+IDAgJiYgdGhpcy50aHJvd0NyaXRpY2FsRXJyb3IoKSwgdGhpcy50b2dnbGUodGhpcy5jb25maWcucmVhZE9ubHksICEwKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHJlYWQtb25seSBtb2RlIG9yIHRvZ2dsZSBjdXJyZW50IHN0YXRlXG4gICAqIENhbGwgYWxsIE1vZHVsZXMgYHRvZ2dsZVJlYWRPbmx5YCBtZXRob2QgYW5kIHJlLXJlbmRlciBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIC0gKG9wdGlvbmFsKSByZWFkLW9ubHkgc3RhdGUgb3IgdG9nZ2xlXG4gICAqIEBwYXJhbSBpc0luaXRpYWwgLSAob3B0aW9uYWwpIHRydWUgd2hlbiBlZGl0b3IgaXMgaW5pdGlhbGl6aW5nXG4gICAqL1xuICBhc3luYyB0b2dnbGUoZSA9ICF0aGlzLnJlYWRPbmx5RW5hYmxlZCwgdCA9ICExKSB7XG4gICAgZSAmJiB0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seS5sZW5ndGggPiAwICYmIHRoaXMudGhyb3dDcml0aWNhbEVycm9yKCk7XG4gICAgY29uc3QgbyA9IHRoaXMucmVhZE9ubHlFbmFibGVkO1xuICAgIHRoaXMucmVhZE9ubHlFbmFibGVkID0gZTtcbiAgICBmb3IgKGNvbnN0IHMgaW4gdGhpcy5FZGl0b3IpXG4gICAgICB0aGlzLkVkaXRvcltzXS50b2dnbGVSZWFkT25seSAmJiB0aGlzLkVkaXRvcltzXS50b2dnbGVSZWFkT25seShlKTtcbiAgICBpZiAobyA9PT0gZSlcbiAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgICBpZiAodClcbiAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgICB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZGlzYWJsZSgpO1xuICAgIGNvbnN0IGkgPSBhd2FpdCB0aGlzLkVkaXRvci5TYXZlci5zYXZlKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcigpLCBhd2FpdCB0aGlzLkVkaXRvci5SZW5kZXJlci5yZW5kZXIoaS5ibG9ja3MpLCB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZW5hYmxlKCksIHRoaXMucmVhZE9ubHlFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgYWJvdXQgdG9vbHMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdGhyb3dDcml0aWNhbEVycm9yKCkge1xuICAgIHRocm93IG5ldyBIbyhcbiAgICAgIGBUbyBlbmFibGUgcmVhZC1vbmx5IG1vZGUgYWxsIGNvbm5lY3RlZCB0b29scyBzaG91bGQgc3VwcG9ydCBpdC4gVG9vbHMgJHt0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seS5qb2luKFwiLCBcIil9IGRvbid0IHN1cHBvcnQgcmVhZC1vbmx5IG1vZGUuYFxuICAgICk7XG4gIH1cbn1cbmNsYXNzIEJlIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITEsIHRoaXMuU0NST0xMX1NQRUVEID0gMywgdGhpcy5IRUlHSFRfT0ZfU0NST0xMX1pPTkUgPSA0MCwgdGhpcy5CT1RUT01fU0NST0xMX1pPTkUgPSAxLCB0aGlzLlRPUF9TQ1JPTExfWk9ORSA9IDIsIHRoaXMuTUFJTl9NT1VTRV9CVVRUT04gPSAwLCB0aGlzLm1vdXNlZG93biA9ICExLCB0aGlzLmlzU2Nyb2xsaW5nID0gITEsIHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgdGhpcy5zdGFydFggPSAwLCB0aGlzLnN0YXJ0WSA9IDAsIHRoaXMubW91c2VYID0gMCwgdGhpcy5tb3VzZVkgPSAwLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZCA9IFtdLCB0aGlzLmxpc3RlbmVySWRzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIENTUyBjbGFzc2VzIGZvciB0aGUgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge3t3cmFwcGVyOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmxheTogXCJjb2RleC1lZGl0b3Itb3ZlcmxheVwiLFxuICAgICAgb3ZlcmxheUNvbnRhaW5lcjogXCJjb2RleC1lZGl0b3Itb3ZlcmxheV9fY29udGFpbmVyXCIsXG4gICAgICByZWN0OiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19yZWN0YW5nbGVcIixcbiAgICAgIHRvcFNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS10b3BcIixcbiAgICAgIGJvdHRvbVNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS1ib3R0b21cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBDcmVhdGluZyByZWN0IGFuZCBoYW5nIGhhbmRsZXJzXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogSW5pdCByZWN0IHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVggLSBYIGNvb3JkIG9mIG1vdXNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWSAtIFkgY29vcmQgb2YgbW91c2VcbiAgICovXG4gIHN0YXJ0U2VsZWN0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICBvLmNsb3Nlc3QoYC4ke3RoaXMuRWRpdG9yLlRvb2xiYXIuQ1NTLnRvb2xiYXJ9YCkgfHwgKHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFsbEJsb2Nrc1NlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQgPSBbXSk7XG4gICAgY29uc3QgcyA9IFtcbiAgICAgIGAuJHtSLkNTUy5jb250ZW50fWAsXG4gICAgICBgLiR7dGhpcy5FZGl0b3IuVG9vbGJhci5DU1MudG9vbGJhcn1gLFxuICAgICAgYC4ke3RoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuQ1NTLmlubGluZVRvb2xiYXJ9YFxuICAgIF0sIHIgPSBvLmNsb3Nlc3QoXCIuXCIgKyB0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlciksIGEgPSBzLnNvbWUoKGwpID0+ICEhby5jbG9zZXN0KGwpKTtcbiAgICAhciB8fCBhIHx8ICh0aGlzLm1vdXNlZG93biA9ICEwLCB0aGlzLnN0YXJ0WCA9IGUsIHRoaXMuc3RhcnRZID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwYXJhbXMgdG8gZW5kIHNlbGVjdGlvblxuICAgKi9cbiAgZW5kU2VsZWN0aW9uKCkge1xuICAgIHRoaXMubW91c2Vkb3duID0gITEsIHRoaXMuc3RhcnRYID0gMCwgdGhpcy5zdGFydFkgPSAwLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG4gIC8qKlxuICAgKiBpcyBSZWN0U2VsZWN0aW9uIEFjdGl2YXRlZFxuICAgKi9cbiAgaXNSZWN0QWN0aXZhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZDtcbiAgfVxuICAvKipcbiAgICogTWFyayB0aGF0IHNlbGVjdGlvbiBpcyBlbmRcbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgTW9kdWxlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGUgfSA9IHRoaXMuZ2VuSFRNTCgpO1xuICAgIHRoaXMubGlzdGVuZXJzLm9uKGUsIFwibW91c2Vkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZURvd24odCk7XG4gICAgfSwgITEpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiLCBkdCgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlTGVhdmUoKTtcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24od2luZG93LCBcInNjcm9sbFwiLCBkdCgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzU2Nyb2xsKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlVXAoKTtcbiAgICB9LCAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIGV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzTW91c2VEb3duKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IHRoaXMuTUFJTl9NT1VTRV9CVVRUT04pXG4gICAgICByZXR1cm47XG4gICAgZS50YXJnZXQuY2xvc2VzdChkLmFsbElucHV0c1NlbGVjdG9yKSAhPT0gbnVsbCB8fCB0aGlzLnN0YXJ0U2VsZWN0aW9uKGUucGFnZVgsIGUucGFnZVkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5jaGFuZ2luZ1JlY3RhbmdsZShlKSwgdGhpcy5zY3JvbGxCeVpvbmVzKGUuY2xpZW50WSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBsZWF2ZVxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpLCB0aGlzLmVuZFNlbGVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzU2Nyb2xsKGUpIHtcbiAgICB0aGlzLmNoYW5naW5nUmVjdGFuZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXBcbiAgICovXG4gIHByb2Nlc3NNb3VzZVVwKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5lbmRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIElmIG1vdXNlIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIC0gWSBjb29yZCBvZiBtb3VzZVxuICAgKi9cbiAgc2Nyb2xsQnlab25lcyhlKSB7XG4gICAgaWYgKHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgZSA8PSB0aGlzLkhFSUdIVF9PRl9TQ1JPTExfWk9ORSAmJiAodGhpcy5pblNjcm9sbFpvbmUgPSB0aGlzLlRPUF9TQ1JPTExfWk9ORSksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSBlIDw9IHRoaXMuSEVJR0hUX09GX1NDUk9MTF9aT05FICYmICh0aGlzLmluU2Nyb2xsWm9uZSA9IHRoaXMuQk9UVE9NX1NDUk9MTF9aT05FKSwgIXRoaXMuaW5TY3JvbGxab25lKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTY3JvbGxpbmcgfHwgKHRoaXMuc2Nyb2xsVmVydGljYWwodGhpcy5pblNjcm9sbFpvbmUgPT09IHRoaXMuVE9QX1NDUk9MTF9aT05FID8gLXRoaXMuU0NST0xMX1NQRUVEIDogdGhpcy5TQ1JPTExfU1BFRUQpLCB0aGlzLmlzU2Nyb2xsaW5nID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmVxdWlyZWQgSFRNTCBlbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgRWxlbWVudD59XG4gICAqL1xuICBnZW5IVE1MKCkge1xuICAgIGNvbnN0IHsgVUk6IGUgfSA9IHRoaXMuRWRpdG9yLCB0ID0gZS5ub2Rlcy5ob2xkZXIucXVlcnlTZWxlY3RvcihcIi5cIiArIGUuQ1NTLmVkaXRvcldyYXBwZXIpLCBvID0gZC5tYWtlKFwiZGl2XCIsIEJlLkNTUy5vdmVybGF5LCB7fSksIGkgPSBkLm1ha2UoXCJkaXZcIiwgQmUuQ1NTLm92ZXJsYXlDb250YWluZXIsIHt9KSwgcyA9IGQubWFrZShcImRpdlwiLCBCZS5DU1MucmVjdCwge30pO1xuICAgIHJldHVybiBpLmFwcGVuZENoaWxkKHMpLCBvLmFwcGVuZENoaWxkKGkpLCB0LmFwcGVuZENoaWxkKG8pLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUgPSBzLCB7XG4gICAgICBjb250YWluZXI6IHQsXG4gICAgICBvdmVybGF5OiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIHNjcm9sbGluZyBpZiBibG9ja1NlbGVjdGlvbiBpcyBhY3RpdmUgYW5kIG1vdXNlIGlzIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCAtIHNwZWVkIG9mIHNjcm9sbGluZ1xuICAgKi9cbiAgc2Nyb2xsVmVydGljYWwoZSkge1xuICAgIGlmICghKHRoaXMuaW5TY3JvbGxab25lICYmIHRoaXMubW91c2Vkb3duKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBlKSwgdGhpcy5tb3VzZVkgKz0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gdCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNjcm9sbFZlcnRpY2FsKGUpO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgaW4gdGhlIHJlY3RhbmdsZSBhbmQgaXRzIGVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gbW91c2UgZXZlbnRcbiAgICovXG4gIGNoYW5naW5nUmVjdGFuZ2xlKGUpIHtcbiAgICBpZiAoIXRoaXMubW91c2Vkb3duKVxuICAgICAgcmV0dXJuO1xuICAgIGUucGFnZVkgIT09IHZvaWQgMCAmJiAodGhpcy5tb3VzZVggPSBlLnBhZ2VYLCB0aGlzLm1vdXNlWSA9IGUucGFnZVkpO1xuICAgIGNvbnN0IHsgcmlnaHRQb3M6IHQsIGxlZnRQb3M6IG8sIGluZGV4OiBpIH0gPSB0aGlzLmdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpLCBzID0gdGhpcy5zdGFydFggPiB0ICYmIHRoaXMubW91c2VYID4gdCwgciA9IHRoaXMuc3RhcnRYIDwgbyAmJiB0aGlzLm1vdXNlWCA8IG87XG4gICAgdGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyA9ICEocyB8fCByKSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgfHwgKHRoaXMucmVjdENyb3NzZXNCbG9ja3MgPSAhMSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgPSAhMCwgdGhpcy5zaHJpbmtSZWN0YW5nbGVUb1BvaW50KCksIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKSwgdGhpcy51cGRhdGVSZWN0YW5nbGVTaXplKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgaSAhPT0gdm9pZCAwICYmICh0aGlzLnRyeVNlbGVjdE5leHRCbG9jayhpKSwgdGhpcy5pbnZlcnNlU2VsZWN0aW9uKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBTaHJpbmsgcmVjdCB0byBzaW5ndWxhciBwb2ludFxuICAgKi9cbiAgc2hyaW5rUmVjdGFuZ2xlVG9Qb2ludCgpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnRvcCA9IGAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmJvdHRvbSA9IGBjYWxjKDEwMCUgLSAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3Qgb3IgdW5zZWxlY3QgYWxsIG9mIGJsb2NrcyBpbiBhcnJheSBpZiByZWN0IGlzIG91dCBvciBpbiBzZWxlY3RhYmxlIGFyZWFcbiAgICovXG4gIGludmVyc2VTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbMF0pLnNlbGVjdGVkO1xuICAgIGlmICh0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmICF0KVxuICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMuc3RhY2tPZlNlbGVjdGVkKVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9ja0J5SW5kZXgobyk7XG4gICAgaWYgKCF0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHQpXG4gICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5zdGFja09mU2VsZWN0ZWQpXG4gICAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuU2VsZWN0QmxvY2tCeUluZGV4KG8pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHNpemUgb2YgcmVjdGFuZ2xlXG4gICAqL1xuICB1cGRhdGVSZWN0YW5nbGVTaXplKCkge1xuICAgIHRoaXMubW91c2VZID49IHRoaXMuc3RhcnRZID8gKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApIDogKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApLCB0aGlzLm1vdXNlWCA+PSB0aGlzLnN0YXJ0WCA/ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKSA6ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUucmlnaHQgPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKTtcbiAgfVxuICAvKipcbiAgICogQ29sbGVjdHMgaW5mb3JtYXRpb24gbmVlZGVkIHRvIGRldGVybWluZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG5leHQgQmxvY2ssIGxlZnRQb3MgLSBzdGFydCBvZiBsZWZ0IGJvcmRlciBvZiBCbG9jaywgcmlnaHRQb3MgLSByaWdodCBib3JkZXJcbiAgICovXG4gIGdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIDIsIG8gPSB0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCwgaSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodCwgbyksIHMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShpKTtcbiAgICBsZXQgcjtcbiAgICBzICE9PSB2b2lkIDAgJiYgKHIgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbmRJbmRleCgoaCkgPT4gaC5ob2xkZXIgPT09IHMuaG9sZGVyKSk7XG4gICAgY29uc3QgYSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2suaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBSLkNTUy5jb250ZW50KSwgbCA9IE51bWJlci5wYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS53aWR0aCwgMTApIC8gMiwgYyA9IHQgLSBsLCB1ID0gdCArIGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiByLFxuICAgICAgbGVmdFBvczogYyxcbiAgICAgIHJpZ2h0UG9zOiB1XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGJsb2NrIHdpdGggaW5kZXggaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgYmxvY2sgaW4gcmVkYWN0b3JcbiAgICovXG4gIGFkZEJsb2NrSW5TZWxlY3Rpb24oZSkge1xuICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0QmxvY2tCeUluZGV4KGUpLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgYmxvY2sgdG8gdGhlIHNlbGVjdGlvbiBhbmQgZGV0ZXJtaW5lcyB3aGljaCBibG9ja3Mgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG9mIG5ldyBibG9jayBpbiB0aGUgcmVhY3RvclxuICAgKi9cbiAgdHJ5U2VsZWN0TmV4dEJsb2NrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbdGhpcy5zdGFja09mU2VsZWN0ZWQubGVuZ3RoIC0gMV0gPT09IGUsIG8gPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5sZW5ndGgsIGkgPSAxLCBzID0gLTEsIHIgPSAwO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gLSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMl0gPiAwO1xuICAgIGxldCBsID0gcjtcbiAgICBvID4gMSAmJiAobCA9IGEgPyBpIDogcyk7XG4gICAgY29uc3QgYyA9IGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gaSwgdSA9IGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gcywgcCA9ICEoYyB8fCB1IHx8IGwgPT09IHIpO1xuICAgIGlmICghcCAmJiAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSB8fCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gPT09IHZvaWQgMCkpIHtcbiAgICAgIGxldCB2ID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICsgMSB8fCBlO1xuICAgICAgZm9yICh2OyB2IDw9IGU7IHYrKylcbiAgICAgICAgdGhpcy5hZGRCbG9ja0luU2VsZWN0aW9uKHYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXAgJiYgZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSkge1xuICAgICAgZm9yIChsZXQgdiA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSAtIDE7IHYgPj0gZTsgdi0tKVxuICAgICAgICB0aGlzLmFkZEJsb2NrSW5TZWxlY3Rpb24odik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZyA9IG8gLSAxLCBmO1xuICAgIGZvciAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSA/IGYgPSAoKSA9PiBlID4gdGhpcy5zdGFja09mU2VsZWN0ZWRbZ10gOiBmID0gKCkgPT4gZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW2ddOyBmKCk7IClcbiAgICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24udW5TZWxlY3RCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbZ10pLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wb3AoKSwgZy0tO1xuICB9XG59XG5jbGFzcyBnYSBleHRlbmRzIEUge1xuICAvKipcbiAgICogUmVuZGVycyBwYXNzZWQgYmxvY2tzIGFzIG9uZSBiYXRjaFxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tzRGF0YSAtIGJsb2NrcyB0byByZW5kZXJcbiAgICovXG4gIGFzeW5jIHJlbmRlcihlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBjb25zdCB7IFRvb2xzOiBvLCBCbG9ja01hbmFnZXI6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgICAgICBpLmluc2VydCgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHMgPSBlLm1hcCgoeyB0eXBlOiByLCBkYXRhOiBhLCB0dW5lczogbCwgaWQ6IGMgfSkgPT4ge1xuICAgICAgICAgIG8uYXZhaWxhYmxlLmhhcyhyKSA9PT0gITEgJiYgKFgoYFRvb2wgwqske3J9wrsgaXMgbm90IGZvdW5kLiBDaGVjayAndG9vbHMnIHByb3BlcnR5IGF0IHRoZSBFZGl0b3IuanMgY29uZmlnLmAsIFwid2FyblwiKSwgYSA9IHRoaXMuY29tcG9zZVN0dWJEYXRhRm9yVG9vbChyLCBhLCBjKSwgciA9IG8uc3R1YlRvb2wpO1xuICAgICAgICAgIGxldCB1O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1ID0gaS5jb21wb3NlQmxvY2soe1xuICAgICAgICAgICAgICBpZDogYyxcbiAgICAgICAgICAgICAgdG9vbDogcixcbiAgICAgICAgICAgICAgZGF0YTogYSxcbiAgICAgICAgICAgICAgdHVuZXM6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgIFMoYEJsb2NrIMKrJHtyfcK7IHNraXBwZWQgYmVjYXVzZSBvZiBwbHVnaW5zIGVycm9yYCwgXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgIGRhdGE6IGEsXG4gICAgICAgICAgICAgIGVycm9yOiBoXG4gICAgICAgICAgICB9KSwgYSA9IHRoaXMuY29tcG9zZVN0dWJEYXRhRm9yVG9vbChyLCBhLCBjKSwgciA9IG8uc3R1YlRvb2wsIHUgPSBpLmNvbXBvc2VCbG9jayh7XG4gICAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgICB0b29sOiByLFxuICAgICAgICAgICAgICBkYXRhOiBhLFxuICAgICAgICAgICAgICB0dW5lczogbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICB9KTtcbiAgICAgICAgaS5pbnNlcnRNYW55KHMpO1xuICAgICAgfVxuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0KCk7XG4gICAgICB9LCB7IHRpbWVvdXQ6IDJlMyB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGRhdGEgZm9yIHRoZSBTdHViIFRvb2wgdGhhdCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB1bmF2YWlsYWJsZSB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gdW5hdmFpbGFibGUgdG9vbCBuYW1lIHRvIHN0dWJcbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIG9mIHVuYXZhaWxhYmxlIGJsb2NrXG4gICAqIEBwYXJhbSBbaWRdIC0gaWQgb2YgdW5hdmFpbGFibGUgYmxvY2tcbiAgICovXG4gIGNvbXBvc2VTdHViRGF0YUZvclRvb2woZSwgdCwgbykge1xuICAgIGNvbnN0IHsgVG9vbHM6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBzID0gZTtcbiAgICBpZiAoaS51bmF2YWlsYWJsZS5oYXMoZSkpIHtcbiAgICAgIGNvbnN0IHIgPSBpLnVuYXZhaWxhYmxlLmdldChlKS50b29sYm94O1xuICAgICAgciAhPT0gdm9pZCAwICYmIHJbMF0udGl0bGUgIT09IHZvaWQgMCAmJiAocyA9IHJbMF0udGl0bGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2F2ZWREYXRhOiB7XG4gICAgICAgIGlkOiBvLFxuICAgICAgICB0eXBlOiBlLFxuICAgICAgICBkYXRhOiB0XG4gICAgICB9LFxuICAgICAgdGl0bGU6IHNcbiAgICB9O1xuICB9XG59XG5jbGFzcyBtYSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQ29tcG9zZXMgbmV3IGNoYWluIG9mIFByb21pc2VzIHRvIGZpcmUgdGhlbSBhbHRlcm5hdGVsbHlcbiAgICpcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBhc3luYyBzYXZlKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBlLmJsb2NrcywgaSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBvLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaS5wdXNoKHRoaXMuZ2V0U2F2ZWREYXRhKGEpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcyA9IGF3YWl0IFByb21pc2UuYWxsKGkpLCByID0gYXdhaXQgeXQocywgKGEpID0+IHQuYmxvY2tUb29scy5nZXQoYSkuc2FuaXRpemVDb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMubWFrZU91dHB1dChyKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBYKFwiU2F2aW5nIGZhaWxlZCBkdWUgdG8gdGhlIEVycm9yICVvXCIsIFwiZXJyb3JcIiwgcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBhbmQgdmFsaWRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gRWRpdG9yJ3MgVG9vbFxuICAgKiBAcmV0dXJucyB7VmFsaWRhdGVkRGF0YX0gLSBUb29sJ3MgdmFsaWRhdGVkIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldFNhdmVkRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IGUuc2F2ZSgpLCBvID0gdCAmJiBhd2FpdCBlLnZhbGlkYXRlKHQuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnQsXG4gICAgICBpc1ZhbGlkOiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvdXRwdXQgb2JqZWN0IHdpdGggc2F2ZWQgZGF0YSwgdGltZSBhbmQgdmVyc2lvbiBvZiBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtWYWxpZGF0ZWREYXRhfSBhbGxFeHRyYWN0ZWREYXRhIC0gZGF0YSBleHRyYWN0ZWQgZnJvbSBCbG9ja3NcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBtYWtlT3V0cHV0KGUpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgcmV0dXJuIGUuZm9yRWFjaCgoeyBpZDogbywgdG9vbDogaSwgZGF0YTogcywgdHVuZXM6IHIsIGlzVmFsaWQ6IGEgfSkgPT4ge1xuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIFMoYEJsb2NrIMKrJHtpfcK7IHNraXBwZWQgYmVjYXVzZSBzYXZlZCBkYXRhIGlzIGludmFsaWRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHRoaXMuRWRpdG9yLlRvb2xzLnN0dWJUb29sKSB7XG4gICAgICAgIHQucHVzaChzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbCA9IHtcbiAgICAgICAgaWQ6IG8sXG4gICAgICAgIHR5cGU6IGksXG4gICAgICAgIGRhdGE6IHMsXG4gICAgICAgIC4uLiFWKHIpICYmIHtcbiAgICAgICAgICB0dW5lczogclxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdC5wdXNoKGwpO1xuICAgIH0pLCB7XG4gICAgICB0aW1lOiArLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBibG9ja3M6IHQsXG4gICAgICB2ZXJzaW9uOiBcIjIuMzEuMC1yYy43XCJcbiAgICB9O1xuICB9XG59XG4oZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA8IFwidVwiKSB7XG4gICAgICB2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIG4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtcGFyYWdyYXBoe2xpbmUtaGVpZ2h0OjEuNmVtO291dGxpbmU6bm9uZX0uY2UtYmxvY2s6b25seS1vZi10eXBlIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdOmVtcHR5OmJlZm9yZSwuY2UtYmxvY2s6b25seS1vZi10eXBlIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdW2RhdGEtZW1wdHk9dHJ1ZV06YmVmb3Jle2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZSl9LmNlLXBhcmFncmFwaCBwOmZpcnN0LW9mLXR5cGV7bWFyZ2luLXRvcDowfS5jZS1wYXJhZ3JhcGggcDpsYXN0LW9mLXR5cGV7bWFyZ2luLWJvdHRvbTowfVwiKSksIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLCBlKTtcbiAgfVxufSkoKTtcbmNvbnN0IGJhID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk04IDlWNy4yQzggNy4wODk1NCA4LjA4OTU0IDcgOC4yIDdMMTIgN00xNiA5VjcuMkMxNiA3LjA4OTU0IDE1LjkxMDUgNyAxNS44IDdMMTIgN00xMiA3TDEyIDE3TTEyIDE3SDEwTTEyIDE3SDE0XCIvPjwvc3ZnPic7XG5mdW5jdGlvbiB2YShuKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBlLmlubmVySFRNTCA9IG4udHJpbSgpO1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICByZXR1cm4gdC5hcHBlbmQoLi4uQXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpKSwgdDtcbn1cbi8qKlxuICogQmFzZSBQYXJhZ3JhcGggQmxvY2sgZm9yIHRoZSBFZGl0b3IuanMuXG4gKiBSZXByZXNlbnRzIGEgcmVndWxhciB0ZXh0IGJsb2NrXG4gKlxuICogQGF1dGhvciBDb2RlWCAodGVhbUBjb2RleC5zbylcbiAqIEBjb3B5cmlnaHQgQ29kZVggMjAxOFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKi9cbmNsYXNzIGZvIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIFBhcmFncmFwaCBUb29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBjbGFzc1xuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1BMQUNFSE9MREVSKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gY29uc3RydWN0b3IgcGFyYW1zXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gcGFyYW1zLmRhdGEgLSBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhDb25maWd9IHBhcmFtcy5jb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmFwaSAtIGVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seSAtIHJlYWQgb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgY29uZmlnOiB0LCBhcGk6IG8sIHJlYWRPbmx5OiBpIH0pIHtcbiAgICB0aGlzLmFwaSA9IG8sIHRoaXMucmVhZE9ubHkgPSBpLCB0aGlzLl9DU1MgPSB7XG4gICAgICBibG9jazogdGhpcy5hcGkuc3R5bGVzLmJsb2NrLFxuICAgICAgd3JhcHBlcjogXCJjZS1wYXJhZ3JhcGhcIlxuICAgIH0sIHRoaXMucmVhZE9ubHkgfHwgKHRoaXMub25LZXlVcCA9IHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKSwgdGhpcy5fcGxhY2Vob2xkZXIgPSB0LnBsYWNlaG9sZGVyID8gdC5wbGFjZWhvbGRlciA6IGZvLkRFRkFVTFRfUExBQ0VIT0xERVIsIHRoaXMuX2RhdGEgPSBlID8/IHt9LCB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fcHJlc2VydmVCbGFuayA9IHQucHJlc2VydmVCbGFuayA/PyAhMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5IGFuZCBzZXQgZW1wdHkgc3RyaW5nIHRvIGlubmVyIGh0bWwuXG4gICAqIFdlIG5lZWQgdGhpcyBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgKGUuZy4gU2FmYXJpKSBpbnNlcnQgPGJyPiBpbnRvIGVtcHR5IGNvbnRlbnRlZGl0YW5sZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBrZXkgdXAgZXZlbnRcbiAgICovXG4gIG9uS2V5VXAoZSkge1xuICAgIGlmIChlLmNvZGUgIT09IFwiQmFja3NwYWNlXCIgJiYgZS5jb2RlICE9PSBcIkRlbGV0ZVwiIHx8ICF0aGlzLl9lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdGV4dENvbnRlbnQ6IHQgfSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgdCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyYXdWaWV3KCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgIHJldHVybiBlLmNsYXNzTGlzdC5hZGQodGhpcy5fQ1NTLndyYXBwZXIsIHRoaXMuX0NTUy5ibG9jayksIGUuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiLCBlLmRhdGFzZXQucGxhY2Vob2xkZXJBY3RpdmUgPSB0aGlzLmFwaS5pMThuLnQodGhpcy5fcGxhY2Vob2xkZXIpLCB0aGlzLl9kYXRhLnRleHQgJiYgKGUuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0KSwgdGhpcy5yZWFkT25seSB8fCAoZS5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIiwgZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5vbktleVVwKSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgPSB0aGlzLmRyYXdWaWV3KCksIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHNwZWNpZmllZCBob3cgdG8gbWVyZ2UgdHdvIFRleHQgYmxvY2tzLlxuICAgKiBDYWxsZWQgYnkgRWRpdG9yLmpzIGJ5IGJhY2tzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbWVyZ2UoZSkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kYXRhLnRleHQgKz0gZS50ZXh0O1xuICAgIGNvbnN0IHQgPSB2YShlLnRleHQpO1xuICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCksIHRoaXMuX2VsZW1lbnQubm9ybWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFBhcmFncmFwaCBibG9jayBkYXRhOlxuICAgKiAtIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBzYXZlZERhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdHJ1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICB2YWxpZGF0ZShlKSB7XG4gICAgcmV0dXJuICEoZS50ZXh0LnRyaW0oKSA9PT0gXCJcIiAmJiAhdGhpcy5fcHJlc2VydmVCbGFuayk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBQYXJhZ3JhcGggdG9vbHMgcmVuZGVyZWQgdmlld1xuICAgKiBAcmV0dXJucyB7UGFyYWdyYXBoRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBlLmlubmVySFRNTFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIGZpcmVkIGZyb20gRWRpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxQYXN0ZUV2ZW50fSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUoZSkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0ZXh0OiBlLmRldGFpbC5kYXRhLmlubmVySFRNTFxuICAgIH07XG4gICAgdGhpcy5fZGF0YSA9IHQsIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBDb252ZXJzaW9uIFRvb2xiYXIuIFBhcmFncmFwaCBjYW4gYmUgY29udmVydGVkIHRvL2Zyb20gb3RoZXIgdG9vbHNcbiAgICogQHJldHVybnMge0NvbnZlcnNpb25Db25maWd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydDogXCJ0ZXh0XCIsXG4gICAgICAvLyB0byBjb252ZXJ0IFBhcmFncmFwaCB0byBvdGhlciBibG9jaywgdXNlICd0ZXh0JyBwcm9wZXJ0eSBvZiBzYXZlZCBkYXRhXG4gICAgICBpbXBvcnQ6IFwidGV4dFwiXG4gICAgICAvLyB0byBjb3ZlcnQgb3RoZXIgYmxvY2sncyBleHBvcnRlZCBzdHJpbmcgdG8gUGFyYWdyYXBoLCBmaWxsICd0ZXh0JyBwcm9wZXJ0eSBvZiB0b29sIGRhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgcnVsZXNcbiAgICogQHJldHVybnMge1Nhbml0aXplckNvbmZpZ30gLSBFZHRpb3IuanMgc2FuaXRpemVyIGNvbmZpZ1xuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDoge1xuICAgICAgICBicjogITBcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IHRoZSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBFZGl0b3IgcGFzdGUgaGFuZGxpbmcgQVBJLlxuICAgKiBQcm92aWRlcyBjb25maWd1cmF0aW9uIHRvIGhhbmRsZSBQIHRhZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQYXN0ZUNvbmZpZ30gLSBQYXJhZ3JhcGggUGFzdGUgU2V0dGluZ1xuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiUFwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEljb24gYW5kIHRpdGxlIGZvciBkaXNwbGF5aW5nIGF0IHRoZSBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYm94Q29uZmlnfSAtIFBhcmFncmFwaCBUb29sYm94IFNldHRpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogYmEsXG4gICAgICB0aXRsZTogXCJUZXh0XCJcbiAgICB9O1xuICB9XG59XG5jbGFzcyBnbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tbWFuZE5hbWUgPSBcImJvbGRcIjtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGI+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGI6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogS2ksXG4gICAgICBuYW1lOiBcImJvbGRcIixcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTmFtZSk7XG4gICAgICB9LFxuICAgICAgaXNBY3RpdmU6ICgpID0+IGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKHRoaXMuY29tbWFuZE5hbWUpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgc2hvcnRjdXRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgcmV0dXJuIFwiQ01EK0JcIjtcbiAgfVxufVxuZ28uaXNJbmxpbmUgPSAhMDtcbmdvLnRpdGxlID0gXCJCb2xkXCI7XG5jbGFzcyBtbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tbWFuZE5hbWUgPSBcIml0YWxpY1wiLCB0aGlzLkNTUyA9IHtcbiAgICAgIGJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgYnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIGJ1dHRvbk1vZGlmaWVyOiBcImNlLWlubGluZS10b29sLS1pdGFsaWNcIlxuICAgIH0sIHRoaXMubm9kZXMgPSB7XG4gICAgICBidXR0b246IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZVxuICAgKiBMZWF2ZSA8aT4gdGFnc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaToge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYnV0dG9uIGZvciBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIHRoaXMubm9kZXMuYnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbiwgdGhpcy5DU1MuYnV0dG9uTW9kaWZpZXIpLCB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBKaSwgdGhpcy5ub2Rlcy5idXR0b247XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgcmFuZ2Ugd2l0aCA8aT4gdGFnXG4gICAqL1xuICBzdXJyb3VuZCgpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmROYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgc2VsZWN0aW9uIGFuZCBzZXQgYWN0aXZhdGVkIHN0YXRlIHRvIGJ1dHRvbiBpZiB0aGVyZSBhcmUgPGk+IHRhZ1xuICAgKi9cbiAgY2hlY2tTdGF0ZSgpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUodGhpcy5jb21tYW5kTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuYnV0dG9uQWN0aXZlLCBlKSwgZTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgc2hvcnRjdXRcbiAgICovXG4gIGdldCBzaG9ydGN1dCgpIHtcbiAgICByZXR1cm4gXCJDTUQrSVwiO1xuICB9XG59XG5tby5pc0lubGluZSA9ICEwO1xubW8udGl0bGUgPSBcIkl0YWxpY1wiO1xuY2xhc3MgYm8ge1xuICAvKipcbiAgICogQHBhcmFtIGFwaSAtIEVkaXRvci5qcyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLmNvbW1hbmRMaW5rID0gXCJjcmVhdGVMaW5rXCIsIHRoaXMuY29tbWFuZFVubGluayA9IFwidW5saW5rXCIsIHRoaXMuRU5URVJfS0VZID0gMTMsIHRoaXMuQ1NTID0ge1xuICAgICAgYnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBidXR0b25BY3RpdmU6IFwiY2UtaW5saW5lLXRvb2wtLWFjdGl2ZVwiLFxuICAgICAgYnV0dG9uTW9kaWZpZXI6IFwiY2UtaW5saW5lLXRvb2wtLWxpbmtcIixcbiAgICAgIGJ1dHRvblVubGluazogXCJjZS1pbmxpbmUtdG9vbC0tdW5saW5rXCIsXG4gICAgICBpbnB1dDogXCJjZS1pbmxpbmUtdG9vbC1pbnB1dFwiLFxuICAgICAgaW5wdXRTaG93ZWQ6IFwiY2UtaW5saW5lLXRvb2wtaW5wdXQtLXNob3dlZFwiXG4gICAgfSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIGJ1dHRvbjogbnVsbCxcbiAgICAgIGlucHV0OiBudWxsXG4gICAgfSwgdGhpcy5pbnB1dE9wZW5lZCA9ICExLCB0aGlzLnRvb2xiYXIgPSBlLnRvb2xiYXIsIHRoaXMuaW5saW5lVG9vbGJhciA9IGUuaW5saW5lVG9vbGJhciwgdGhpcy5ub3RpZmllciA9IGUubm90aWZpZXIsIHRoaXMuaTE4biA9IGUuaTE4biwgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZVxuICAgKiBMZWF2ZSA8YT4gdGFnc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYToge1xuICAgICAgICBocmVmOiAhMCxcbiAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICByZWw6IFwibm9mb2xsb3dcIlxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBidXR0b24gZm9yIElubGluZSBUb29sYmFyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgdGhpcy5ub2Rlcy5idXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uLCB0aGlzLkNTUy5idXR0b25Nb2RpZmllciksIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IENvLCB0aGlzLm5vZGVzLmJ1dHRvbjtcbiAgfVxuICAvKipcbiAgICogSW5wdXQgZm9yIHRoZSBsaW5rXG4gICAqL1xuICByZW5kZXJBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCB0aGlzLm5vZGVzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5pMThuLnQoXCJBZGQgYSBsaW5rXCIpLCB0aGlzLm5vZGVzLmlucHV0LmVudGVyS2V5SGludCA9IFwiZG9uZVwiLCB0aGlzLm5vZGVzLmlucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuaW5wdXQpLCB0aGlzLm5vZGVzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBlLmtleUNvZGUgPT09IHRoaXMuRU5URVJfS0VZICYmIHRoaXMuZW50ZXJQcmVzc2VkKGUpO1xuICAgIH0pLCB0aGlzLm5vZGVzLmlucHV0O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uIHRoZSBJbmxpbmUgVG9vbGJhciBpY29uXG4gICAqXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gcmFuZ2UgdG8gd3JhcCB3aXRoIGxpbmtcbiAgICovXG4gIHN1cnJvdW5kKGUpIHtcbiAgICBpZiAoZSkge1xuICAgICAgdGhpcy5pbnB1dE9wZW5lZCA/ICh0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCkpIDogKHRoaXMuc2VsZWN0aW9uLnNldEZha2VCYWNrZ3JvdW5kKCksIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSk7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyhcIkFcIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5leHBhbmRUb1RhZyh0KSwgdGhpcy51bmxpbmsoKSwgdGhpcy5jbG9zZUFjdGlvbnMoKSwgdGhpcy5jaGVja1N0YXRlKCksIHRoaXMudG9vbGJhci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlQWN0aW9ucygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBzZWxlY3Rpb24gYW5kIHNldCBhY3RpdmF0ZWQgc3RhdGUgdG8gYnV0dG9uIGlmIHRoZXJlIGFyZSA8YT4gdGFnXG4gICAqL1xuICBjaGVja1N0YXRlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKFwiQVwiKTtcbiAgICBpZiAoZSkge1xuICAgICAgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gbnMsIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uVW5saW5rKSwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b25BY3RpdmUpLCB0aGlzLm9wZW5BY3Rpb25zKCk7XG4gICAgICBjb25zdCB0ID0gZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgdGhpcy5ub2Rlcy5pbnB1dC52YWx1ZSA9IHQgIT09IFwibnVsbFwiID8gdCA6IFwiXCIsIHRoaXMuc2VsZWN0aW9uLnNhdmUoKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IENvLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmJ1dHRvblVubGluayksIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuYnV0dG9uQWN0aXZlKTtcbiAgICByZXR1cm4gISFlO1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBjYWxsZWQgd2l0aCBJbmxpbmUgVG9vbGJhciBjbG9zaW5nXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNsb3NlQWN0aW9ucygpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSBzaG9ydGN1dFxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIHJldHVybiBcIkNNRCtLXCI7XG4gIH1cbiAgLyoqXG4gICAqIFNob3cvY2xvc2UgbGluayBpbnB1dFxuICAgKi9cbiAgdG9nZ2xlQWN0aW9ucygpIHtcbiAgICB0aGlzLmlucHV0T3BlbmVkID8gdGhpcy5jbG9zZUFjdGlvbnMoITEpIDogdGhpcy5vcGVuQWN0aW9ucyghMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZEZvY3VzIC0gb24gbGluayBjcmVhdGlvbiB3ZSBuZWVkIHRvIGZvY3VzIGlucHV0LiBPbiBlZGl0aW5nIC0gbm9wZS5cbiAgICovXG4gIG9wZW5BY3Rpb25zKGUgPSAhMSkge1xuICAgIHRoaXMubm9kZXMuaW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5pbnB1dFNob3dlZCksIGUgJiYgdGhpcy5ub2Rlcy5pbnB1dC5mb2N1cygpLCB0aGlzLmlucHV0T3BlbmVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJTYXZlZFNlbGVjdGlvbiDigJQgd2UgZG9uJ3QgbmVlZCB0byBjbGVhciBzYXZlZCBzZWxlY3Rpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdG9nZ2xlLWNsaWNrcyBvbiB0aGUgaWNvbiBvZiBvcGVuZWQgVG9vbGJhclxuICAgKi9cbiAgY2xvc2VBY3Rpb25zKGUgPSAhMCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCkge1xuICAgICAgY29uc3QgdCA9IG5ldyBiKCk7XG4gICAgICB0LnNhdmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbi5yZW1vdmVGYWtlQmFja2dyb3VuZCgpLCB0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5ub2Rlcy5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmlucHV0U2hvd2VkKSwgdGhpcy5ub2Rlcy5pbnB1dC52YWx1ZSA9IFwiXCIsIGUgJiYgdGhpcy5zZWxlY3Rpb24uY2xlYXJTYXZlZCgpLCB0aGlzLmlucHV0T3BlbmVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVyIHByZXNzZWQgb24gaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGVudGVyIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGVudGVyUHJlc3NlZChlKSB7XG4gICAgbGV0IHQgPSB0aGlzLm5vZGVzLmlucHV0LnZhbHVlIHx8IFwiXCI7XG4gICAgaWYgKCF0LnRyaW0oKSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnVubGluaygpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuY2xvc2VBY3Rpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZVVSTCh0KSkge1xuICAgICAgdGhpcy5ub3RpZmllci5zaG93KHtcbiAgICAgICAgbWVzc2FnZTogXCJQYXN0ZWQgbGluayBpcyBub3QgdmFsaWQuXCIsXG4gICAgICAgIHN0eWxlOiBcImVycm9yXCJcbiAgICAgIH0pLCBTKFwiSW5jb3JyZWN0IExpbmsgcGFzdGVkXCIsIFwid2FyblwiLCB0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCA9IHRoaXMucHJlcGFyZUxpbmsodCksIHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRmFrZUJhY2tncm91bmQoKSwgdGhpcy5pbnNlcnRMaW5rKHQpLCBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMuc2VsZWN0aW9uLmNvbGxhcHNlVG9FbmQoKSwgdGhpcy5pbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVjdHMgaWYgcGFzc2VkIHN0cmluZyBpcyBVUkxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlVVJMKGUpIHtcbiAgICByZXR1cm4gIS9cXHMvLnRlc3QoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgbGluayBiZWZvcmUgaW5qZWN0aW9uXG4gICAqIC0gc2FuaXRpemVcbiAgICogLSBhZGQgcHJvdG9jb2wgZm9yIGxpbmtzIGxpa2UgJ2dvb2dsZS5jb20nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gcmF3IHVzZXIgaW5wdXRcbiAgICovXG4gIHByZXBhcmVMaW5rKGUpIHtcbiAgICByZXR1cm4gZSA9IGUudHJpbSgpLCBlID0gdGhpcy5hZGRQcm90b2NvbChlKSwgZTtcbiAgfVxuICAvKipcbiAgICogQWRkICdodHRwJyBwcm90b2NvbCB0byB0aGUgbGlua3MgbGlrZSAndmMucnUnLCAnZ29vZ2xlLmNvbSdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgLSBzdHJpbmcgdG8gcHJvY2Vzc1xuICAgKi9cbiAgYWRkUHJvdG9jb2woZSkge1xuICAgIGlmICgvXihcXHcrKTooXFwvXFwvKT8vLnRlc3QoZSkpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCB0ID0gL15cXC9bXi9cXHNdLy50ZXN0KGUpLCBvID0gZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiI1wiLCBpID0gL15cXC9cXC9bXi9cXHNdLy50ZXN0KGUpO1xuICAgIHJldHVybiAhdCAmJiAhbyAmJiAhaSAmJiAoZSA9IFwiaHR0cDovL1wiICsgZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgPGE+IHRhZyB3aXRoIFwiaHJlZlwiXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gXCJocmVmXCIgdmFsdWVcbiAgICovXG4gIGluc2VydExpbmsoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKFwiQVwiKTtcbiAgICB0ICYmIHRoaXMuc2VsZWN0aW9uLmV4cGFuZFRvVGFnKHQpLCBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRMaW5rLCAhMSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgPGE+IHRhZ1xuICAgKi9cbiAgdW5saW5rKCkge1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZFVubGluayk7XG4gIH1cbn1cbmJvLmlzSW5saW5lID0gITA7XG5iby50aXRsZSA9IFwiTGlua1wiO1xuY2xhc3MgRm4ge1xuICAvKipcbiAgICogQHBhcmFtIGFwaSAtIEVkaXRvci5qcyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLmkxOG5BUEkgPSBlLmkxOG4sIHRoaXMuYmxvY2tzQVBJID0gZS5ibG9ja3MsIHRoaXMuc2VsZWN0aW9uQVBJID0gZS5zZWxlY3Rpb24sIHRoaXMudG9vbHNBUEkgPSBlLnRvb2xzLCB0aGlzLmNhcmV0QVBJID0gZS5jYXJldDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0b29sJ3MgVUkgY29uZmlnXG4gICAqL1xuICBhc3luYyByZW5kZXIoKSB7XG4gICAgY29uc3QgZSA9IGIuZ2V0KCksIHQgPSB0aGlzLmJsb2Nrc0FQSS5nZXRCbG9ja0J5RWxlbWVudChlLmFuY2hvck5vZGUpO1xuICAgIGlmICh0ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbyA9IHRoaXMudG9vbHNBUEkuZ2V0QmxvY2tUb29scygpLCBpID0gYXdhaXQgWW8odCwgbyk7XG4gICAgaWYgKGkubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHMgPSBpLnJlZHVjZSgoYywgdSkgPT4ge1xuICAgICAgdmFyIGg7XG4gICAgICByZXR1cm4gKGggPSB1LnRvb2xib3gpID09IG51bGwgfHwgaC5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIGMucHVzaCh7XG4gICAgICAgICAgaWNvbjogcC5pY29uLFxuICAgICAgICAgIHRpdGxlOiB6LnQoSy50b29sTmFtZXMsIHAudGl0bGUpLFxuICAgICAgICAgIG5hbWU6IHUubmFtZSxcbiAgICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICAgIG9uQWN0aXZhdGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBhd2FpdCB0aGlzLmJsb2Nrc0FQSS5jb252ZXJ0KHQuaWQsIHUubmFtZSwgcC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXRBUEkuc2V0VG9CbG9jayhnLCBcImVuZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGM7XG4gICAgfSwgW10pLCByID0gYXdhaXQgdC5nZXRBY3RpdmVUb29sYm94RW50cnkoKSwgYSA9IHIgIT09IHZvaWQgMCA/IHIuaWNvbiA6IEdvLCBsID0gIWJlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGEsXG4gICAgICBuYW1lOiBcImNvbnZlcnQtdG9cIixcbiAgICAgIGhpbnQ6IHtcbiAgICAgICAgdGl0bGU6IHRoaXMuaTE4bkFQSS50KFwiQ29udmVydCB0b1wiKVxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgIHNlYXJjaGFibGU6IGwsXG4gICAgICAgIGl0ZW1zOiBzLFxuICAgICAgICBvbk9wZW46ICgpID0+IHtcbiAgICAgICAgICBsICYmICh0aGlzLnNlbGVjdGlvbkFQSS5zZXRGYWtlQmFja2dyb3VuZCgpLCB0aGlzLnNlbGVjdGlvbkFQSS5zYXZlKCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgbCAmJiAodGhpcy5zZWxlY3Rpb25BUEkucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbkFQSS5yZW1vdmVGYWtlQmFja2dyb3VuZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbkZuLmlzSW5saW5lID0gITA7XG5jbGFzcyBqbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIHN0dWIgdG9vbCBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zLmFwaSAtIEVkaXRvci5qcyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogZSwgYXBpOiB0IH0pIHtcbiAgICB0aGlzLkNTUyA9IHtcbiAgICAgIHdyYXBwZXI6IFwiY2Utc3R1YlwiLFxuICAgICAgaW5mbzogXCJjZS1zdHViX19pbmZvXCIsXG4gICAgICB0aXRsZTogXCJjZS1zdHViX190aXRsZVwiLFxuICAgICAgc3VidGl0bGU6IFwiY2Utc3R1Yl9fc3VidGl0bGVcIlxuICAgIH0sIHRoaXMuYXBpID0gdCwgdGhpcy50aXRsZSA9IGUudGl0bGUgfHwgdGhpcy5hcGkuaTE4bi50KFwiRXJyb3JcIiksIHRoaXMuc3VidGl0bGUgPSB0aGlzLmFwaS5pMThuLnQoXCJUaGUgYmxvY2sgY2FuIG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LlwiKSwgdGhpcy5zYXZlZERhdGEgPSBlLnNhdmVkRGF0YSwgdGhpcy53cmFwcGVyID0gdGhpcy5tYWtlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc3R1YiBob2xkZXJcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBvcmlnaW5hbCBUb29sIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrVG9vbERhdGF9XG4gICAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNhdmVkRGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFRvb2wgaHRtbCBtYXJrdXBcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICBjb25zdCBlID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLndyYXBwZXIpLCB0ID0gaXMsIG8gPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuaW5mbyksIGkgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLnRpdGxlXG4gICAgfSksIHMgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1Muc3VidGl0bGUsIHtcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLnN1YnRpdGxlXG4gICAgfSk7XG4gICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gdCwgby5hcHBlbmRDaGlsZChpKSwgby5hcHBlbmRDaGlsZChzKSwgZS5hcHBlbmRDaGlsZChvKSwgZTtcbiAgfVxufVxuam4uaXNSZWFkT25seVN1cHBvcnRlZCA9ICEwO1xuY2xhc3Mga2EgZXh0ZW5kcyBUdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IGFlLklubGluZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aXRsZSBmb3IgSW5saW5lIFRvb2wgaWYgc3BlY2lmaWVkIGJ5IHVzZXJcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW1dlLlRpdGxlXTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgSW5saW5lVG9vbCBpbnN0YW5jZSBmcm9tIGNvbnN0cnVjdGFibGVcbiAgICovXG4gIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyBpbmxpbmUgdG9vbCB0byBiZSBhdmFpbGFibGUgaW4gcmVhZC1vbmx5IG1vZGVcbiAgICogQ2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBieSBjb21tZW50cyB0b29sXG4gICAqL1xuICBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW1dlLklzUmVhZE9ubHlTdXBwb3J0ZWRdID8/ICExO1xuICB9XG59XG5jbGFzcyB5YSBleHRlbmRzIFR0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gYWUuVHVuZTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgQmxvY2tUdW5lIGluc3RhbmNlIGZyb20gY29uc3RydWN0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFR1bmUgZGF0YVxuICAgKiBAcGFyYW0gYmxvY2sgLSBCbG9jayBBUEkgb2JqZWN0XG4gICAqL1xuICBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RhYmxlKHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjb25maWc6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBibG9jazogdCxcbiAgICAgIGRhdGE6IGVcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgaiBleHRlbmRzIE1hcCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIFRvb2xzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBibG9ja1Rvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzQmxvY2soKSk7XG4gICAgcmV0dXJuIG5ldyBqKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIElubGluZSBUb29scyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgaW5saW5lVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNJbmxpbmUoKSk7XG4gICAgcmV0dXJuIG5ldyBqKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIFR1bmVzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBibG9ja1R1bmVzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzVHVuZSgpKTtcbiAgICByZXR1cm4gbmV3IGooZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgVG9vbHMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGludGVybmFsVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNJbnRlcm5hbCk7XG4gICAgcmV0dXJuIG5ldyBqKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2xzIGNvbGxlY3Rpb24gcHJvdmlkZWQgYnkgdXNlclxuICAgKi9cbiAgZ2V0IGV4dGVybmFsVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+ICF0LmlzSW50ZXJuYWwpO1xuICAgIHJldHVybiBuZXcgaihlKTtcbiAgfVxufVxudmFyIHdhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBFYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIEhuID0gKG4sIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IEVhKGUsIHQpIDogZSwgcyA9IG4ubGVuZ3RoIC0gMSwgcjsgcyA+PSAwOyBzLS0pXG4gICAgKHIgPSBuW3NdKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIHdhKGUsIHQsIGkpLCBpO1xufTtcbmNsYXNzIHZvIGV4dGVuZHMgVHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBhZS5CbG9jaywgdGhpcy5pbmxpbmVUb29scyA9IG5ldyBqKCksIHRoaXMudHVuZXMgPSBuZXcgaigpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBUb29sIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVG9vbCBkYXRhXG4gICAqIEBwYXJhbSBibG9jayAtIEJsb2NrQVBJIGZvciBjdXJyZW50IEJsb2NrXG4gICAqIEBwYXJhbSByZWFkT25seSAtIFRydWUgaWYgRWRpdG9yIGlzIGluIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICBjcmVhdGUoZSwgdCwgbykge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RhYmxlKHtcbiAgICAgIGRhdGE6IGUsXG4gICAgICBibG9jazogdCxcbiAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkIGJ5IFRvb2xcbiAgICovXG4gIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbcGUuSXNSZWFkT25seVN1cHBvcnRlZF0gPT09ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbCBzdXBwb3J0cyBsaW5lYnJlYWtzXG4gICAqL1xuICBnZXQgaXNMaW5lQnJlYWtzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3BlLklzRW5hYmxlZExpbmVCcmVha3NdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2wgdG9vbGJveCBjb25maWd1cmF0aW9uIChpbnRlcm5hbCBvciB1c2VyLXNwZWNpZmllZCkuXG4gICAqXG4gICAqIE1lcmdlcyBpbnRlcm5hbCBhbmQgdXNlci1kZWZpbmVkIHRvb2xib3ggY29uZmlncyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICAgKlxuICAgKiAtIElmIGJvdGggaW50ZXJuYWwgYW5kIHVzZXItZGVmaW5lZCB0b29sYm94IGNvbmZpZ3MgYXJlIGFycmF5cyB0aGVpciBpdGVtcyBhcmUgbWVyZ2VkLlxuICAgKiBMZW5ndGggb2YgdGhlIHNlY29uZCBvbmUgaXMga2VwdC5cbiAgICpcbiAgICogLSBJZiBib3RoIGFyZSBvYmplY3RzIHRoZWlyIHByb3BlcnRpZXMgYXJlIG1lcmdlZC5cbiAgICpcbiAgICogLSBJZiBvbmUgaXMgYW4gb2JqZWN0IGFuZCBhbm90aGVyIGlzIGFuIGFycmF5IHRoYW4gaW50ZXJuYWwgY29uZmlnIGlzIHJlcGxhY2VkIHdpdGggdXNlci1kZWZpbmVkXG4gICAqIGNvbmZpZy4gVGhpcyBpcyBtYWRlIHRvIGFsbG93IHVzZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCB0b29sJ3MgdG9vbGJveCByZXByZXNlbnRhdGlvbiAoc2luZ2xlL211bHRpcGxlIGVudHJpZXMpXG4gICAqL1xuICBnZXQgdG9vbGJveCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25zdHJ1Y3RhYmxlW3BlLlRvb2xib3hdLCB0ID0gdGhpcy5jb25maWdbUGUuVG9vbGJveF07XG4gICAgaWYgKCFWKGUpICYmIHQgIT09ICExKVxuICAgICAgcmV0dXJuIHQgPyBBcnJheS5pc0FycmF5KGUpID8gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKChvLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBlW2ldO1xuICAgICAgICByZXR1cm4gcyA/IHtcbiAgICAgICAgICAuLi5zLFxuICAgICAgICAgIC4uLm9cbiAgICAgICAgfSA6IG87XG4gICAgICB9KSA6IFt0XSA6IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICAuLi50XG4gICAgICAgIH1cbiAgICAgIF0gOiBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtlXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIGNvbnZlcnNpb24gY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtwZS5Db252ZXJzaW9uQ29uZmlnXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBlbmFibGVkIGlubGluZSB0b29scyBmb3IgVG9vbFxuICAgKi9cbiAgZ2V0IGVuYWJsZWRJbmxpbmVUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdbUGUuRW5hYmxlZElubGluZVRvb2xzXSB8fCAhMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBlbmFibGVkIHR1bmVzIGZvciBUb29sXG4gICAqL1xuICBnZXQgZW5hYmxlZEJsb2NrVHVuZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW1BlLkVuYWJsZWRCbG9ja1R1bmVzXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHBhc3RlIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3BlLlBhc3RlQ29uZmlnXSA/PyB7fTtcbiAgfVxuICBnZXQgc2FuaXRpemVDb25maWcoKSB7XG4gICAgY29uc3QgZSA9IHN1cGVyLnNhbml0aXplQ29uZmlnLCB0ID0gdGhpcy5iYXNlU2FuaXRpemVDb25maWc7XG4gICAgaWYgKFYoZSkpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBvID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIGUpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIGkpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBlW2ldO1xuICAgICAgICBEKHMpID8gb1tpXSA9IE9iamVjdC5hc3NpZ24oe30sIHQsIHMpIDogb1tpXSA9IHM7XG4gICAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZ2V0IGJhc2VTYW5pdGl6ZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4gT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKSksIEFycmF5LmZyb20odGhpcy50dW5lcy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4gT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKSksIGU7XG4gIH1cbn1cbkhuKFtcbiAgbWVcbl0sIHZvLnByb3RvdHlwZSwgXCJzYW5pdGl6ZUNvbmZpZ1wiLCAxKTtcbkhuKFtcbiAgbWVcbl0sIHZvLnByb3RvdHlwZSwgXCJiYXNlU2FuaXRpemVDb25maWdcIiwgMSk7XG5jbGFzcyB4YSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIGNvbmZpZyAtIHRvb2xzIGNvbmZpZ1xuICAgKiBAcGFyYW0gZWRpdG9yQ29uZmlnIC0gRWRpdG9ySlMgY29uZmlnXG4gICAqIEBwYXJhbSBhcGkgLSBFZGl0b3JKUyBBUEkgbW9kdWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCBvKSB7XG4gICAgdGhpcy5hcGkgPSBvLCB0aGlzLmNvbmZpZyA9IGUsIHRoaXMuZWRpdG9yQ29uZmlnID0gdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIG9iamVjdCBiYXNlZCBvbiBpdCdzIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0b29sIG5hbWVcbiAgICovXG4gIGdldChlKSB7XG4gICAgY29uc3QgeyBjbGFzczogdCwgaXNJbnRlcm5hbDogbyA9ICExLCAuLi5pIH0gPSB0aGlzLmNvbmZpZ1tlXSwgcyA9IHRoaXMuZ2V0Q29uc3RydWN0b3IodCksIHIgPSB0W210LklzVHVuZV07XG4gICAgcmV0dXJuIG5ldyBzKHtcbiAgICAgIG5hbWU6IGUsXG4gICAgICBjb25zdHJ1Y3RhYmxlOiB0LFxuICAgICAgY29uZmlnOiBpLFxuICAgICAgYXBpOiB0aGlzLmFwaS5nZXRNZXRob2RzRm9yVG9vbChlLCByKSxcbiAgICAgIGlzRGVmYXVsdDogZSA9PT0gdGhpcy5lZGl0b3JDb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgZGVmYXVsdFBsYWNlaG9sZGVyOiB0aGlzLmVkaXRvckNvbmZpZy5wbGFjZWhvbGRlcixcbiAgICAgIGlzSW50ZXJuYWw6IG9cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhcHByb3ByaWF0ZSBUb29sIG9iamVjdCBjb25zdHJ1Y3RvciBmb3IgVG9vbCBjb25zdHJ1Y3RhYmxlXG4gICAqXG4gICAqIEBwYXJhbSBjb25zdHJ1Y3RhYmxlIC0gVG9vbHMgY29uc3RydWN0YWJsZVxuICAgKi9cbiAgZ2V0Q29uc3RydWN0b3IoZSkge1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgZVtXZS5Jc0lubGluZV06XG4gICAgICAgIHJldHVybiBrYTtcbiAgICAgIGNhc2UgZVttdC5Jc1R1bmVdOlxuICAgICAgICByZXR1cm4geWE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdm87XG4gICAgfVxuICB9XG59XG5jbGFzcyAkbiB7XG4gIC8qKlxuICAgKiBNb3ZlRG93blR1bmUgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtBUEl9IGFwaSDigJQgRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5DU1MgPSB7XG4gICAgICBhbmltYXRpb246IFwid29iYmxlXCJcbiAgICB9LCB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogWGksXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiTW92ZSBkb3duXCIpLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpLFxuICAgICAgbmFtZTogXCJtb3ZlLWRvd25cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gJ21vdmUgZG93bicgYnV0dG9uXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIHQgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUgKyAxKTtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbW92ZSBCbG9jayBkb3duIHNpbmNlIGl0IGlzIGFscmVhZHkgdGhlIGxhc3RcIik7XG4gICAgY29uc3QgbyA9IHQuaG9sZGVyLCBpID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcyA9IE1hdGguYWJzKHdpbmRvdy5pbm5lckhlaWdodCAtIG8ub2Zmc2V0SGVpZ2h0KTtcbiAgICBpLnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiAocyA9IHdpbmRvdy5zY3JvbGxZICsgby5vZmZzZXRIZWlnaHQpLCB3aW5kb3cuc2Nyb2xsVG8oMCwgcyksIHRoaXMuYXBpLmJsb2Nrcy5tb3ZlKGUgKyAxKSwgdGhpcy5hcGkudG9vbGJhci50b2dnbGVCbG9ja1NldHRpbmdzKCEwKTtcbiAgfVxufVxuJG4uaXNUdW5lID0gITA7XG5jbGFzcyB6biB7XG4gIC8qKlxuICAgKiBEZWxldGVUdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkgLSBFZGl0b3IncyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogR2ksXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiRGVsZXRlXCIpLFxuICAgICAgbmFtZTogXCJkZWxldGVcIixcbiAgICAgIGNvbmZpcm1hdGlvbjoge1xuICAgICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiQ2xpY2sgdG8gZGVsZXRlXCIpLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYmxvY2sgY29uZGl0aW9ucyBwYXNzZWRcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMuYXBpLmJsb2Nrcy5kZWxldGUoKTtcbiAgfVxufVxuem4uaXNUdW5lID0gITA7XG5jbGFzcyBVbiB7XG4gIC8qKlxuICAgKiBNb3ZlVXBUdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkgLSBFZGl0b3IncyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLkNTUyA9IHtcbiAgICAgIGFuaW1hdGlvbjogXCJ3b2JibGVcIlxuICAgIH0sIHRoaXMuYXBpID0gZTtcbiAgfVxuICAvKipcbiAgICogVHVuZSdzIGFwcGVhcmFuY2UgaW4gYmxvY2sgc2V0dGluZ3MgbWVudVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBaaSxcbiAgICAgIHRpdGxlOiB0aGlzLmFwaS5pMThuLnQoXCJNb3ZlIHVwXCIpLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpLFxuICAgICAgbmFtZTogXCJtb3ZlLXVwXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGN1cnJlbnQgYmxvY2sgdXBcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgdCA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgoZSksIG8gPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUgLSAxKTtcbiAgICBpZiAoZSA9PT0gMCB8fCAhdCB8fCAhbylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBtb3ZlIEJsb2NrIHVwIHNpbmNlIGl0IGlzIGFscmVhZHkgdGhlIGZpcnN0XCIpO1xuICAgIGNvbnN0IGkgPSB0LmhvbGRlciwgcyA9IG8uaG9sZGVyLCByID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGw7XG4gICAgYS50b3AgPiAwID8gbCA9IE1hdGguYWJzKHIudG9wKSAtIE1hdGguYWJzKGEudG9wKSA6IGwgPSBNYXRoLmFicyhyLnRvcCkgKyBhLmhlaWdodCwgd2luZG93LnNjcm9sbEJ5KDAsIC0xICogbCksIHRoaXMuYXBpLmJsb2Nrcy5tb3ZlKGUgLSAxKSwgdGhpcy5hcGkudG9vbGJhci50b2dnbGVCbG9ja1NldHRpbmdzKCEwKTtcbiAgfVxufVxuVW4uaXNUdW5lID0gITA7XG52YXIgQmEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIENhID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgVGEgPSAobiwgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gQ2EoZSwgdCkgOiBlLCBzID0gbi5sZW5ndGggLSAxLCByOyBzID49IDA7IHMtLSlcbiAgICAociA9IG5bc10pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgQmEoZSwgdCwgaSksIGk7XG59O1xuY2xhc3MgV24gZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zdHViVG9vbCA9IFwic3R1YlwiLCB0aGlzLnRvb2xzQXZhaWxhYmxlID0gbmV3IGooKSwgdGhpcy50b29sc1VuYXZhaWxhYmxlID0gbmV3IGooKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhdmFpbGFibGUgVG9vbHNcbiAgICovXG4gIGdldCBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNBdmFpbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdW5hdmFpbGFibGUgVG9vbHNcbiAgICovXG4gIGdldCB1bmF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sc1VuYXZhaWxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbHMgZm9yIHRoZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5pbmxpbmVUb29scztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGVkaXRvciBibG9jayB0b29sc1xuICAgKi9cbiAgZ2V0IGJsb2NrVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmJsb2NrVG9vbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhdmFpbGFibGUgQmxvY2sgVHVuZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gLSBvYmplY3Qgb2YgSW5saW5lIFRvb2wncyBjbGFzc2VzXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuYmxvY2tUdW5lcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0IFRvb2wgb2JqZWN0XG4gICAqL1xuICBnZXQgZGVmYXVsdFRvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tUb29scy5nZXQodGhpcy5jb25maWcuZGVmYXVsdEJsb2NrKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbnRlcm5hbCB0b29sc1xuICAgKi9cbiAgZ2V0IGludGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5pbnRlcm5hbFRvb2xzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGluc3RhbmNlcyB2aWEgcGFzc2VkIG9yIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUb29scygpLCB0aGlzLmNvbmZpZy50b29scyA9IHV0KHt9LCB0aGlzLmludGVybmFsVG9vbHMsIHRoaXMuY29uZmlnLnRvb2xzKSwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbmZpZywgXCJ0b29sc1wiKSB8fCBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy50b29scykubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBzdGFydCB3aXRob3V0IHRvb2xzXCIpO1xuICAgIGNvbnN0IGUgPSB0aGlzLnByZXBhcmVDb25maWcoKTtcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgeGEoZSwgdGhpcy5jb25maWcsIHRoaXMuRWRpdG9yLkFQSSk7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0TGlzdE9mUHJlcGFyZUZ1bmN0aW9ucyhlKTtcbiAgICBpZiAodC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgYXdhaXQgUW4odCwgKG8pID0+IHtcbiAgICAgIHRoaXMudG9vbFByZXBhcmVNZXRob2RTdWNjZXNzKG8pO1xuICAgIH0sIChvKSA9PiB7XG4gICAgICB0aGlzLnRvb2xQcmVwYXJlTWV0aG9kRmFsbGJhY2sobyk7XG4gICAgfSksIHRoaXMucHJlcGFyZUJsb2NrVG9vbHMoKTtcbiAgfVxuICBnZXRBbGxJbmxpbmVUb29sc1Nhbml0aXplQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlubGluZVRvb2xzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGUsIHQuc2FuaXRpemVDb25maWcpO1xuICAgIH0pLCBlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBlYWNoIFRvb2wgcmVzZXQgbWV0aG9kIHRvIGNsZWFuIHVwIGFueXRoaW5nIHNldCBieSBUb29sXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5hdmFpbGFibGUpLmZvckVhY2goYXN5bmMgKGUpID0+IHtcbiAgICAgIEEoZS5yZXNldCkgJiYgYXdhaXQgZS5yZXNldCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGludGVybmFsIHRvb2xzXG4gICAqIEluY2x1ZGVzIEJvbGQsIEl0YWxpYywgTGluayBhbmQgUGFyYWdyYXBoXG4gICAqL1xuICBnZXQgaW50ZXJuYWxUb29scygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udmVydFRvOiB7XG4gICAgICAgIGNsYXNzOiBGbixcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBsaW5rOiB7XG4gICAgICAgIGNsYXNzOiBibyxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBib2xkOiB7XG4gICAgICAgIGNsYXNzOiBnbyxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBpdGFsaWM6IHtcbiAgICAgICAgY2xhc3M6IG1vLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICBjbGFzczogZm8sXG4gICAgICAgIGlubGluZVRvb2xiYXI6ICEwLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIHN0dWI6IHtcbiAgICAgICAgY2xhc3M6IGpuLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIG1vdmVVcDoge1xuICAgICAgICBjbGFzczogVW4sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiB7XG4gICAgICAgIGNsYXNzOiB6bixcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBtb3ZlRG93bjoge1xuICAgICAgICBjbGFzczogJG4sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBwcmVwYXJlIG1ldGhvZCBzdWNjZXNzIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gYXBwZW5kIHRvb2wgdG8gYXZhaWxhYmxlIGxpc3RcbiAgICovXG4gIHRvb2xQcmVwYXJlTWV0aG9kU3VjY2VzcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmFjdG9yeS5nZXQoZS50b29sTmFtZSk7XG4gICAgaWYgKHQuaXNJbmxpbmUoKSkge1xuICAgICAgY29uc3QgaSA9IFtcInJlbmRlclwiXS5maWx0ZXIoKHMpID0+ICF0LmNyZWF0ZSgpW3NdKTtcbiAgICAgIGlmIChpLmxlbmd0aCkge1xuICAgICAgICBTKFxuICAgICAgICAgIGBJbmNvcnJlY3QgSW5saW5lIFRvb2w6ICR7dC5uYW1lfS4gU29tZSBvZiByZXF1aXJlZCBtZXRob2RzIGlzIG5vdCBpbXBsZW1lbnRlZCAlb2AsXG4gICAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgICAgaVxuICAgICAgICApLCB0aGlzLnRvb2xzVW5hdmFpbGFibGUuc2V0KHQubmFtZSwgdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50b29sc0F2YWlsYWJsZS5zZXQodC5uYW1lLCB0KTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBwcmVwYXJlIG1ldGhvZCBmYWlsIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gYXBwZW5kIHRvb2wgdG8gdW5hdmFpbGFibGUgbGlzdFxuICAgKi9cbiAgdG9vbFByZXBhcmVNZXRob2RGYWxsYmFjayhlKSB7XG4gICAgdGhpcy50b29sc1VuYXZhaWxhYmxlLnNldChlLnRvb2xOYW1lLCB0aGlzLmZhY3RvcnkuZ2V0KGUudG9vbE5hbWUpKTtcbiAgfVxuICAvKipcbiAgICogQmluZHMgcHJlcGFyZSBmdW5jdGlvbiBvZiBwbHVnaW5zIHdpdGggdXNlciBvciBkZWZhdWx0IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgbmVlZHMgdG8gYmUgZmlyZWQgc2VxdWVudGlhbGx5XG4gICAqIEBwYXJhbSBjb25maWcgLSB0b29scyBjb25maWdcbiAgICovXG4gIGdldExpc3RPZlByZXBhcmVGdW5jdGlvbnMoZSkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28sIGldKSA9PiB7XG4gICAgICB0LnB1c2goe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICAgIGZ1bmN0aW9uOiBBKGkuY2xhc3MucHJlcGFyZSkgPyBpLmNsYXNzLnByZXBhcmUgOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0b29sTmFtZTogbyxcbiAgICAgICAgICBjb25maWc6IGkuY29uZmlnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCB0O1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gZW5hYmxlZCBJbmxpbmUgVG9vbHMgYW5kIEJsb2NrIFR1bmVzIGZvciBCbG9jayBUb29sXG4gICAqL1xuICBwcmVwYXJlQmxvY2tUb29scygpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMuYmxvY2tUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5hc3NpZ25JbmxpbmVUb29sc1RvQmxvY2tUb29sKGUpLCB0aGlzLmFzc2lnbkJsb2NrVHVuZXNUb0Jsb2NrVG9vbChlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgSW5saW5lIFRvb2xzIGZvciBCbG9jayBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2sgVG9vbFxuICAgKi9cbiAgYXNzaWduSW5saW5lVG9vbHNUb0Jsb2NrVG9vbChlKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgIT09ICExKSB7XG4gICAgICBpZiAoZS5lbmFibGVkSW5saW5lVG9vbHMgPT09ICEwKSB7XG4gICAgICAgIGUuaW5saW5lVG9vbHMgPSBuZXcgaihcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIpID8gdGhpcy5jb25maWcuaW5saW5lVG9vbGJhci5tYXAoKHQpID0+IFt0LCB0aGlzLmlubGluZVRvb2xzLmdldCh0KV0pIDogQXJyYXkuZnJvbSh0aGlzLmlubGluZVRvb2xzLmVudHJpZXMoKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgQXJyYXkuaXNBcnJheShlLmVuYWJsZWRJbmxpbmVUb29scykgJiYgKGUuaW5saW5lVG9vbHMgPSBuZXcgaihcbiAgICAgICAgLyoqIFByZXBlbmQgQ29udmVydFRvIElubGluZSBUb29sICovXG4gICAgICAgIFtcImNvbnZlcnRUb1wiLCAuLi5lLmVuYWJsZWRJbmxpbmVUb29sc10ubWFwKCh0KSA9PiBbdCwgdGhpcy5pbmxpbmVUb29scy5nZXQodCldKVxuICAgICAgKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gZW5hYmxlZCBCbG9jayBUdW5lcyBmb3IgQmxvY2sgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCDigJQgQmxvY2sgVG9vbFxuICAgKi9cbiAgYXNzaWduQmxvY2tUdW5lc1RvQmxvY2tUb29sKGUpIHtcbiAgICBpZiAoZS5lbmFibGVkQmxvY2tUdW5lcyAhPT0gITEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUuZW5hYmxlZEJsb2NrVHVuZXMpKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgaihcbiAgICAgICAgICBlLmVuYWJsZWRCbG9ja1R1bmVzLm1hcCgobykgPT4gW28sIHRoaXMuYmxvY2tUdW5lcy5nZXQobyldKVxuICAgICAgICApO1xuICAgICAgICBlLnR1bmVzID0gbmV3IGooWy4uLnQsIC4uLnRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLnR1bmVzKSkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IGooXG4gICAgICAgICAgdGhpcy5jb25maWcudHVuZXMubWFwKChvKSA9PiBbbywgdGhpcy5ibG9ja1R1bmVzLmdldChvKV0pXG4gICAgICAgICk7XG4gICAgICAgIGUudHVuZXMgPSBuZXcgaihbLi4udCwgLi4udGhpcy5ibG9ja1R1bmVzLmludGVybmFsVG9vbHNdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS50dW5lcyA9IHRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgVG9vbHMgY29uZmlndXJhdGlvbiBvYmplY3RzIGFuZCB0aHJvdyBFcnJvciBmb3IgdXNlciBpZiBpdCBpcyBpbnZhbGlkXG4gICAqL1xuICB2YWxpZGF0ZVRvb2xzKCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLmNvbmZpZy50b29scylcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWcudG9vbHMsIGUpKSB7XG4gICAgICAgIGlmIChlIGluIHRoaXMuaW50ZXJuYWxUb29scylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbmZpZy50b29sc1tlXTtcbiAgICAgICAgaWYgKCFBKHQpICYmICFBKHQuY2xhc3MpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgYFRvb2wgwqske2V9wrsgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9uIGluIHRoZSDCq2NsYXNzwrsgcHJvcGVydHlgXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogVW5pZnkgdG9vbHMgY29uZmlnXG4gICAqL1xuICBwcmVwYXJlQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5jb25maWcudG9vbHMpXG4gICAgICBEKHRoaXMuY29uZmlnLnRvb2xzW3RdKSA/IGVbdF0gPSB0aGlzLmNvbmZpZy50b29sc1t0XSA6IGVbdF0gPSB7IGNsYXNzOiB0aGlzLmNvbmZpZy50b29sc1t0XSB9O1xuICAgIHJldHVybiBlO1xuICB9XG59XG5UYShbXG4gIG1lXG5dLCBXbi5wcm90b3R5cGUsIFwiZ2V0QWxsSW5saW5lVG9vbHNTYW5pdGl6ZUNvbmZpZ1wiLCAxKTtcbmNvbnN0IFNhID0gYDpyb290ey0tc2VsZWN0aW9uQ29sb3I6ICNlMWYyZmY7LS1pbmxpbmVTZWxlY3Rpb25Db2xvcjogI2Q0ZWNmZjstLWJnLWxpZ2h0OiAjZWZmMmY1Oy0tZ3JheVRleHQ6ICM3MDc2ODQ7LS1jb2xvci1kYXJrOiAjMUQyMDJCOy0tY29sb3ItYWN0aXZlLWljb246ICMzODhBRTU7LS1jb2xvci1ncmF5LWJvcmRlcjogcmdiYSgyMDEsIDIwMSwgMjA0LCAuNDgpOy0tY29udGVudC13aWR0aDogNjUwcHg7LS1uYXJyb3ctbW9kZS1yaWdodC1wYWRkaW5nOiA1MHB4Oy0tdG9vbGJveC1idXR0b25zLXNpemU6IDI2cHg7LS10b29sYm94LWJ1dHRvbnMtc2l6ZS0tbW9iaWxlOiAzNnB4Oy0taWNvbi1zaXplOiAyMHB4Oy0taWNvbi1zaXplLS1tb2JpbGU6IDI4cHg7LS1ibG9jay1wYWRkaW5nLXZlcnRpY2FsOiAuNGVtOy0tY29sb3ItbGluZS1ncmF5OiAjRUZGMEYxIH0uY29kZXgtZWRpdG9ye3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDt6LWluZGV4OjF9LmNvZGV4LWVkaXRvciAuaGlkZXtkaXNwbGF5Om5vbmV9LmNvZGV4LWVkaXRvcl9fcmVkYWN0b3IgW2NvbnRlbnRlZGl0YWJsZV06ZW1wdHk6YWZ0ZXJ7Y29udGVudDpcIlxcXFxmZWZmXCJ9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNvZGV4LWVkaXRvcl9fcmVkYWN0b3J7bWFyZ2luLXJpZ2h0OjUwcHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jb2RleC1lZGl0b3JfX3JlZGFjdG9ye21hcmdpbi1sZWZ0OjUwcHg7bWFyZ2luLXJpZ2h0OjB9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0Oi01cHh9fS5jb2RleC1lZGl0b3ItY29weWFibGV7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjFweDt3aWR0aDoxcHg7dG9wOi00MDAlO29wYWNpdHk6LjAwMX0uY29kZXgtZWRpdG9yLW92ZXJsYXl7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7ei1pbmRleDo5OTk7cG9pbnRlci1ldmVudHM6bm9uZTtvdmVyZmxvdzpoaWRkZW59LmNvZGV4LWVkaXRvci1vdmVybGF5X19jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7cG9pbnRlci1ldmVudHM6YXV0bzt6LWluZGV4OjB9LmNvZGV4LWVkaXRvci1vdmVybGF5X19yZWN0YW5nbGV7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiMyZWFhZGMzMztib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50fS5jb2RleC1lZGl0b3Igc3Zne21heC1oZWlnaHQ6MTAwJX0uY29kZXgtZWRpdG9yIHBhdGh7c3Ryb2tlOmN1cnJlbnRDb2xvcn0uY29kZXgtZWRpdG9yIDo6LW1vei1zZWxlY3Rpb257YmFja2dyb3VuZC1jb2xvcjojZDRlY2ZmfS5jb2RleC1lZGl0b3IgOjpzZWxlY3Rpb257YmFja2dyb3VuZC1jb2xvcjojZDRlY2ZmfS5jb2RleC1lZGl0b3ItLXRvb2xib3gtb3BlbmVkIFtjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06Zm9jdXM6YmVmb3Jle29wYWNpdHk6MCFpbXBvcnRhbnR9LmNlLXNjcm9sbC1sb2NrZWR7b3ZlcmZsb3c6aGlkZGVufS5jZS1zY3JvbGwtbG9ja2VkLS1oYXJke292ZXJmbG93OmhpZGRlbjt0b3A6Y2FsYygtMSAqIHZhcigtLXdpbmRvdy1zY3JvbGwtb2Zmc2V0KSk7cG9zaXRpb246Zml4ZWQ7d2lkdGg6MTAwJX0uY2UtdG9vbGJhcntwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2U7d2lsbC1jaGFuZ2U6b3BhY2l0eSx0b3A7ZGlzcGxheTpub25lfS5jZS10b29sYmFyLS1vcGVuZWR7ZGlzcGxheTpibG9ja30uY2UtdG9vbGJhcl9fY29udGVudHttYXgtd2lkdGg6NjUwcHg7bWFyZ2luOjAgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZX0uY2UtdG9vbGJhcl9fcGx1c3tjb2xvcjojMWQyMDJiO2N1cnNvcjpwb2ludGVyO3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7Ym9yZGVyLXJhZGl1czo3cHg7ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjB9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fcGx1c3t3aWR0aDozNnB4O2hlaWdodDozNnB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXRvb2xiYXJfX3BsdXM6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWZmMmY1fX0uY2UtdG9vbGJhcl9fcGx1cy0tYWN0aXZle2JhY2tncm91bmQtY29sb3I6I2VmZjJmNTstd2Via2l0LWFuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7YW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHM7YW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkc30uY2UtdG9vbGJhcl9fcGx1cy1zaG9ydGN1dHtvcGFjaXR5Oi42O3dvcmQtc3BhY2luZzotMnB4O21hcmdpbi10b3A6NXB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3BsdXN7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI0U4RThFQjstd2Via2l0LWJveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4IHJnYmEoMTMsMjAsMzMsLjEzKTtib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCAjMGQxNDIxMjE7Ym9yZGVyLXJhZGl1czo2cHg7ei1pbmRleDoyO3Bvc2l0aW9uOnN0YXRpY30uY2UtdG9vbGJhcl9fcGx1cy0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLXRvb2xiYXJfX3BsdXMtLXJpZ2h0LW9yaWVudGVkOmJlZm9yZXtsZWZ0OmF1dG87cmlnaHQ6MTVweDttYXJnaW4tbGVmdDowfX0uY2UtdG9vbGJhcl9fYWN0aW9uc3twb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxMDAlO29wYWNpdHk6MDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3BhZGRpbmctcmlnaHQ6NXB4fS5jZS10b29sYmFyX19hY3Rpb25zLS1vcGVuZWR7b3BhY2l0eToxfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX2FjdGlvbnN7cmlnaHQ6YXV0b319LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bntjb2xvcjojMWQyMDJiO3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7Ym9yZGVyLXJhZGl1czo3cHg7ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7bWFyZ2luLWxlZnQ6M3B4O2N1cnNvcjpwb2ludGVyO3VzZXItc2VsZWN0Om5vbmV9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tYWN0aXZle2JhY2tncm91bmQtY29sb3I6I2VmZjJmNTstd2Via2l0LWFuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7YW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHM7YW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkc31AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jZS10b29sYmFyX19zZXR0aW5ncy1idG57d2lkdGg6MjRweH19LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19zZXR0aW5ncy1idG57cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI0U4RThFQjstd2Via2l0LWJveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4IHJnYmEoMTMsMjAsMzMsLjEzKTtib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCAjMGQxNDIxMjE7Ym9yZGVyLXJhZGl1czo2cHg7ei1pbmRleDoyO3Bvc2l0aW9uOnN0YXRpY30uY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuLS1sZWZ0LW9yaWVudGVkOmJlZm9yZXtsZWZ0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH19LmNlLXRvb2xiYXJfX3BsdXMgc3ZnLC5jZS10b29sYmFyX19zZXR0aW5ncy1idG4gc3Zne3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHh9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNlLXRvb2xiYXJfX3BsdXN7bGVmdDo1cHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYm94IC5jZS1wb3BvdmVye3JpZ2h0OjA7bGVmdDphdXRvO2xlZnQ6aW5pdGlhbH19LmNlLWlubGluZS10b29sYmFyey0teS1vZmZzZXQ6IDhweDstLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmU6IHJnYmEoNTYsIDEzOCwgMjI5LCAuMSk7LS1jb2xvci10ZXh0LWljb24tYWN0aXZlOiAjMzg4QUU1Oy0tY29sb3ItdGV4dC1wcmltYXJ5OiBibGFjaztwb3NpdGlvbjphYnNvbHV0ZTt2aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2U7dHJhbnNpdGlvbjpvcGFjaXR5IC4yNXMgZWFzZTt3aWxsLWNoYW5nZTpvcGFjaXR5LGxlZnQsdG9wO3RvcDowO2xlZnQ6MDt6LWluZGV4OjM7b3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZX0uY2UtaW5saW5lLXRvb2xiYXIgW2hpZGRlbl17ZGlzcGxheTpub25lIWltcG9ydGFudH0uY2UtaW5saW5lLXRvb2xiYXJfX3RvZ2dsZXItYW5kLWJ1dHRvbi13cmFwcGVye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTtwYWRkaW5nOjAgNnB4fS5jZS1pbmxpbmUtdG9vbGJhcl9fYnV0dG9uc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd257ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjZweDttYXJnaW46MCA2cHggMCAtNnB4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2N1cnNvcjpwb2ludGVyO2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bjpob3ZlcntiYWNrZ3JvdW5kOiNlZmYyZjV9fS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1jb250ZW50LC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tYXJyb3d7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleH0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWNvbnRlbnQgc3ZnLC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tYXJyb3cgc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9LmNlLWlubGluZS10b29sYmFyX19zaG9ydGN1dHtvcGFjaXR5Oi42O3dvcmQtc3BhY2luZzotM3B4O21hcmdpbi10b3A6M3B4fS5jZS1pbmxpbmUtdG9vbHtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXByaW1hcnkpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtib3JkZXI6MDtib3JkZXItcmFkaXVzOjRweDtsaW5lLWhlaWdodDpub3JtYWw7aGVpZ2h0OjEwMCU7cGFkZGluZzowO3dpZHRoOjI4cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtjdXJzb3I6cG9pbnRlcn1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1pbmxpbmUtdG9vbHt3aWR0aDozNnB4O2hlaWdodDozNnB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLWlubGluZS10b29sOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2Y4ZjhmOH19LmNlLWlubGluZS10b29sIHN2Z3tkaXNwbGF5OmJsb2NrO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2wgc3Zne3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9fS5jZS1pbmxpbmUtdG9vbC0tbGluayAuaWNvbi0tdW5saW5rLC5jZS1pbmxpbmUtdG9vbC0tdW5saW5rIC5pY29uLS1saW5re2Rpc3BsYXk6bm9uZX0uY2UtaW5saW5lLXRvb2wtLXVubGluayAuaWNvbi0tdW5saW5re2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1ib3R0b206LTFweH0uY2UtaW5saW5lLXRvb2wtaW5wdXR7YmFja2dyb3VuZDojRjhGOEY4O2JvcmRlcjoxcHggc29saWQgcmdiYSgyMjYsMjI2LDIyOSwuMik7Ym9yZGVyLXJhZGl1czo2cHg7cGFkZGluZzo0cHggOHB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIycHg7b3V0bGluZTpub25lO21hcmdpbjowO3dpZHRoOjEwMCU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6bm9uZTtmb250LXdlaWdodDo1MDA7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7Zm9udC1mYW1pbHk6aW5oZXJpdH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1pbmxpbmUtdG9vbC1pbnB1dHtmb250LXNpemU6MTVweDtmb250LXdlaWdodDo1MDB9fS5jZS1pbmxpbmUtdG9vbC1pbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0fS5jZS1pbmxpbmUtdG9vbC1pbnB1dDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0fS5jZS1pbmxpbmUtdG9vbC1pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0fS5jZS1pbmxpbmUtdG9vbC1pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQtLXNob3dlZHtkaXNwbGF5OmJsb2NrfS5jZS1pbmxpbmUtdG9vbC0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZSk7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZSl9QC13ZWJraXQta2V5ZnJhbWVzIGZhZGUtaW57MCV7b3BhY2l0eTowfXRve29wYWNpdHk6MX19QGtleWZyYW1lcyBmYWRlLWluezAle29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fS5jZS1ibG9ja3std2Via2l0LWFuaW1hdGlvbjpmYWRlLWluIC4zcyBlYXNlO2FuaW1hdGlvbjpmYWRlLWluIC4zcyBlYXNlOy13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTpub25lO2FuaW1hdGlvbi1maWxsLW1vZGU6bm9uZTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6aW5pdGlhbDthbmltYXRpb24tZmlsbC1tb2RlOmluaXRpYWx9LmNlLWJsb2NrOmZpcnN0LW9mLXR5cGV7bWFyZ2luLXRvcDowfS5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50e2JhY2tncm91bmQ6I2UxZjJmZn0uY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudCBbY29udGVudGVkaXRhYmxlXXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnQgaW1nLC5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50IC5jZS1zdHVie29wYWNpdHk6LjU1fS5jZS1ibG9jay0tc3RyZXRjaGVkIC5jZS1ibG9ja19fY29udGVudHttYXgtd2lkdGg6bm9uZX0uY2UtYmxvY2tfX2NvbnRlbnR7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjY1MHB4O21hcmdpbjowIGF1dG87LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMTVzIGVhc2V9LmNlLWJsb2NrLS1kcm9wLXRhcmdldCAuY2UtYmxvY2tfX2NvbnRlbnQ6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0Oi0yMHB4O21hcmdpbi10b3A6LTFweDtoZWlnaHQ6OHB4O3dpZHRoOjhweDtib3JkZXI6c29saWQgIzM4OEFFNTtib3JkZXItd2lkdGg6MXB4IDFweCAwIDA7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0O3RyYW5zZm9ybS1vcmlnaW46cmlnaHQ7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uY2UtYmxvY2stLWRyb3AtdGFyZ2V0IC5jZS1ibG9ja19fY29udGVudDphZnRlcntjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7aGVpZ2h0OjFweDt3aWR0aDoxMDAlO2NvbG9yOiMzODhhZTU7YmFja2dyb3VuZDpyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KDkwZGVnLCMzODhBRTUsIzM4OEFFNSAxcHgsI2ZmZiAxcHgsI2ZmZiA2cHgpfS5jZS1ibG9jayBhe2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5jZS1ibG9jayBie2ZvbnQtd2VpZ2h0OjcwMH0uY2UtYmxvY2sgaXtmb250LXN0eWxlOml0YWxpY31ALXdlYmtpdC1rZXlmcmFtZXMgYm91bmNlSW57MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpO3RyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KX0yMCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1Aa2V5ZnJhbWVzIGJvdW5jZUluezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX0wJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KTt0cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSl9MjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QC13ZWJraXQta2V5ZnJhbWVzIHNlbGVjdGlvbkJvdW5jZXswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKX03MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QGtleWZyYW1lcyBzZWxlY3Rpb25Cb3VuY2V7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSl9NzAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUAtd2Via2l0LWtleWZyYW1lcyBidXR0b25DbGlja2VkezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX0wJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KTt0cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKX04MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QGtleWZyYW1lcyBidXR0b25DbGlja2VkezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX0wJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KTt0cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKX04MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19LmNkeC1ibG9ja3twYWRkaW5nOi40ZW0gMH0uY2R4LWJsb2NrOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2xpbmUtaGVpZ2h0Om5vcm1hbCFpbXBvcnRhbnR9LmNkeC1pbnB1dHtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4IDAgcmdiYSgzNSw0NCw3MiwuMDYpO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4ICMyMzJjNDgwZjtib3JkZXItcmFkaXVzOjNweDtwYWRkaW5nOjEwcHggMTJweDtvdXRsaW5lOm5vbmU7d2lkdGg6MTAwJTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmNkeC1pbnB1dFtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7cG9zaXRpb246c3RhdGljIWltcG9ydGFudH0uY2R4LWlucHV0W2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowO3doaXRlLXNwYWNlOm5vd3JhcDtwb2ludGVyLWV2ZW50czpub25lfS5jZHgtc2V0dGluZ3MtYnV0dG9ue2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt2ZXJ0aWNhbC1hbGlnbjpib3R0b207Y29sb3I6aW5oZXJpdDttYXJnaW46MDttaW4td2lkdGg6MjZweDttaW4taGVpZ2h0OjI2cHh9LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7YmFja2dyb3VuZDpyZ2JhKDM0LDE4NiwyNTUsLjA4KSFpbXBvcnRhbnR9LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHJnYmEoNywxNjEsMjI3LC4wOCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggIzA3YTFlMzE0fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2VkLWFuaW1hdGVkey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDthbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkOy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOi4yNXM7YW5pbWF0aW9uLWR1cmF0aW9uOi4yNXN9LmNkeC1zZXR0aW5ncy1idXR0b24tLWFjdGl2ZXtjb2xvcjojMzg4YWU1fS5jZHgtc2V0dGluZ3MtYnV0dG9uIHN2Z3t3aWR0aDphdXRvO2hlaWdodDphdXRvfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNkeC1zZXR0aW5ncy1idXR0b24gc3Zne3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNkeC1zZXR0aW5ncy1idXR0b257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtc2V0dGluZ3MtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNkeC1sb2FkZXJ7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCl9LmNkeC1sb2FkZXI6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3dpZHRoOjE4cHg7aGVpZ2h0OjE4cHg7bWFyZ2luOi0xMXB4IDAgMCAtMTFweDtib3JkZXI6MnB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtib3JkZXItbGVmdC1jb2xvcjojMzg4YWU1O2JvcmRlci1yYWRpdXM6NTAlOy13ZWJraXQtYW5pbWF0aW9uOmNkeFJvdGF0aW9uIDEuMnMgaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjpjZHhSb3RhdGlvbiAxLjJzIGluZmluaXRlIGxpbmVhcn1ALXdlYmtpdC1rZXlmcmFtZXMgY2R4Um90YXRpb257MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGNkeFJvdGF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmNkeC1idXR0b257cGFkZGluZzoxM3B4O2JvcmRlci1yYWRpdXM6M3B4O2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO2ZvbnQtc2l6ZToxNC45cHg7YmFja2dyb3VuZDojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDJweCAycHggMCByZ2JhKDE4LDMwLDU3LC4wNCk7Ym94LXNoYWRvdzowIDJweCAycHggIzEyMWUzOTBhO2NvbG9yOiM3MDc2ODQ7dGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6I0ZCRkNGRTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggM3B4IDAgcmdiYSgxOCwzMCw1NywuMDgpO2JveC1zaGFkb3c6MCAxcHggM3B4ICMxMjFlMzkxNH19LmNkeC1idXR0b24gc3Zne2hlaWdodDoyMHB4O21hcmdpbi1yaWdodDouMmVtO21hcmdpbi10b3A6LTJweH0uY2Utc3R1YntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmc6MTJweCAxOHB4O21hcmdpbjoxMHB4IDA7Ym9yZGVyLXJhZGl1czoxMHB4O2JhY2tncm91bmQ6I2VmZjJmNTtib3JkZXI6MXB4IHNvbGlkICNFRkYwRjE7Y29sb3I6IzcwNzY4NDtmb250LXNpemU6MTRweH0uY2Utc3R1YiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH0uY2Utc3R1Yl9faW5mb3ttYXJnaW4tbGVmdDoxNHB4fS5jZS1zdHViX190aXRsZXtmb250LXdlaWdodDo1MDA7dGV4dC10cmFuc2Zvcm06Y2FwaXRhbGl6ZX0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRse2RpcmVjdGlvbjpydGx9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2R4LWxpc3R7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDo0MHB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX3BsdXN7cmlnaHQ6LTI2cHg7bGVmdDphdXRvfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7cmlnaHQ6YXV0bztsZWZ0Oi0yNnB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtdG9vbGJhcl9fYWN0aW9uc3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDphdXRvO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTBweH19LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3N7bGVmdDo1cHg7cmlnaHQ6YXV0b30uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1zZXR0aW5nczpiZWZvcmV7cmlnaHQ6YXV0bztsZWZ0OjI1cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3NfX2J1dHRvbjpub3QoOm50aC1jaGlsZCgzbiszKSl7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi1yaWdodDowfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLWNvbnZlcnNpb24tdG9vbF9faWNvbnttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDoxMHB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bntib3JkZXItcmlnaHQ6MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7bWFyZ2luOjAgLTZweCAwIDZweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24gLmljb24tLXRvZ2dsZXItZG93bnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDo0cHh9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX3BsdXN7bGVmdDowO3JpZ2h0OjVweH19QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7bGVmdDotNXB4fX0uY2R4LXNlYXJjaC1maWVsZHstLWljb24tbWFyZ2luLXJpZ2h0OiAxMHB4O2JhY2tncm91bmQ6I0Y4RjhGODtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjI2LDIyNiwyMjksLjIpO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6MnB4O2Rpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBhdXRvIDFmcjtncmlkLXRlbXBsYXRlLXJvd3M6YXV0b30uY2R4LXNlYXJjaC1maWVsZF9faWNvbnt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW4tcmlnaHQ6dmFyKC0taWNvbi1tYXJnaW4tcmlnaHQpfS5jZHgtc2VhcmNoLWZpZWxkX19pY29uIHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2NvbG9yOiM3MDc2ODR9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0e2ZvbnQtc2l6ZToxNHB4O291dGxpbmU6bm9uZTtmb250LXdlaWdodDo1MDA7Zm9udC1mYW1pbHk6aW5oZXJpdDtib3JkZXI6MDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O21hcmdpbjowO3BhZGRpbmc6MDtsaW5lLWhlaWdodDoyMnB4O21pbi13aWR0aDpjYWxjKDEwMCUgLSAyNnB4IC0gdmFyKC0taWNvbi1tYXJnaW4tcmlnaHQpKX0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0OjotbW96LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0OjpwbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2UtcG9wb3ZlcnstLWJvcmRlci1yYWRpdXM6IDZweDstLXdpZHRoOiAyMDBweDstLW1heC1oZWlnaHQ6IDI3MHB4Oy0tcGFkZGluZzogNnB4Oy0tb2Zmc2V0LWZyb20tdGFyZ2V0OiA4cHg7LS1jb2xvci1ib3JkZXI6ICNFRkYwRjE7LS1jb2xvci1zaGFkb3c6IHJnYmEoMTMsIDIwLCAzMywgLjEpOy0tY29sb3ItYmFja2dyb3VuZDogd2hpdGU7LS1jb2xvci10ZXh0LXByaW1hcnk6IGJsYWNrOy0tY29sb3ItdGV4dC1zZWNvbmRhcnk6ICM3MDc2ODQ7LS1jb2xvci1ib3JkZXItaWNvbjogcmdiYSgyMDEsIDIwMSwgMjA0LCAuNDgpOy0tY29sb3ItYm9yZGVyLWljb24tZGlzYWJsZWQ6ICNFRkYwRjE7LS1jb2xvci10ZXh0LWljb24tYWN0aXZlOiAjMzg4QUU1Oy0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZTogcmdiYSg1NiwgMTM4LCAyMjksIC4xKTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1mb2N1czogcmdiYSgzNCwgMTg2LCAyNTUsIC4wOCk7LS1jb2xvci1zaGFkb3ctaXRlbS1mb2N1czogcmdiYSg3LCAxNjEsIDIyNywgLjA4KTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1ob3ZlcjogI0Y4RjhGODstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtOiAjRTI0QTRBOy0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0taG92ZXI6ICNDRTQzNDM7LS1wb3BvdmVyLXRvcDogY2FsYygxMDAlICsgdmFyKC0tb2Zmc2V0LWZyb20tdGFyZ2V0KSk7LS1wb3BvdmVyLWxlZnQ6IDA7LS1uZXN0ZWQtcG9wb3Zlci1vdmVybGFwOiA0cHg7LS1pY29uLXNpemU6IDIwcHg7LS1pdGVtLXBhZGRpbmc6IDNweDstLWl0ZW0taGVpZ2h0OiBjYWxjKHZhcigtLWljb24tc2l6ZSkgKyAyICogdmFyKC0taXRlbS1wYWRkaW5nKSl9LmNlLXBvcG92ZXJfX2NvbnRhaW5lcnttaW4td2lkdGg6dmFyKC0td2lkdGgpO3dpZHRoOnZhcigtLXdpZHRoKTttYXgtaGVpZ2h0OnZhcigtLW1heC1oZWlnaHQpO2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWJveC1zaGFkb3c6MHB4IDNweCAxNXB4IC0zcHggdmFyKC0tY29sb3Itc2hhZG93KTtib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCB2YXIoLS1jb2xvci1zaGFkb3cpO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6dmFyKC0tcG9wb3Zlci1sZWZ0KTt0b3A6dmFyKC0tcG9wb3Zlci10b3ApO2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZCk7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt6LWluZGV4OjQ7b3BhY2l0eTowO21heC1oZWlnaHQ6MDtwb2ludGVyLWV2ZW50czpub25lO3BhZGRpbmc6MDtib3JkZXI6bm9uZX0uY2UtcG9wb3Zlci0tb3BlbmVkPi5jZS1wb3BvdmVyX19jb250YWluZXJ7b3BhY2l0eToxO3BhZGRpbmc6dmFyKC0tcGFkZGluZyk7bWF4LWhlaWdodDp2YXIoLS1tYXgtaGVpZ2h0KTtwb2ludGVyLWV2ZW50czphdXRvOy13ZWJraXQtYW5pbWF0aW9uOnBhbmVsU2hvd2luZyAuMXMgZWFzZTthbmltYXRpb246cGFuZWxTaG93aW5nIC4xcyBlYXNlO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLS1vcGVuZWQ+LmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstd2Via2l0LWFuaW1hdGlvbjpwYW5lbFNob3dpbmdNb2JpbGUgLjI1cyBlYXNlO2FuaW1hdGlvbjpwYW5lbFNob3dpbmdNb2JpbGUgLjI1cyBlYXNlfX0uY2UtcG9wb3Zlci0tb3Blbi10b3AgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstLXBvcG92ZXItdG9wOiBjYWxjKC0xICogKHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkgKyB2YXIoLS1wb3BvdmVyLWhlaWdodCkpKX0uY2UtcG9wb3Zlci0tb3Blbi1sZWZ0IC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLWxlZnQ6IGNhbGMoLTEgKiB2YXIoLS13aWR0aCkgKyAxMDAlKX0uY2UtcG9wb3Zlcl9faXRlbXN7b3ZlcmZsb3cteTphdXRvOy1tcy1zY3JvbGwtY2hhaW5pbmc6bm9uZTtvdmVyc2Nyb2xsLWJlaGF2aW9yOmNvbnRhaW59QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlcl9fb3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt0b3A6MDtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDtiYWNrZ3JvdW5kOiMxRDIwMkI7ei1pbmRleDozO29wYWNpdHk6LjU7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjEycyBlYXNlLWluO3RyYW5zaXRpb246b3BhY2l0eSAuMTJzIGVhc2UtaW47d2lsbC1jaGFuZ2U6b3BhY2l0eTt2aXNpYmlsaXR5OnZpc2libGV9fS5jZS1wb3BvdmVyX19vdmVybGF5LS1oaWRkZW57ZGlzcGxheTpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXIgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstLW9mZnNldDogNXB4O3Bvc2l0aW9uOmZpeGVkO21heC13aWR0aDpub25lO21pbi13aWR0aDpjYWxjKDEwMCUgLSB2YXIoLS1vZmZzZXQpICogMik7bGVmdDp2YXIoLS1vZmZzZXQpO3JpZ2h0OnZhcigtLW9mZnNldCk7Ym90dG9tOmNhbGModmFyKC0tb2Zmc2V0KSArIGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKSk7dG9wOmF1dG87Ym9yZGVyLXJhZGl1czoxMHB4fX0uY2UtcG9wb3Zlcl9fc2VhcmNoe21hcmdpbi1ib3R0b206NXB4fS5jZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2V7Y29sb3I6IzcwNzY4NDtkaXNwbGF5Om5vbmU7Y3Vyc29yOmRlZmF1bHQ7cGFkZGluZzozcHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjBweDtmb250LXdlaWdodDo1MDA7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5jZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2UtLWRpc3BsYXllZHtkaXNwbGF5OmJsb2NrfS5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstLXBvcG92ZXItbGVmdDogY2FsYyh2YXIoLS1uZXN0aW5nLWxldmVsKSAqICh2YXIoLS13aWR0aCkgLSB2YXIoLS1uZXN0ZWQtcG9wb3Zlci1vdmVybGFwKSkpO3RvcDpjYWxjKHZhcigtLXRyaWdnZXItaXRlbS10b3ApIC0gdmFyKC0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcCkpO3Bvc2l0aW9uOmFic29sdXRlfS5jZS1wb3BvdmVyLS1vcGVuLXRvcC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnt0b3A6Y2FsYyh2YXIoLS10cmlnZ2VyLWl0ZW0tdG9wKSAtIHZhcigtLXBvcG92ZXItaGVpZ2h0KSArIHZhcigtLWl0ZW0taGVpZ2h0KSArIHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkgKyB2YXIoLS1uZXN0ZWQtcG9wb3Zlci1vdmVybGFwKSl9LmNlLXBvcG92ZXItLW9wZW4tbGVmdCAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLWxlZnQ6IGNhbGMoLTEgKiAodmFyKC0tbmVzdGluZy1sZXZlbCkgKyAxKSAqIHZhcigtLXdpZHRoKSArIDEwMCUpfS5jZS1wb3BvdmVyLWl0ZW0tc2VwYXJhdG9ye3BhZGRpbmc6NHB4IDNweH0uY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvci0taGlkZGVue2Rpc3BsYXk6bm9uZX0uY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcl9fbGluZXtoZWlnaHQ6MXB4O2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYm9yZGVyKTt3aWR0aDoxMDAlfS5jZS1wb3BvdmVyLWl0ZW0taHRtbC0taGlkZGVue2Rpc3BsYXk6bm9uZX0uY2UtcG9wb3Zlci1pdGVtey0tYm9yZGVyLXJhZGl1czogNnB4O2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOnZhcigtLWl0ZW0tcGFkZGluZyk7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW17cGFkZGluZzo0cHh9fS5jZS1wb3BvdmVyLWl0ZW06bm90KDpsYXN0LW9mLXR5cGUpe21hcmdpbi1ib3R0b206MXB4fS5jZS1wb3BvdmVyLWl0ZW1fX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmNlLXBvcG92ZXItaXRlbV9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX2ljb257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH0uY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtcG9wb3Zlci1pdGVtX19pY29uLS10b29se21hcmdpbi1yaWdodDo0cHh9LmNlLXBvcG92ZXItaXRlbV9fdGl0bGV7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjBweDtmb250LXdlaWdodDo1MDA7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO21hcmdpbi1yaWdodDphdXRvfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItaXRlbV9fdGl0bGV7Zm9udC1zaXplOjE2cHh9fS5jZS1wb3BvdmVyLWl0ZW1fX3NlY29uZGFyeS10aXRsZXtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSk7Zm9udC1zaXplOjEycHg7d2hpdGUtc3BhY2U6bm93cmFwO2xldHRlci1zcGFjaW5nOi0uMWVtO3BhZGRpbmctcmlnaHQ6NXB4O29wYWNpdHk6LjZ9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVtX19zZWNvbmRhcnktdGl0bGV7ZGlzcGxheTpub25lfX0uY2UtcG9wb3Zlci1pdGVtLS1hY3RpdmV7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWljb24tYWN0aXZlKTtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LWljb24tYWN0aXZlKX0uY2UtcG9wb3Zlci1pdGVtLS1kaXNhYmxlZHtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSk7Y3Vyc29yOmRlZmF1bHQ7cG9pbnRlci1ldmVudHM6bm9uZX0uY2UtcG9wb3Zlci1pdGVtLS1mb2N1c2VkOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1mb2N1cyl7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tZm9jdXMpIWltcG9ydGFudH0uY2UtcG9wb3Zlci1pdGVtLS1oaWRkZW57ZGlzcGxheTpub25lfUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2UtcG9wb3Zlci1pdGVtOmhvdmVye2N1cnNvcjpwb2ludGVyfS5jZS1wb3BvdmVyLWl0ZW06aG92ZXI6bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWhvdmVyKXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1ob3Zlcil9fS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbntiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtKX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb24gLmNlLXBvcG92ZXItaXRlbV9fdGl0bGUsLmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb257Y29sb3I6I2ZmZn1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1ob3Zlcik6aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3Zlcil9fS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbjpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8tZm9jdXMpLmNlLXBvcG92ZXItaXRlbS0tZm9jdXNlZHtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtLWhvdmVyKSFpbXBvcnRhbnR9QC13ZWJraXQta2V5ZnJhbWVzIHBhbmVsU2hvd2luZ3swJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19QGtleWZyYW1lcyBwYW5lbFNob3dpbmd7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fUAtd2Via2l0LWtleWZyYW1lcyBwYW5lbFNob3dpbmdNb2JpbGV7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX1Aa2V5ZnJhbWVzIHBhbmVsU2hvd2luZ01vYmlsZXswJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fS53b2JibGV7LXdlYmtpdC1hbmltYXRpb24tbmFtZTp3b2JibGU7YW5pbWF0aW9uLW5hbWU6d29iYmxlOy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOi40czthbmltYXRpb24tZHVyYXRpb246LjRzfUAtd2Via2l0LWtleWZyYW1lcyB3b2JibGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfTE1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCl9MzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCl9NDUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKX03NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX19QGtleWZyYW1lcyB3b2JibGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfTE1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCl9MzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCl9NDUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKX03NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX19LmNlLXBvcG92ZXItaGVhZGVye21hcmdpbi1ib3R0b206OHB4O21hcmdpbi10b3A6NHB4O2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmNlLXBvcG92ZXItaGVhZGVyX190ZXh0e2ZvbnQtc2l6ZToxOHB4O2ZvbnQtd2VpZ2h0OjYwMH0uY2UtcG9wb3Zlci1oZWFkZXJfX2JhY2stYnV0dG9ue2JvcmRlcjowO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXByaW1hcnkpfS5jZS1wb3BvdmVyLWhlYWRlcl9fYmFjay1idXR0b24gc3Zne2Rpc3BsYXk6YmxvY2s7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH0uY2UtcG9wb3Zlci0taW5saW5ley0taGVpZ2h0OiAzOHB4Oy0taGVpZ2h0LW1vYmlsZTogNDZweDstLWNvbnRhaW5lci1wYWRkaW5nOiA0cHg7cG9zaXRpb246cmVsYXRpdmV9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnR7bWFyZ2luLWJvdHRvbTowfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2l0ZW1ze2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3c7cGFkZGluZzp2YXIoLS1jb250YWluZXItcGFkZGluZyk7aGVpZ2h0OnZhcigtLWhlaWdodCk7dG9wOjA7bWluLXdpZHRoOi13ZWJraXQtbWF4LWNvbnRlbnQ7bWluLXdpZHRoOi1tb3otbWF4LWNvbnRlbnQ7bWluLXdpZHRoOm1heC1jb250ZW50O3dpZHRoOi13ZWJraXQtbWF4LWNvbnRlbnQ7d2lkdGg6LW1vei1tYXgtY29udGVudDt3aWR0aDptYXgtY29udGVudDstd2Via2l0LWFuaW1hdGlvbjpub25lO2FuaW1hdGlvbjpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlcl9fY29udGFpbmVye2hlaWdodDp2YXIoLS1oZWlnaHQtbW9iaWxlKTtwb3NpdGlvbjphYnNvbHV0ZX19LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcntwYWRkaW5nOjAgNHB4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3JfX2xpbmV7aGVpZ2h0OjEwMCU7d2lkdGg6MXB4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbXtib3JkZXItcmFkaXVzOjRweDtwYWRkaW5nOjRweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24tLXRvb2x7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7bWFyZ2luLXJpZ2h0OjB9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOmF1dG87d2lkdGg6aW5pdGlhbDtoZWlnaHQ6YXV0bztoZWlnaHQ6aW5pdGlhbH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24gc3Zne3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbTpub3QoOmxhc3Qtb2YtdHlwZSl7bWFyZ2luLWJvdHRvbTowO21hcmdpbi1ib3R0b206aW5pdGlhbH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW0taHRtbHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbV9faWNvbi0tY2hldnJvbi1yaWdodHstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZC1sZXZlbC0xIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1vZmZzZXQ6IDNweDtsZWZ0OjA7dG9wOmNhbGModmFyKC0taGVpZ2h0KSArIHZhcigtLW9mZnNldCkpfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkLWxldmVsLTEgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnt0b3A6Y2FsYyh2YXIoLS1oZWlnaHQtbW9iaWxlKSArIHZhcigtLW9mZnNldCkpfX0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnttaW4td2lkdGg6dmFyKC0td2lkdGgpO3dpZHRoOnZhcigtLXdpZHRoKTtoZWlnaHQ6LXdlYmtpdC1maXQtY29udGVudDtoZWlnaHQ6LW1vei1maXQtY29udGVudDtoZWlnaHQ6Zml0LWNvbnRlbnQ7cGFkZGluZzo2cHg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19pdGVtc3tkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCV9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW17Ym9yZGVyLXJhZGl1czo2cHg7cGFkZGluZzozcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXItaXRlbXtwYWRkaW5nOjRweH19LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24tLXRvb2x7bWFyZ2luLXJpZ2h0OjRweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXItaXRlbV9faWNvbnt3aWR0aDoyNnB4O2hlaWdodDoyNnB4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcntwYWRkaW5nOjRweCAzcHh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW0tc2VwYXJhdG9yX19saW5le3dpZHRoOjEwMCU7aGVpZ2h0OjFweH0uY29kZXgtZWRpdG9yIFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmUsLmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlcl1bZGF0YS1lbXB0eT10cnVlXTpiZWZvcmV7cG9pbnRlci1ldmVudHM6bm9uZTtjb2xvcjojNzA3Njg0O2N1cnNvcjp0ZXh0O2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyKX0uY29kZXgtZWRpdG9yIFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV06ZW1wdHk6YmVmb3JlLC5jb2RleC1lZGl0b3IgW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXVtkYXRhLWVtcHR5PXRydWVdOmJlZm9yZXtwb2ludGVyLWV2ZW50czpub25lO2NvbG9yOiM3MDc2ODQ7Y3Vyc29yOnRleHR9LmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdOmVtcHR5OmZvY3VzOmJlZm9yZSwuY29kZXgtZWRpdG9yIFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV1bZGF0YS1lbXB0eT10cnVlXTpmb2N1czpiZWZvcmV7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXItYWN0aXZlKX1cbmA7XG5jbGFzcyBJYSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzTW9iaWxlID0gITEsIHRoaXMuY29udGVudFJlY3RDYWNoZSA9IG51bGwsIHRoaXMucmVzaXplRGVib3VuY2VyID0gRW8oKCkgPT4ge1xuICAgICAgdGhpcy53aW5kb3dSZXNpemUoKTtcbiAgICB9LCAyMDApLCB0aGlzLnNlbGVjdGlvbkNoYW5nZURlYm91bmNlZCA9IEVvKCgpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgIH0sIGRhKSwgdGhpcy5kb2N1bWVudFRvdWNoZWRMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50VG91Y2hlZChlKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFZGl0b3IuanMgVUkgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHt7ZWRpdG9yV3JhcHBlcjogc3RyaW5nLCBlZGl0b3Jab25lOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yV3JhcHBlcjogXCJjb2RleC1lZGl0b3JcIixcbiAgICAgIGVkaXRvcldyYXBwZXJOYXJyb3c6IFwiY29kZXgtZWRpdG9yLS1uYXJyb3dcIixcbiAgICAgIGVkaXRvclpvbmU6IFwiY29kZXgtZWRpdG9yX19yZWRhY3RvclwiLFxuICAgICAgZWRpdG9yWm9uZUhpZGRlbjogXCJjb2RleC1lZGl0b3JfX3JlZGFjdG9yLS1oaWRkZW5cIixcbiAgICAgIGVkaXRvckVtcHR5OiBcImNvZGV4LWVkaXRvci0tZW1wdHlcIixcbiAgICAgIGVkaXRvclJ0bEZpeDogXCJjb2RleC1lZGl0b3ItLXJ0bFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFdpZHRoIG9mIGNlbnRlciBjb2x1bW4gb2YgRWRpdG9yXG4gICAqXG4gICAqIEByZXR1cm5zIHtET01SZWN0fVxuICAgKi9cbiAgZ2V0IGNvbnRlbnRSZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnRSZWN0Q2FjaGUgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50UmVjdENhY2hlO1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLndyYXBwZXIucXVlcnlTZWxlY3RvcihgLiR7Ui5DU1MuY29udGVudH1gKTtcbiAgICByZXR1cm4gZSA/ICh0aGlzLmNvbnRlbnRSZWN0Q2FjaGUgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmNvbnRlbnRSZWN0Q2FjaGUpIDoge1xuICAgICAgd2lkdGg6IDY1MCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ha2luZyBtYWluIGludGVyZmFjZVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICB0aGlzLnNldElzTW9iaWxlKCksIHRoaXMubWFrZSgpLCB0aGlzLmxvYWRTdHlsZXMoKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIHJlYWQtb25seSBzdGF0ZVxuICAgKlxuICAgKiBJZiByZWFkT25seSBpcyB0cnVlOlxuICAgKiAgLSByZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBtYWluIFVJIG1vZHVsZSBlbGVtZW50c1xuICAgKlxuICAgKiBpZiByZWFkT25seSBpcyBmYWxzZTpcbiAgICogIC0gZW5hYmxlcyBhbGwgbGlzdGVuZXJzIHRvIFVJIG1vZHVsZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIFwicmVhZCBvbmx5XCIgc3RhdGVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gdGhpcy51bmJpbmRSZWFkT25seVNlbnNpdGl2ZUxpc3RlbmVycygpIDogd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5iaW5kUmVhZE9ubHlTZW5zaXRpdmVMaXN0ZW5lcnMoKTtcbiAgICB9LCB7XG4gICAgICB0aW1lb3V0OiAyZTNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgRWRpdG9yIGlzIGVtcHR5IGFuZCBzZXQgQ1NTIGNsYXNzIHRvIHdyYXBwZXJcbiAgICovXG4gIGNoZWNrRW1wdGluZXNzKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLkNTUy5lZGl0b3JFbXB0eSwgZS5pc0VkaXRvckVtcHR5KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgb25lIG9mIFRvb2xiYXIgaXMgb3BlbmVkXG4gICAqIFVzZWQgdG8gcHJldmVudCBnbG9iYWwga2V5ZG93bnMgKGZvciBleGFtcGxlLCBFbnRlcikgY29uZmxpY3RzIHdpdGggRW50ZXItb24tdG9vbGJhclxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzb21lVG9vbGJhck9wZW5lZCgpIHtcbiAgICBjb25zdCB7IFRvb2xiYXI6IGUsIEJsb2NrU2V0dGluZ3M6IHQsIElubGluZVRvb2xiYXI6IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIHJldHVybiAhISh0Lm9wZW5lZCB8fCBvLm9wZW5lZCB8fCBlLnRvb2xib3gub3BlbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgZm9yIHNvbWUgRmxpcHBlci1idXR0b25zIGlzIHVuZGVyIGZvY3VzXG4gICAqL1xuICBnZXQgc29tZUZsaXBwZXJCdXR0b25Gb2N1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3guaGFzRm9jdXMoKSA/ICEwIDogT2JqZWN0LmVudHJpZXModGhpcy5FZGl0b3IpLmZpbHRlcigoW2UsIHRdKSA9PiB0LmZsaXBwZXIgaW5zdGFuY2VvZiBjZSkuc29tZSgoW2UsIHRdKSA9PiB0LmZsaXBwZXIuaGFzRm9jdXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIGVkaXRvcmBzIFVJXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm9kZXMuaG9sZGVyLmlubmVySFRNTCA9IFwiXCIsIHRoaXMudW5iaW5kUmVhZE9ubHlJbnNlbnNpdGl2ZUxpc3RlbmVycygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBhbGwgRWRpdG9yJ3MgdG9vbGJhcnNcbiAgICovXG4gIGNsb3NlQWxsVG9vbGJhcnMoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmNsb3NlKCksIG8uY2xvc2UoKSwgZS50b29sYm94LmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBtb2JpbGUgbW9kZSBhbmQgc2F2ZSB0aGUgcmVzdWx0XG4gICAqL1xuICBzZXRJc01vYmlsZSgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmlubmVyV2lkdGggPCBSbztcbiAgICBlICE9PSB0aGlzLmlzTW9iaWxlICYmIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KFRlLCB7XG4gICAgICBpc0VuYWJsZWQ6IHRoaXMuaXNNb2JpbGVcbiAgICB9KSwgdGhpcy5pc01vYmlsZSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIEVkaXRvci5qcyBpbnRlcmZhY2VcbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy5ob2xkZXIgPSBkLmdldEhvbGRlcih0aGlzLmNvbmZpZy5ob2xkZXIpLCB0aGlzLm5vZGVzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgdGhpcy5DU1MuZWRpdG9yV3JhcHBlcixcbiAgICAgIC4uLnRoaXMuaXNSdGwgPyBbdGhpcy5DU1MuZWRpdG9yUnRsRml4XSA6IFtdXG4gICAgXSksIHRoaXMubm9kZXMucmVkYWN0b3IgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuZWRpdG9yWm9uZSksIHRoaXMubm9kZXMuaG9sZGVyLm9mZnNldFdpZHRoIDwgdGhpcy5jb250ZW50UmVjdC53aWR0aCAmJiB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5lZGl0b3JXcmFwcGVyTmFycm93KSwgdGhpcy5ub2Rlcy5yZWRhY3Rvci5zdHlsZS5wYWRkaW5nQm90dG9tID0gdGhpcy5jb25maWcubWluSGVpZ2h0ICsgXCJweFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5yZWRhY3RvciksIHRoaXMubm9kZXMuaG9sZGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMud3JhcHBlciksIHRoaXMuYmluZFJlYWRPbmx5SW5zZW5zaXRpdmVMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBDU1NcbiAgICovXG4gIGxvYWRTdHlsZXMoKSB7XG4gICAgY29uc3QgZSA9IFwiZWRpdG9yLWpzLXN0eWxlc1wiO1xuICAgIGlmIChkLmdldChlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwic3R5bGVcIiwgbnVsbCwge1xuICAgICAgaWQ6IGUsXG4gICAgICB0ZXh0Q29udGVudDogU2EudG9TdHJpbmcoKVxuICAgIH0pO1xuICAgIHRoaXMuY29uZmlnLnN0eWxlICYmICFWKHRoaXMuY29uZmlnLnN0eWxlKSAmJiB0aGlzLmNvbmZpZy5zdHlsZS5ub25jZSAmJiB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHRoaXMuY29uZmlnLnN0eWxlLm5vbmNlKSwgZC5wcmVwZW5kKGRvY3VtZW50LmhlYWQsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVycyB0aGF0IHNob3VsZCB3b3JrIGJvdGggaW4gcmVhZC1vbmx5IGFuZCByZWFkLXdyaXRlIG1vZGVzXG4gICAqL1xuICBiaW5kUmVhZE9ubHlJbnNlbnNpdGl2ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5zZWxlY3Rpb25DaGFuZ2VEZWJvdW5jZWQpLCB0aGlzLmxpc3RlbmVycy5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMucmVzaXplRGVib3VuY2VyLCB7XG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcIm1vdXNlZG93blwiLCB0aGlzLmRvY3VtZW50VG91Y2hlZExpc3RlbmVyLCB7XG4gICAgICBjYXB0dXJlOiAhMCxcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucmVkYWN0b3IsIFwidG91Y2hzdGFydFwiLCB0aGlzLmRvY3VtZW50VG91Y2hlZExpc3RlbmVyLCB7XG4gICAgICBjYXB0dXJlOiAhMCxcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXJzIHRoYXQgc2hvdWxkIHdvcmsgYm90aCBpbiByZWFkLW9ubHkgYW5kIHJlYWQtd3JpdGUgbW9kZXNcbiAgICovXG4gIHVuYmluZFJlYWRPbmx5SW5zZW5zaXRpdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMub2ZmKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLnNlbGVjdGlvbkNoYW5nZURlYm91bmNlZCksIHRoaXMubGlzdGVuZXJzLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMucmVzaXplRGVib3VuY2VyKSwgdGhpcy5saXN0ZW5lcnMub2ZmKHRoaXMubm9kZXMucmVkYWN0b3IsIFwibW91c2Vkb3duXCIsIHRoaXMuZG9jdW1lbnRUb3VjaGVkTGlzdGVuZXIpLCB0aGlzLmxpc3RlbmVycy5vZmYodGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuZG9jdW1lbnRUb3VjaGVkTGlzdGVuZXIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVycyB0aGF0IHNob3VsZCB3b3JrIG9ubHkgaW4gcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIGJpbmRSZWFkT25seVNlbnNpdGl2ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLnJlZGFjdG9yQ2xpY2tlZChlKTtcbiAgICB9LCAhMSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duKGUpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tlZChlKTtcbiAgICB9LCAhMCksIHRoaXMud2F0Y2hCbG9ja0hvdmVyZWRFdmVudHMoKSwgdGhpcy5lbmFibGVJbnB1dHNFbXB0eU1hcmsoKTtcbiAgfVxuICAvKipcbiAgICogTGlzdGVuIHJlZGFjdG9yIG1vdXNlbW92ZSB0byBlbWl0ICdibG9jay1ob3ZlcmVkJyBldmVudFxuICAgKi9cbiAgd2F0Y2hCbG9ja0hvdmVyZWRFdmVudHMoKSB7XG4gICAgbGV0IGU7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJtb3VzZW1vdmVcIiwgZHQoKHQpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0LnRhcmdldC5jbG9zZXN0KFwiLmNlLWJsb2NrXCIpO1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uYW55QmxvY2tTZWxlY3RlZCB8fCBvICYmIGUgIT09IG8gJiYgKGUgPSBvLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdChsbiwge1xuICAgICAgICBibG9jazogdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUobylcbiAgICAgIH0pKTtcbiAgICB9LCAyMCksIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVuYmluZCBldmVudHMgdGhhdCBzaG91bGQgd29yayBvbmx5IGluIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICB1bmJpbmRSZWFkT25seVNlbnNpdGl2ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNpemUgd2luZG93IGhhbmRsZXJcbiAgICovXG4gIHdpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRSZWN0Q2FjaGUgPSBudWxsLCB0aGlzLnNldElzTW9iaWxlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCBrZXlkb3ducyBvbiBkb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGRvY3VtZW50S2V5ZG93bihlKSB7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgeS5FTlRFUjpcbiAgICAgICAgdGhpcy5lbnRlclByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5LkJBQ0tTUEFDRTpcbiAgICAgIGNhc2UgeS5ERUxFVEU6XG4gICAgICAgIHRoaXMuYmFja3NwYWNlUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuRVNDOlxuICAgICAgICB0aGlzLmVzY2FwZVByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kZWZhdWx0QmVoYXZpb3VyKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIElnbm9yZSBhbGwgb3RoZXIgZG9jdW1lbnQncyBrZXlkb3duIGV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGRlZmF1bHRCZWhhdmlvdXIoZSkge1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiB0IH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIsIG8gPSBlLnRhcmdldC5jbG9zZXN0KGAuJHt0aGlzLkNTUy5lZGl0b3JXcmFwcGVyfWApLCBpID0gZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5O1xuICAgIGlmICh0ICE9PSB2b2lkIDAgJiYgbyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tFdmVudHMua2V5ZG93bihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbyB8fCB0ICYmIGkgfHwgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci51bnNldEN1cnJlbnRCbG9jaygpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGJhY2tzcGFjZVByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbywgQ2FyZXQ6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmIChvLmFueUJsb2NrU2VsZWN0ZWQgJiYgIWIuaXNTZWxlY3Rpb25FeGlzdHMpIHtcbiAgICAgIGNvbnN0IHMgPSB0LnJlbW92ZVNlbGVjdGVkQmxvY2tzKCksIHIgPSB0Lmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgocywgITApO1xuICAgICAgaS5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLlNUQVJUKSwgby5jbGVhclNlbGVjdGlvbihlKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXNjYXBlIHByZXNzZWRcbiAgICogSWYgc29tZSBvZiBUb29sYmFyIGNvbXBvbmVudHMgYXJlIG9wZW5lZCwgdGhlbiBjbG9zZSBpdCBvdGhlcndpc2UgY2xvc2UgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIGVzY2FwZSBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBlc2NhcGVQcmVzc2VkKGUpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKSwgdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW5lZCA/ICh0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3guY2xvc2UoKSwgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLCB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuRU5EKSkgOiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCA/IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSA6IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIub3BlbmVkID8gdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpIDogdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlciBwcmVzc2VkIG9uIGRvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgZW50ZXJQcmVzc2VkKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmICh0aGlzLnNvbWVUb29sYmFyT3BlbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0LmN1cnJlbnRCbG9ja0luZGV4ID49IDA7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiAhYi5pc1NlbGVjdGlvbkV4aXN0cykge1xuICAgICAgby5jbGVhclNlbGVjdGlvbihlKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc29tZVRvb2xiYXJPcGVuZWQgJiYgaSAmJiBlLnRhcmdldC50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhzKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbihzKTtcbiAgICB9XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCBjbGlja3Mgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIENsaWNrIGV2ZW50XG4gICAqL1xuICBkb2N1bWVudENsaWNrZWQoZSkge1xuICAgIHZhciBhLCBsO1xuICAgIGlmICghZS5pc1RydXN0ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUudGFyZ2V0O1xuICAgIHRoaXMubm9kZXMuaG9sZGVyLmNvbnRhaW5zKHQpIHx8IGIuaXNBdEVkaXRvciB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnVuc2V0Q3VycmVudEJsb2NrKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSk7XG4gICAgY29uc3QgaSA9IChhID0gdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5ub2Rlcy53cmFwcGVyKSA9PSBudWxsID8gdm9pZCAwIDogYS5jb250YWlucyh0KSwgcyA9IChsID0gdGhpcy5FZGl0b3IuVG9vbGJhci5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIpID09IG51bGwgPyB2b2lkIDAgOiBsLmNvbnRhaW5zKHQpLCByID0gaSB8fCBzO1xuICAgIGlmICh0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCAmJiAhcikge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpO1xuICAgICAgY29uc3QgYyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5Q2hpbGROb2RlKHQpO1xuICAgICAgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbihjKTtcbiAgICB9XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IHRvdWNoIG9uIGVkaXRvclxuICAgKiBGaXJlZCBiZWZvcmUgY2xpY2tcbiAgICpcbiAgICogVXNlZCB0byBjaGFuZ2UgY3VycmVudCBibG9jayDigJQgd2UgbmVlZCB0byBkbyBpdCBiZWZvcmUgJ3NlbGVjdGlvbkNoYW5nZScgZXZlbnQuXG4gICAqIEFsc286XG4gICAqIC0gTW92ZSBhbmQgc2hvdyB0aGUgVG9vbGJhclxuICAgKiAtIFNldCBhIENhcmV0XG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIHRvdWNoIG9yIG1vdXNlIGV2ZW50XG4gICAqL1xuICBkb2N1bWVudFRvdWNoZWQoZSkge1xuICAgIGxldCB0ID0gZS50YXJnZXQ7XG4gICAgaWYgKHQgPT09IHRoaXMubm9kZXMucmVkYWN0b3IpIHtcbiAgICAgIGNvbnN0IG8gPSBlIGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGUuY2xpZW50WCA6IGUudG91Y2hlc1swXS5jbGllbnRYLCBpID0gZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBlLmNsaWVudFkgOiBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KG8sIGkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKHQpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmlzUmVjdEFjdGl2YXRlZCgpIHx8IHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvVGhlTGFzdEJsb2NrKCk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCB8fCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCBjbGlja3Mgb24gdGhlIHJlZGFjdG9yIHpvbmVcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIGNsaWNrIGV2ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAtIEJ5IGNsaWNrcyBvbiB0aGUgRWRpdG9yJ3MgYm90dG9tIHpvbmU6XG4gICAqICAgICAgLSBpZiBsYXN0IEJsb2NrIGlzIGVtcHR5LCBzZXQgYSBDYXJldCB0byB0aGlzXG4gICAqICAgICAgLSBvdGhlcndpc2UsIGFkZCBhIG5ldyBlbXB0eSBCbG9jayBhbmQgc2V0IGEgQ2FyZXQgdG8gdGhhdFxuICAgKi9cbiAgcmVkYWN0b3JDbGlja2VkKGUpIHtcbiAgICBpZiAoIWIuaXNDb2xsYXBzZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUudGFyZ2V0LCBvID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleTtcbiAgICBpZiAoZC5pc0FuY2hvcih0KSAmJiBvKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgaSA9IHQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSwgcyA9IG9pKGkpO1xuICAgICAgaWkocyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0JvdHRvbVpvbmVDbGljayhlKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdXNlciBjbGlja3Mgb24gdGhlIEVkaXRvcidzIGJvdHRvbSB6b25lOlxuICAgKiAgLSBzZXQgY2FyZXQgdG8gdGhlIGxhc3QgYmxvY2tcbiAgICogIC0gb3IgYWRkIG5ldyBlbXB0eSBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBjbGljayBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0JvdHRvbVpvbmVDbGljayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoLTEpLCBvID0gZC5vZmZzZXQodC5ob2xkZXIpLmJvdHRvbSwgaSA9IGUucGFnZVksIHsgQmxvY2tTZWxlY3Rpb246IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZS50YXJnZXQuaXNFcXVhbE5vZGUodGhpcy5ub2Rlcy5yZWRhY3RvcikgJiYgLyoqXG4gICAgKiBJZiB0aGVyZSBpcyBjcm9zcyBibG9jayBzZWxlY3Rpb24gc3RhcnRlZCwgdGFyZ2V0IHdpbGwgYmUgZXF1YWwgdG8gcmVkYWN0b3Igc28gd2UgbmVlZCBhZGRpdGlvbmFsIGNoZWNrXG4gICAgKi9cbiAgICAhcy5hbnlCbG9ja1NlbGVjdGVkICYmIC8qKlxuICAgICogUHJldmVudCBjYXJldCBqdW1waW5nICh0byBsYXN0IGJsb2NrKSB3aGVuIGNsaWNraW5nIGJldHdlZW4gYmxvY2tzXG4gICAgKi9cbiAgICBvIDwgaSkge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBhLCBDYXJldDogbCwgVG9vbGJhcjogYyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgICAoIWEubGFzdEJsb2NrLnRvb2wuaXNEZWZhdWx0IHx8ICFhLmxhc3RCbG9jay5pc0VtcHR5KSAmJiBhLmluc2VydEF0RW5kKCksIGwuc2V0VG9UaGVMYXN0QmxvY2soKSwgYy5tb3ZlQW5kT3BlbihhLmxhc3RCbG9jayk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgc2VsZWN0aW9uIGNoYW5nZXMgb24gbW9iaWxlIGRldmljZXNcbiAgICogVXNlcyBmb3Igc2hvd2luZyB0aGUgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHNlbGVjdGlvbkNoYW5nZWQoKSB7XG4gICAgY29uc3QgeyBDcm9zc0Jsb2NrU2VsZWN0aW9uOiBlLCBCbG9ja1NlbGVjdGlvbjogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBiLmFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGUuaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCAmJiB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgIW8pIHtcbiAgICAgIGIucmFuZ2UgfHwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gby5jbG9zZXN0KGAuJHtSLkNTUy5jb250ZW50fWApO1xuICAgIChpID09PSBudWxsIHx8IGkuY2xvc2VzdChgLiR7Yi5DU1MuZWRpdG9yV3JhcHBlcn1gKSAhPT0gdGhpcy5ub2Rlcy53cmFwcGVyKSAmJiAodGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jb250YWluc05vZGUobykgfHwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpLCAhKG8uZGF0YXNldC5pbmxpbmVUb29sYmFyID09PSBcInRydWVcIikpIHx8ICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrIHx8IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShvKSwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci50cnlUb1Nob3coITApKTtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yLmpzIHByb3ZpZGVzIGFuZCBhYmlsaXR5IHRvIHNob3cgcGxhY2Vob2xkZXJzIGZvciBlbXB0eSBjb250ZW50ZWRpdGFibGUgZWxlbWVudHNcbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2F0Y2hlcyBmb3IgaW5wdXQgYW5kIGZvY3VzIGV2ZW50cyBhbmQgdG9nZ2xlcyAnZGF0YS1lbXB0eScgYXR0cmlidXRlXG4gICAqIHRvIHdvcmthcm91ZCB0aGUgY2FzZSwgd2hlbiBpbnB1dHMgY29udGFpbnMgb25seSA8YnI+cyBhbmQgaGFzIG5vIHZpc2libGUgY29udGVudFxuICAgKiBUaGVuLCBDU1MgY291bGQgcmVseSBvbiB0aGlzIGF0dHJpYnV0ZSB0byBzaG93IHBsYWNlaG9sZGVyc1xuICAgKi9cbiAgZW5hYmxlSW5wdXRzRW1wdHlNYXJrKCkge1xuICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgY29uc3QgbyA9IHQudGFyZ2V0O1xuICAgICAgRG8obyk7XG4gICAgfVxuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMud3JhcHBlciwgXCJpbnB1dFwiLCBlKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy53cmFwcGVyLCBcImZvY3VzaW5cIiwgZSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMud3JhcHBlciwgXCJmb2N1c291dFwiLCBlKTtcbiAgfVxufVxuY29uc3QgT2EgPSB7XG4gIC8vIEFQSSBNb2R1bGVzXG4gIEJsb2Nrc0FQSTogZ2ksXG4gIENhcmV0QVBJOiBiaSxcbiAgRXZlbnRzQVBJOiB2aSxcbiAgSTE4bkFQSToga3QsXG4gIEFQSToga2ksXG4gIElubGluZVRvb2xiYXJBUEk6IHlpLFxuICBMaXN0ZW5lcnNBUEk6IHdpLFxuICBOb3RpZmllckFQSTogQ2ksXG4gIFJlYWRPbmx5QVBJOiBUaSxcbiAgU2FuaXRpemVyQVBJOiBMaSxcbiAgU2F2ZXJBUEk6IFBpLFxuICBTZWxlY3Rpb25BUEk6IE5pLFxuICBUb29sc0FQSTogUmksXG4gIFN0eWxlc0FQSTogRGksXG4gIFRvb2xiYXJBUEk6IEZpLFxuICBUb29sdGlwQVBJOiBVaSxcbiAgVWlBUEk6IFdpLFxuICAvLyBUb29sYmFyIE1vZHVsZXNcbiAgQmxvY2tTZXR0aW5nczogbXMsXG4gIFRvb2xiYXI6IEJzLFxuICBJbmxpbmVUb29sYmFyOiBDcyxcbiAgLy8gTW9kdWxlc1xuICBCbG9ja0V2ZW50czogbmEsXG4gIEJsb2NrTWFuYWdlcjogcmEsXG4gIEJsb2NrU2VsZWN0aW9uOiBhYSxcbiAgQ2FyZXQ6IFllLFxuICBDcm9zc0Jsb2NrU2VsZWN0aW9uOiBsYSxcbiAgRHJhZ05Ecm9wOiBjYSxcbiAgTW9kaWZpY2F0aW9uc09ic2VydmVyOiBoYSxcbiAgUGFzdGU6IHBhLFxuICBSZWFkT25seTogZmEsXG4gIFJlY3RhbmdsZVNlbGVjdGlvbjogQmUsXG4gIFJlbmRlcmVyOiBnYSxcbiAgU2F2ZXI6IG1hLFxuICBUb29sczogV24sXG4gIFVJOiBJYVxufTtcbmNsYXNzIF9hIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWRpdG9yQ29uZmlnfSBjb25maWcgLSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm1vZHVsZUluc3RhbmNlcyA9IHt9LCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIgPSBuZXcgT2UoKTtcbiAgICBsZXQgdCwgbztcbiAgICB0aGlzLmlzUmVhZHkgPSBuZXcgUHJvbWlzZSgoaSwgcykgPT4ge1xuICAgICAgdCA9IGksIG8gPSBzO1xuICAgIH0pLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGUsIHRoaXMudmFsaWRhdGUoKSwgdGhpcy5pbml0KCksIGF3YWl0IHRoaXMuc3RhcnQoKSwgYXdhaXQgdGhpcy5yZW5kZXIoKTtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpLCBDYXJldDogcywgVUk6IHIsIE1vZGlmaWNhdGlvbnNPYnNlcnZlcjogYSB9ID0gdGhpcy5tb2R1bGVJbnN0YW5jZXM7XG4gICAgICByLmNoZWNrRW1wdGluZXNzKCksIGEuZW5hYmxlKCksIHRoaXMuY29uZmlndXJhdGlvbi5hdXRvZm9jdXMgPT09ICEwICYmIHRoaXMuY29uZmlndXJhdGlvbi5yZWFkT25seSAhPT0gITAgJiYgcy5zZXRUb0Jsb2NrKGkuYmxvY2tzWzBdLCBzLnBvc2l0aW9ucy5TVEFSVCksIHQoKTtcbiAgICB9KS5jYXRjaCgoaSkgPT4ge1xuICAgICAgUyhgRWRpdG9yLmpzIGlzIG5vdCByZWFkeSBiZWNhdXNlIG9mICR7aX1gLCBcImVycm9yXCIpLCBvKGkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0aW5nIGZvciBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RWRpdG9yQ29uZmlnfHN0cmluZ30gY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnIHRvIHNldFxuICAgKi9cbiAgc2V0IGNvbmZpZ3VyYXRpb24oZSkge1xuICAgIHZhciBvLCBpO1xuICAgIEQoZSkgPyB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLmVcbiAgICB9IDogdGhpcy5jb25maWcgPSB7XG4gICAgICBob2xkZXI6IGVcbiAgICB9LCBodCghIXRoaXMuY29uZmlnLmhvbGRlcklkLCBcImNvbmZpZy5ob2xkZXJJZFwiLCBcImNvbmZpZy5ob2xkZXJcIiksIHRoaXMuY29uZmlnLmhvbGRlcklkICYmICF0aGlzLmNvbmZpZy5ob2xkZXIgJiYgKHRoaXMuY29uZmlnLmhvbGRlciA9IHRoaXMuY29uZmlnLmhvbGRlcklkLCB0aGlzLmNvbmZpZy5ob2xkZXJJZCA9IG51bGwpLCB0aGlzLmNvbmZpZy5ob2xkZXIgPT0gbnVsbCAmJiAodGhpcy5jb25maWcuaG9sZGVyID0gXCJlZGl0b3Jqc1wiKSwgdGhpcy5jb25maWcubG9nTGV2ZWwgfHwgKHRoaXMuY29uZmlnLmxvZ0xldmVsID0gTG8uVkVSQk9TRSksIFpuKHRoaXMuY29uZmlnLmxvZ0xldmVsKSwgaHQoISF0aGlzLmNvbmZpZy5pbml0aWFsQmxvY2ssIFwiY29uZmlnLmluaXRpYWxCbG9ja1wiLCBcImNvbmZpZy5kZWZhdWx0QmxvY2tcIiksIHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayA9IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayB8fCB0aGlzLmNvbmZpZy5pbml0aWFsQmxvY2sgfHwgXCJwYXJhZ3JhcGhcIiwgdGhpcy5jb25maWcubWluSGVpZ2h0ID0gdGhpcy5jb25maWcubWluSGVpZ2h0ICE9PSB2b2lkIDAgPyB0aGlzLmNvbmZpZy5taW5IZWlnaHQgOiAzMDA7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHR5cGU6IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayxcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciA9IHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICExLCB0aGlzLmNvbmZpZy5zYW5pdGl6ZXIgPSB0aGlzLmNvbmZpZy5zYW5pdGl6ZXIgfHwge1xuICAgICAgcDogITAsXG4gICAgICBiOiAhMCxcbiAgICAgIGE6ICEwXG4gICAgfSwgdGhpcy5jb25maWcuaGlkZVRvb2xiYXIgPSB0aGlzLmNvbmZpZy5oaWRlVG9vbGJhciA/IHRoaXMuY29uZmlnLmhpZGVUb29sYmFyIDogITEsIHRoaXMuY29uZmlnLnRvb2xzID0gdGhpcy5jb25maWcudG9vbHMgfHwge30sIHRoaXMuY29uZmlnLmkxOG4gPSB0aGlzLmNvbmZpZy5pMThuIHx8IHt9LCB0aGlzLmNvbmZpZy5kYXRhID0gdGhpcy5jb25maWcuZGF0YSB8fCB7IGJsb2NrczogW10gfSwgdGhpcy5jb25maWcub25SZWFkeSA9IHRoaXMuY29uZmlnLm9uUmVhZHkgfHwgKCgpID0+IHtcbiAgICB9KSwgdGhpcy5jb25maWcub25DaGFuZ2UgPSB0aGlzLmNvbmZpZy5vbkNoYW5nZSB8fCAoKCkgPT4ge1xuICAgIH0pLCB0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyID0gdGhpcy5jb25maWcuaW5saW5lVG9vbGJhciAhPT0gdm9pZCAwID8gdGhpcy5jb25maWcuaW5saW5lVG9vbGJhciA6ICEwLCAoVih0aGlzLmNvbmZpZy5kYXRhKSB8fCAhdGhpcy5jb25maWcuZGF0YS5ibG9ja3MgfHwgdGhpcy5jb25maWcuZGF0YS5ibG9ja3MubGVuZ3RoID09PSAwKSAmJiAodGhpcy5jb25maWcuZGF0YSA9IHsgYmxvY2tzOiBbdF0gfSksIHRoaXMuY29uZmlnLnJlYWRPbmx5ID0gdGhpcy5jb25maWcucmVhZE9ubHkgfHwgITEsIChvID0gdGhpcy5jb25maWcuaTE4bikgIT0gbnVsbCAmJiBvLm1lc3NhZ2VzICYmIHouc2V0RGljdGlvbmFyeSh0aGlzLmNvbmZpZy5pMThuLm1lc3NhZ2VzKSwgdGhpcy5jb25maWcuaTE4bi5kaXJlY3Rpb24gPSAoKGkgPSB0aGlzLmNvbmZpZy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogaS5kaXJlY3Rpb24pIHx8IFwibHRyXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7RWRpdG9yQ29uZmlnfVxuICAgKi9cbiAgZ2V0IGNvbmZpZ3VyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIHJlcXVpcmVkIGZpZWxkcyBpbiBFZGl0b3IncyBjb25maWdcbiAgICovXG4gIHZhbGlkYXRlKCkge1xuICAgIGNvbnN0IHsgaG9sZGVySWQ6IGUsIGhvbGRlcjogdCB9ID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGUgJiYgdClcbiAgICAgIHRocm93IEVycm9yKFwiwqtob2xkZXJJZMK7IGFuZCDCq2hvbGRlcsK7IHBhcmFtIGNhbid0IGFzc2lnbiBhdCB0aGUgc2FtZSB0aW1lLlwiKTtcbiAgICBpZiAodGUodCkgJiYgIWQuZ2V0KHQpKVxuICAgICAgdGhyb3cgRXJyb3IoYGVsZW1lbnQgd2l0aCBJRCDCqyR7dH3CuyBpcyBtaXNzaW5nLiBQYXNzIGNvcnJlY3QgaG9sZGVyJ3MgSUQuYCk7XG4gICAgaWYgKHQgJiYgRCh0KSAmJiAhZC5pc0VsZW1lbnQodCkpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVywrsgdmFsdWUgbXVzdCBiZSBhbiBFbGVtZW50IG5vZGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIG1vZHVsZXM6XG4gICAqICAtIG1ha2UgYW5kIHNhdmUgaW5zdGFuY2VzXG4gICAqICAtIGNvbmZpZ3VyZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNvbnN0cnVjdE1vZHVsZXMoKSwgdGhpcy5jb25maWd1cmVNb2R1bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IEVkaXRvciFcbiAgICpcbiAgICogR2V0IGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWRzIHRvIGJlIHByZXBhcmVkIGFuZCByZXR1cm4gYSBzZXF1ZW5jZSAoUHJvbWlzZSlcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBzdGFydCgpIHtcbiAgICBhd2FpdCBbXG4gICAgICBcIlRvb2xzXCIsXG4gICAgICBcIlVJXCIsXG4gICAgICBcIkJsb2NrTWFuYWdlclwiLFxuICAgICAgXCJQYXN0ZVwiLFxuICAgICAgXCJCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWN0YW5nbGVTZWxlY3Rpb25cIixcbiAgICAgIFwiQ3Jvc3NCbG9ja1NlbGVjdGlvblwiLFxuICAgICAgXCJSZWFkT25seVwiXG4gICAgXS5yZWR1Y2UoXG4gICAgICAodCwgbykgPT4gdC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm1vZHVsZUluc3RhbmNlc1tvXS5wcmVwYXJlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIEhvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkubWVzc2FnZSk7XG4gICAgICAgICAgUyhgTW9kdWxlICR7b30gd2FzIHNraXBwZWQgYmVjYXVzZSBvZiAlb2AsIFwid2FyblwiLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBpbml0aWFsIGRhdGFcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVJbnN0YW5jZXMuUmVuZGVyZXIucmVuZGVyKHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzKTtcbiAgfVxuICAvKipcbiAgICogTWFrZSBtb2R1bGVzIGluc3RhbmNlcyBhbmQgc2F2ZSBpdCB0byB0aGUgQHByb3BlcnR5IHRoaXMubW9kdWxlSW5zdGFuY2VzXG4gICAqL1xuICBjb25zdHJ1Y3RNb2R1bGVzKCkge1xuICAgIE9iamVjdC5lbnRyaWVzKE9hKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubW9kdWxlSW5zdGFuY2VzW2VdID0gbmV3IHQoe1xuICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWd1cmF0aW9uLFxuICAgICAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRoaXMuZXZlbnRzRGlzcGF0Y2hlclxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgUyhcIltjb25zdHJ1Y3RNb2R1bGVzXVwiLCBgTW9kdWxlICR7ZX0gc2tpcHBlZCBiZWNhdXNlYCwgXCJlcnJvclwiLCBvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlcyBpbnN0YW5jZXMgY29uZmlndXJhdGlvbjpcbiAgICogIC0gcGFzcyBvdGhlciBtb2R1bGVzIHRvIHRoZSAnc3RhdGUnIHByb3BlcnR5XG4gICAqICAtIC4uLlxuICAgKi9cbiAgY29uZmlndXJlTW9kdWxlcygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5tb2R1bGVJbnN0YW5jZXMpXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2R1bGVJbnN0YW5jZXMsIGUpICYmICh0aGlzLm1vZHVsZUluc3RhbmNlc1tlXS5zdGF0ZSA9IHRoaXMuZ2V0TW9kdWxlc0RpZmYoZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbW9kdWxlcyB3aXRob3V0IHBhc3NlZCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbW9kdWxlIGZvciB3aXRjaCBtb2R1bGVzIGRpZmZlcmVuY2Ugc2hvdWxkIGJlIGNhbGN1bGF0ZWRcbiAgICovXG4gIGdldE1vZHVsZXNEaWZmKGUpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBvIGluIHRoaXMubW9kdWxlSW5zdGFuY2VzKVxuICAgICAgbyAhPT0gZSAmJiAodFtvXSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzW29dKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufVxuLyoqXG4gKiBFZGl0b3IuanNcbiAqXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKiBAc2VlIEVkaXRvci5qcyA8aHR0cHM6Ly9lZGl0b3Jqcy5pbz5cbiAqIEBhdXRob3IgQ29kZVggVGVhbSA8aHR0cHM6Ly9jb2RleC5zbz5cbiAqL1xuY2xhc3MgQWEge1xuICAvKiogRWRpdG9yIHZlcnNpb24gKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjIuMzEuMC1yYy43XCI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWRpdG9yQ29uZmlnfHN0cmluZ3x1bmRlZmluZWR9IFtjb25maWd1cmF0aW9uXSAtIHVzZXIgY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGxldCB0ID0gKCkgPT4ge1xuICAgIH07XG4gICAgRChlKSAmJiBBKGUub25SZWFkeSkgJiYgKHQgPSBlLm9uUmVhZHkpO1xuICAgIGNvbnN0IG8gPSBuZXcgX2EoZSk7XG4gICAgdGhpcy5pc1JlYWR5ID0gby5pc1JlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5leHBvcnRBUEkobyksIHQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0IGV4dGVybmFsIEFQSSBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7Q29yZX0gZWRpdG9yIOKAlCBFZGl0b3IncyBpbnN0YW5jZVxuICAgKi9cbiAgZXhwb3J0QVBJKGUpIHtcbiAgICBjb25zdCB0ID0gW1wiY29uZmlndXJhdGlvblwiXSwgbyA9ICgpID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXMoZS5tb2R1bGVJbnN0YW5jZXMpLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgQShzLmRlc3Ryb3kpICYmIHMuZGVzdHJveSgpLCBzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgICAgIH0pLCB6aSgpLCBlID0gbnVsbDtcbiAgICAgIGZvciAoY29uc3QgcyBpbiB0aGlzKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcykgJiYgZGVsZXRlIHRoaXNbc107XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbnVsbCk7XG4gICAgfTtcbiAgICB0LmZvckVhY2goKHMpID0+IHtcbiAgICAgIHRoaXNbc10gPSBlW3NdO1xuICAgIH0pLCB0aGlzLmRlc3Ryb3kgPSBvLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgZS5tb2R1bGVJbnN0YW5jZXMuQVBJLm1ldGhvZHMpLCBkZWxldGUgdGhpcy5leHBvcnRBUEksIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIGJsb2Nrczoge1xuICAgICAgICBjbGVhcjogXCJjbGVhclwiLFxuICAgICAgICByZW5kZXI6IFwicmVuZGVyXCJcbiAgICAgIH0sXG4gICAgICBjYXJldDoge1xuICAgICAgICBmb2N1czogXCJmb2N1c1wiXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG9uOiBcIm9uXCIsXG4gICAgICAgIG9mZjogXCJvZmZcIixcbiAgICAgICAgZW1pdDogXCJlbWl0XCJcbiAgICAgIH0sXG4gICAgICBzYXZlcjoge1xuICAgICAgICBzYXZlOiBcInNhdmVcIlxuICAgICAgfVxuICAgIH0pLmZvckVhY2goKFtzLCByXSkgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMocikuZm9yRWFjaCgoW2EsIGxdKSA9PiB7XG4gICAgICAgIHRoaXNbbF0gPSBlLm1vZHVsZUluc3RhbmNlcy5BUEkubWV0aG9kc1tzXVthXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnQge1xuICBBYSBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/header/dist/header.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@editorjs/header/dist/header.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}\")),document.head.appendChild(e)}}catch(n){console.error(\"vite-plugin-css-injected-by-js\",n)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5\"/></svg>', l = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17\"/></svg>', o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3\"/></svg>', h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6\"/></svg>', d = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8\"/></svg>', u = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z\"/></svg>', g = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12\"/></svg>';\n/**\n * Header block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license MIT\n * @version 2.0.0\n */\nclass v {\n  constructor({ data: e, config: t, api: s, readOnly: r }) {\n    this.api = s, this.readOnly = r, this._settings = t, this._data = this.normalizeData(e), this._element = this.getTag();\n  }\n  /**\n   * Styles\n   */\n  get _CSS() {\n    return {\n      block: this.api.styles.block,\n      wrapper: \"ce-header\"\n    };\n  }\n  /**\n   * Check if data is valid\n   * \n   * @param {any} data - data to check\n   * @returns {data is HeaderData}\n   * @private\n   */\n  isHeaderData(e) {\n    return e.text !== void 0;\n  }\n  /**\n   * Normalize input data\n   *\n   * @param {HeaderData} data - saved data to process\n   *\n   * @returns {HeaderData}\n   * @private\n   */\n  normalizeData(e) {\n    const t = { text: \"\", level: this.defaultLevel.number };\n    return this.isHeaderData(e) && (t.text = e.text || \"\", e.level !== void 0 && !isNaN(parseInt(e.level.toString())) && (t.level = parseInt(e.level.toString()))), t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLHeadingElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Returns header block tunes config\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return this.levels.map((e) => ({\n      icon: e.svg,\n      label: this.api.i18n.t(`Heading ${e.number}`),\n      onActivate: () => this.setLevel(e.number),\n      closeOnActivate: !0,\n      isActive: this.currentLevel.number === e.number,\n      render: () => document.createElement(\"div\")\n    }));\n  }\n  /**\n   * Callback for Block's settings buttons\n   *\n   * @param {number} level - level to set\n   */\n  setLevel(e) {\n    this.data = {\n      level: e,\n      text: this.data.text\n    };\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {HeaderData} data - saved data to merger with current block\n   * @public\n   */\n  merge(e) {\n    this._element.insertAdjacentHTML(\"beforeend\", e.text);\n  }\n  /**\n   * Validate Text block data:\n   * - check for emptiness\n   *\n   * @param {HeaderData} blockData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return e.text.trim() !== \"\";\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLHeadingElement} toolsContent - Text tools rendered view\n   * @returns {HeaderData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML,\n      level: this.currentLevel.number\n    };\n  }\n  /**\n   * Allow Header to be converted to/from other blocks\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // use 'text' property for other blocks\n      import: \"text\"\n      // fill 'text' property from other block's export string\n    };\n  }\n  /**\n   * Sanitizer Rules\n   */\n  static get sanitize() {\n    return {\n      level: !1,\n      text: {}\n    };\n  }\n  /**\n   * Returns true to notify core that read-only is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {HeaderData} Current data\n   * @private\n   */\n  get data() {\n    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {HeaderData} data — data to set\n   * @private\n   */\n  set data(e) {\n    if (this._data = this.normalizeData(e), e.level !== void 0 && this._element.parentNode) {\n      const t = this.getTag();\n      t.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t, this._element), this._element = t;\n    }\n    e.text !== void 0 && (this._element.innerHTML = this._data.text || \"\");\n  }\n  /**\n   * Get tag for target level\n   * By default returns second-leveled header\n   *\n   * @returns {HTMLElement}\n   */\n  getTag() {\n    const e = document.createElement(this.currentLevel.tag);\n    return e.innerHTML = this._data.text || \"\", e.classList.add(this._CSS.wrapper), e.contentEditable = this.readOnly ? \"false\" : \"true\", e.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || \"\"), e;\n  }\n  /**\n   * Get current level\n   *\n   * @returns {level}\n   */\n  get currentLevel() {\n    let e = this.levels.find((t) => t.number === this._data.level);\n    return e || (e = this.defaultLevel), e;\n  }\n  /**\n   * Return default level\n   *\n   * @returns {level}\n   */\n  get defaultLevel() {\n    if (this._settings.defaultLevel) {\n      const e = this.levels.find((t) => t.number === this._settings.defaultLevel);\n      if (e)\n        return e;\n      console.warn(\"(ง'̀-'́)ง Heading Tool: the default level specified was not found in available levels\");\n    }\n    return this.levels[1];\n  }\n  /**\n   * @typedef {object} level\n   * @property {number} number - level number\n   * @property {string} tag - tag corresponds with level number\n   * @property {string} svg - icon\n   */\n  /**\n   * Available header levels\n   *\n   * @returns {level[]}\n   */\n  get levels() {\n    const e = [\n      {\n        number: 1,\n        tag: \"H1\",\n        svg: a\n      },\n      {\n        number: 2,\n        tag: \"H2\",\n        svg: l\n      },\n      {\n        number: 3,\n        tag: \"H3\",\n        svg: o\n      },\n      {\n        number: 4,\n        tag: \"H4\",\n        svg: h\n      },\n      {\n        number: 5,\n        tag: \"H5\",\n        svg: d\n      },\n      {\n        number: 6,\n        tag: \"H6\",\n        svg: u\n      }\n    ];\n    return this._settings.levels ? e.filter(\n      (t) => this._settings.levels.includes(t.number)\n    ) : e;\n  }\n  /**\n   * Handle H1-H6 tags on paste to substitute it with header Tool\n   *\n   * @param {PasteEvent} event - event with pasted content\n   */\n  onPaste(e) {\n    const t = e.detail;\n    if (\"data\" in t) {\n      const s = t.data;\n      let r = this.defaultLevel.number;\n      switch (s.tagName) {\n        case \"H1\":\n          r = 1;\n          break;\n        case \"H2\":\n          r = 2;\n          break;\n        case \"H3\":\n          r = 3;\n          break;\n        case \"H4\":\n          r = 4;\n          break;\n        case \"H5\":\n          r = 5;\n          break;\n        case \"H6\":\n          r = 6;\n          break;\n      }\n      this._settings.levels && (r = this._settings.levels.reduce((n, i) => Math.abs(i - r) < Math.abs(n - r) ? i : n)), this.data = {\n        level: r,\n        text: s.innerHTML\n      };\n    }\n  }\n  /**\n   * Used by Editor.js paste handling API.\n   * Provides configuration to handle H1-H6 tags.\n   *\n   * @returns {{handler: (function(HTMLElement): {text: string}), tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"]\n    };\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: g,\n      title: \"Heading\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2hlYWRlci9kaXN0L2hlYWRlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0Msa0RBQWtELG1CQUFtQixTQUFTLG1CQUFtQixhQUFhLDRCQUE0QixvQkFBb0IsbUJBQW1CLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUMxVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9oZWFkZXIvZGlzdC9oZWFkZXIubWpzP2VhYzkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2UtaGVhZGVye3BhZGRpbmc6LjZlbSAwIDNweDttYXJnaW46MDtsaW5lLWhlaWdodDoxLjI1ZW07b3V0bGluZTpub25lfS5jZS1oZWFkZXIgcCwuY2UtaGVhZGVyIGRpdntwYWRkaW5nOjAhaW1wb3J0YW50O21hcmdpbjowIWltcG9ydGFudH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKG4pe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIixuKX19KSgpO1xuY29uc3QgYSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTkgMTdWMTAuMjEzNUMxOSAxMC4xMjg3IDE4LjkwMTEgMTAuMDgyNCAxOC44MzYgMTAuMTM2N0wxNiAxMi41XCIvPjwvc3ZnPicsIGwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDExQzE2IDEwIDE5IDkuNSAxOSAxMkMxOSAxMy45NzcxIDE2LjA2ODQgMTMuOTk5NyAxNi4wMDEyIDE2Ljg5ODFDMTUuOTk5OSAxNi45NTMzIDE2LjA0NDggMTcgMTYuMSAxN0wxOS4zIDE3XCIvPjwvc3ZnPicsIG8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDExQzE2IDEwLjUgMTYuODMyMyAxMCAxNy42IDEwQzE4LjM2NzcgMTAgMTkuNSAxMC4zMTEgMTkuNSAxMS41QzE5LjUgMTIuNTMxNSAxOC43NDc0IDEyLjkwMjIgMTguNTQ4IDEyLjk4MjNDMTguNTM3OCAxMi45ODY0IDE4LjUzOTUgMTMuMDA0NyAxOC41NTAzIDEzLjAwNjNDMTguODExNSAxMy4wNDU2IDIwIDEzLjMwNjUgMjAgMTQuOEMyMCAxNiAxOS41IDE3IDE3LjggMTdDMTcuOCAxNyAxNiAxNyAxNiAxNi4zXCIvPjwvc3ZnPicsIGggPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4IDEwTDE1LjI4MzQgMTQuODUxMUMxNS4yNDYgMTQuOTE3OCAxNS4yOTQgMTUgMTUuMzcwNCAxNUMxNi44NDg5IDE1IDE4Ljc1NjEgMTUgMjAuMiAxNU0xOSAxN0MxOSAxNS43MTg3IDE5IDE0Ljg4MTMgMTkgMTMuNlwiLz48L3N2Zz4nLCBkID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxNS45QzE2IDE1LjkgMTYuMzc2OCAxNyAxNy44IDE3QzE5LjUgMTcgMjAgMTUuNjE5OSAyMCAxNC43QzIwIDEyLjczMjMgMTcuNjc0NSAxMi4wNDg2IDE2LjE2MzUgMTIuOTg5NEMxNi4wOTQgMTMuMDMyNyAxNiAxMi45ODQ2IDE2IDEyLjkwMjdWMTAuMUMxNiAxMC4wNDQ4IDE2LjA0NDggMTAgMTYuMSAxMEgxOS44XCIvPjwvc3ZnPicsIHUgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE5LjUgMTBDMTYuNSAxMC41IDE2IDEzLjMyODUgMTYgMTVNMTYgMTVWMTVDMTYgMTYuMTA0NiAxNi44OTU0IDE3IDE4IDE3SDE4LjMyNDZDMTkuMzI1MSAxNyAyMC4zMTkxIDE2LjM0OTIgMjAuMjUyMiAxNS4zNTA5QzIwLjA2MTIgMTIuNDk1OCAxNiAxMi42NjExIDE2IDE1WlwiLz48L3N2Zz4nLCBnID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05IDdMOSAxMk05IDE3VjEyTTkgMTJMMTUgMTJNMTUgN1YxMk0xNSAxN0wxNSAxMlwiLz48L3N2Zz4nO1xuLyoqXG4gKiBIZWFkZXIgYmxvY2sgZm9yIHRoZSBFZGl0b3IuanMuXG4gKlxuICogQGF1dGhvciBDb2RlWCAodGVhbUBpZm1vLnN1KVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKi9cbmNsYXNzIHYge1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGNvbmZpZzogdCwgYXBpOiBzLCByZWFkT25seTogciB9KSB7XG4gICAgdGhpcy5hcGkgPSBzLCB0aGlzLnJlYWRPbmx5ID0gciwgdGhpcy5fc2V0dGluZ3MgPSB0LCB0aGlzLl9kYXRhID0gdGhpcy5ub3JtYWxpemVEYXRhKGUpLCB0aGlzLl9lbGVtZW50ID0gdGhpcy5nZXRUYWcoKTtcbiAgfVxuICAvKipcbiAgICogU3R5bGVzXG4gICAqL1xuICBnZXQgX0NTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2UtaGVhZGVyXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBkYXRhIGlzIHZhbGlkXG4gICAqIFxuICAgKiBAcGFyYW0ge2FueX0gZGF0YSAtIGRhdGEgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2RhdGEgaXMgSGVhZGVyRGF0YX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSGVhZGVyRGF0YShlKSB7XG4gICAgcmV0dXJuIGUudGV4dCAhPT0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgaW5wdXQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGRhdGEgLSBzYXZlZCBkYXRhIHRvIHByb2Nlc3NcbiAgICpcbiAgICogQHJldHVybnMge0hlYWRlckRhdGF9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVEYXRhKGUpIHtcbiAgICBjb25zdCB0ID0geyB0ZXh0OiBcIlwiLCBsZXZlbDogdGhpcy5kZWZhdWx0TGV2ZWwubnVtYmVyIH07XG4gICAgcmV0dXJuIHRoaXMuaXNIZWFkZXJEYXRhKGUpICYmICh0LnRleHQgPSBlLnRleHQgfHwgXCJcIiwgZS5sZXZlbCAhPT0gdm9pZCAwICYmICFpc05hTihwYXJzZUludChlLmxldmVsLnRvU3RyaW5nKCkpKSAmJiAodC5sZXZlbCA9IHBhcnNlSW50KGUubGV2ZWwudG9TdHJpbmcoKSkpKSwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MSGVhZGluZ0VsZW1lbnR9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBoZWFkZXIgYmxvY2sgdHVuZXMgY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVscy5tYXAoKGUpID0+ICh7XG4gICAgICBpY29uOiBlLnN2ZyxcbiAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoYEhlYWRpbmcgJHtlLm51bWJlcn1gKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuc2V0TGV2ZWwoZS5udW1iZXIpLFxuICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmN1cnJlbnRMZXZlbC5udW1iZXIgPT09IGUubnVtYmVyLFxuICAgICAgcmVuZGVyOiAoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgQmxvY2sncyBzZXR0aW5ncyBidXR0b25zXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIGxldmVsIHRvIHNldFxuICAgKi9cbiAgc2V0TGV2ZWwoZSkge1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIGxldmVsOiBlLFxuICAgICAgdGV4dDogdGhpcy5kYXRhLnRleHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG93IHRvIG1lcmdlIHR3byBUZXh0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIC0gc2F2ZWQgZGF0YSB0byBtZXJnZXIgd2l0aCBjdXJyZW50IGJsb2NrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1lcmdlKGUpIHtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBlLnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBUZXh0IGJsb2NrIGRhdGE6XG4gICAqIC0gY2hlY2sgZm9yIGVtcHRpbmVzc1xuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGJsb2NrRGF0YSDigJQgZGF0YSByZWNlaXZlZCBhZnRlciBzYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhbGlkYXRlKGUpIHtcbiAgICByZXR1cm4gZS50ZXh0LnRyaW0oKSAhPT0gXCJcIjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEhlYWRpbmdFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBUZXh0IHRvb2xzIHJlbmRlcmVkIHZpZXdcbiAgICogQHJldHVybnMge0hlYWRlckRhdGF9IC0gc2F2ZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZS5pbm5lckhUTUwsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwubnVtYmVyXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWxsb3cgSGVhZGVyIHRvIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIGJsb2Nrc1xuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxuICAgICAgLy8gdXNlICd0ZXh0JyBwcm9wZXJ0eSBmb3Igb3RoZXIgYmxvY2tzXG4gICAgICBpbXBvcnQ6IFwidGV4dFwiXG4gICAgICAvLyBmaWxsICd0ZXh0JyBwcm9wZXJ0eSBmcm9tIG90aGVyIGJsb2NrJ3MgZXhwb3J0IHN0cmluZ1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlc1xuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6ICExLFxuICAgICAgdGV4dDoge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgdG8gbm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgVG9vbHNgcyBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfSBDdXJyZW50IGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLnRleHQgPSB0aGlzLl9lbGVtZW50LmlubmVySFRNTCwgdGhpcy5fZGF0YS5sZXZlbCA9IHRoaXMuY3VycmVudExldmVsLm51bWJlciwgdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogU3RvcmUgZGF0YSBpbiBwbHVnaW46XG4gICAqIC0gYXQgdGhlIHRoaXMuX2RhdGEgcHJvcGVydHlcbiAgICogLSBhdCB0aGUgSFRNTFxuICAgKlxuICAgKiBAcGFyYW0ge0hlYWRlckRhdGF9IGRhdGEg4oCUIGRhdGEgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXQgZGF0YShlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEgPSB0aGlzLm5vcm1hbGl6ZURhdGEoZSksIGUubGV2ZWwgIT09IHZvaWQgMCAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmdldFRhZygpO1xuICAgICAgdC5pbm5lckhUTUwgPSB0aGlzLl9lbGVtZW50LmlubmVySFRNTCwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0LCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudCA9IHQ7XG4gICAgfVxuICAgIGUudGV4dCAhPT0gdm9pZCAwICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRhZyBmb3IgdGFyZ2V0IGxldmVsXG4gICAqIEJ5IGRlZmF1bHQgcmV0dXJucyBzZWNvbmQtbGV2ZWxlZCBoZWFkZXJcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0VGFnKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuY3VycmVudExldmVsLnRhZyk7XG4gICAgcmV0dXJuIGUuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0IHx8IFwiXCIsIGUuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciksIGUuY29udGVudEVkaXRhYmxlID0gdGhpcy5yZWFkT25seSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLCBlLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmFwaS5pMThuLnQodGhpcy5fc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgXCJcIiksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGxldmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtsZXZlbH1cbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKSB7XG4gICAgbGV0IGUgPSB0aGlzLmxldmVscy5maW5kKCh0KSA9PiB0Lm51bWJlciA9PT0gdGhpcy5fZGF0YS5sZXZlbCk7XG4gICAgcmV0dXJuIGUgfHwgKGUgPSB0aGlzLmRlZmF1bHRMZXZlbCksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBkZWZhdWx0IGxldmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtsZXZlbH1cbiAgICovXG4gIGdldCBkZWZhdWx0TGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmRlZmF1bHRMZXZlbCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMubGV2ZWxzLmZpbmQoKHQpID0+IHQubnVtYmVyID09PSB0aGlzLl9zZXR0aW5ncy5kZWZhdWx0TGV2ZWwpO1xuICAgICAgaWYgKGUpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgY29uc29sZS53YXJuKFwiKOC4hyfMgC0nzIEp4LiHIEhlYWRpbmcgVG9vbDogdGhlIGRlZmF1bHQgbGV2ZWwgc3BlY2lmaWVkIHdhcyBub3QgZm91bmQgaW4gYXZhaWxhYmxlIGxldmVsc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxzWzFdO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBsZXZlbFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbnVtYmVyIC0gbGV2ZWwgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgLSB0YWcgY29ycmVzcG9uZHMgd2l0aCBsZXZlbCBudW1iZXJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN2ZyAtIGljb25cbiAgICovXG4gIC8qKlxuICAgKiBBdmFpbGFibGUgaGVhZGVyIGxldmVsc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWxbXX1cbiAgICovXG4gIGdldCBsZXZlbHMoKSB7XG4gICAgY29uc3QgZSA9IFtcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICB0YWc6IFwiSDFcIixcbiAgICAgICAgc3ZnOiBhXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgIHRhZzogXCJIMlwiLFxuICAgICAgICBzdmc6IGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMyxcbiAgICAgICAgdGFnOiBcIkgzXCIsXG4gICAgICAgIHN2Zzogb1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICB0YWc6IFwiSDRcIixcbiAgICAgICAgc3ZnOiBoXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDUsXG4gICAgICAgIHRhZzogXCJINVwiLFxuICAgICAgICBzdmc6IGRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNixcbiAgICAgICAgdGFnOiBcIkg2XCIsXG4gICAgICAgIHN2ZzogdVxuICAgICAgfVxuICAgIF07XG4gICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmxldmVscyA/IGUuZmlsdGVyKFxuICAgICAgKHQpID0+IHRoaXMuX3NldHRpbmdzLmxldmVscy5pbmNsdWRlcyh0Lm51bWJlcilcbiAgICApIDogZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIEgxLUg2IHRhZ3Mgb24gcGFzdGUgdG8gc3Vic3RpdHV0ZSBpdCB3aXRoIGhlYWRlciBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBjb250ZW50XG4gICAqL1xuICBvblBhc3RlKGUpIHtcbiAgICBjb25zdCB0ID0gZS5kZXRhaWw7XG4gICAgaWYgKFwiZGF0YVwiIGluIHQpIHtcbiAgICAgIGNvbnN0IHMgPSB0LmRhdGE7XG4gICAgICBsZXQgciA9IHRoaXMuZGVmYXVsdExldmVsLm51bWJlcjtcbiAgICAgIHN3aXRjaCAocy50YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgXCJIMVwiOlxuICAgICAgICAgIHIgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSDJcIjpcbiAgICAgICAgICByID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkgzXCI6XG4gICAgICAgICAgciA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJINFwiOlxuICAgICAgICAgIHIgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSDVcIjpcbiAgICAgICAgICByID0gNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkg2XCI6XG4gICAgICAgICAgciA9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXR0aW5ncy5sZXZlbHMgJiYgKHIgPSB0aGlzLl9zZXR0aW5ncy5sZXZlbHMucmVkdWNlKChuLCBpKSA9PiBNYXRoLmFicyhpIC0gcikgPCBNYXRoLmFicyhuIC0gcikgPyBpIDogbikpLCB0aGlzLmRhdGEgPSB7XG4gICAgICAgIGxldmVsOiByLFxuICAgICAgICB0ZXh0OiBzLmlubmVySFRNTFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYnkgRWRpdG9yLmpzIHBhc3RlIGhhbmRsaW5nIEFQSS5cbiAgICogUHJvdmlkZXMgY29uZmlndXJhdGlvbiB0byBoYW5kbGUgSDEtSDYgdGFncy5cbiAgICpcbiAgICogQHJldHVybnMge3toYW5kbGVyOiAoZnVuY3Rpb24oSFRNTEVsZW1lbnQpOiB7dGV4dDogc3RyaW5nfSksIHRhZ3M6IHN0cmluZ1tdfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIkgxXCIsIFwiSDJcIiwgXCJIM1wiLCBcIkg0XCIsIFwiSDVcIiwgXCJINlwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUb29sIHRvb2xib3ggc2V0dGluZ3NcbiAgICogaWNvbiAtIFRvb2wgaWNvbidzIFNWR1xuICAgKiB0aXRsZSAtIHRpdGxlIHRvIHNob3cgaW4gdG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7e2ljb246IHN0cmluZywgdGl0bGU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGcsXG4gICAgICB0aXRsZTogXCJIZWFkaW5nXCJcbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICB2IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/header/dist/header.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/image/dist/image.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/image/dist/image.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ P)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode('.image-tool{--bg-color: #cdd1e0;--front-color: #388ae5;--border-color: #e8e8eb}.image-tool__image{border-radius:3px;overflow:hidden;margin-bottom:10px}.image-tool__image-picture{max-width:100%;vertical-align:bottom;display:block}.image-tool__image-preloader{width:50px;height:50px;border-radius:50%;background-size:cover;margin:auto;position:relative;background-color:var(--bg-color);background-position:center center}.image-tool__image-preloader:after{content:\"\";position:absolute;z-index:3;width:60px;height:60px;border-radius:50%;border:2px solid var(--bg-color);border-top-color:var(--front-color);left:50%;top:50%;margin-top:-30px;margin-left:-30px;animation:image-preloader-spin 2s infinite linear;box-sizing:border-box}.image-tool__caption{display:none}.image-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute!important;content:attr(data-placeholder);color:#707684;font-weight:400;display:none}.image-tool__caption[contentEditable=true][data-placeholder]:empty:before{display:block}.image-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{display:none}.image-tool--empty .image-tool__image{display:none}.image-tool--empty .image-tool__caption,.image-tool--uploading .image-tool__caption{display:none!important}.image-tool .cdx-button{display:flex;align-items:center;justify-content:center}.image-tool .cdx-button svg{height:auto;margin:0 6px 0 0}.image-tool--filled .cdx-button,.image-tool--filled .image-tool__image-preloader{display:none}.image-tool--uploading .image-tool__image{min-height:200px;display:flex;border:1px solid var(--border-color);background-color:#fff}.image-tool--uploading .image-tool__image-picture,.image-tool--uploading .cdx-button{display:none}.image-tool--withBorder .image-tool__image{border:1px solid var(--border-color)}.image-tool--withBackground .image-tool__image{padding:15px;background:var(--bg-color)}.image-tool--withBackground .image-tool__image-picture{max-width:60%;margin:0 auto}.image-tool--stretched .image-tool__image-picture{width:100%}.image-tool--caption .image-tool__caption{display:block}@keyframes image-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')),document.head.appendChild(o)}}catch(e){console.error(\"vite-plugin-css-injected-by-js\",e)}})();\nconst R = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6.5 17.5L17.5 6.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 10.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10.9919 19H11.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 13L13 5\"/></svg>', I = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 9.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.5 5H14.5096\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 5H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 9.5H5.00957\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 19H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 14.55H5.00957\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/></svg>', L = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13.7778 9.33331H13.7867\"/></svg>', x = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17 9L20 12L17 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14 12H20\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 9L4 12L7 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 12H10\"/></svg>', B = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction M(C, i = null, a = {}) {\n  const s = document.createElement(C);\n  Array.isArray(i) ? s.classList.add(...i) : i !== null && s.classList.add(i);\n  for (const r in a)\n    a.hasOwnProperty(r) && (s[r] = a[r]);\n  return s;\n}\nvar S = /* @__PURE__ */ ((C) => (C.Empty = \"empty\", C.Uploading = \"uploading\", C.Filled = \"filled\", C))(S || {});\nclass U {\n  /**\n   * @param ui - image tool Ui module\n   * @param ui.api - Editor.js API\n   * @param ui.config - user config\n   * @param ui.onSelectFile - callback for clicks on Select file button\n   * @param ui.readOnly - read-only mode flag\n   */\n  constructor({ api: i, config: a, onSelectFile: s, readOnly: r }) {\n    this.api = i, this.config = a, this.onSelectFile = s, this.readOnly = r, this.nodes = {\n      wrapper: M(\"div\", [this.CSS.baseClass, this.CSS.wrapper]),\n      imageContainer: M(\"div\", [this.CSS.imageContainer]),\n      fileButton: this.createFileButton(),\n      imageEl: void 0,\n      imagePreloader: M(\"div\", this.CSS.imagePreloader),\n      caption: M(\"div\", [this.CSS.input, this.CSS.caption], {\n        contentEditable: !this.readOnly\n      })\n    }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);\n  }\n  /**\n   * Apply visual representation of activated tune\n   * @param tuneName - one of available tunes {@link Tunes.tunes}\n   * @param status - true for enable, false for disable\n   */\n  applyTune(i, a) {\n    this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${i}`, a);\n  }\n  /**\n   * Renders tool UI\n   * @param toolData - saved tool data\n   */\n  render(i) {\n    return i.file === void 0 || Object.keys(i.file).length === 0 ? this.toggleStatus(\n      \"empty\"\n      /* Empty */\n    ) : this.toggleStatus(\n      \"uploading\"\n      /* Uploading */\n    ), this.nodes.wrapper;\n  }\n  /**\n   * Shows uploading preloader\n   * @param src - preview source\n   */\n  showPreloader(i) {\n    this.nodes.imagePreloader.style.backgroundImage = `url(${i})`, this.toggleStatus(\n      \"uploading\"\n      /* Uploading */\n    );\n  }\n  /**\n   * Hide uploading preloader\n   */\n  hidePreloader() {\n    this.nodes.imagePreloader.style.backgroundImage = \"\", this.toggleStatus(\n      \"empty\"\n      /* Empty */\n    );\n  }\n  /**\n   * Shows an image\n   * @param url - image source\n   */\n  fillImage(i) {\n    const a = /\\.mp4$/.test(i) ? \"VIDEO\" : \"IMG\", s = {\n      src: i\n    };\n    let r = \"load\";\n    a === \"VIDEO\" && (s.autoplay = !0, s.loop = !0, s.muted = !0, s.playsinline = !0, r = \"loadeddata\"), this.nodes.imageEl = M(a, this.CSS.imageEl, s), this.nodes.imageEl.addEventListener(r, () => {\n      this.toggleStatus(\n        \"filled\"\n        /* Filled */\n      ), this.nodes.imagePreloader !== void 0 && (this.nodes.imagePreloader.style.backgroundImage = \"\");\n    }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);\n  }\n  /**\n   * Shows caption input\n   * @param text - caption content text\n   */\n  fillCaption(i) {\n    this.nodes.caption !== void 0 && (this.nodes.caption.innerHTML = i);\n  }\n  /**\n   * CSS classes\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      loading: this.api.styles.loader,\n      input: this.api.styles.input,\n      button: this.api.styles.button,\n      /**\n       * Tool's classes\n       */\n      wrapper: \"image-tool\",\n      imageContainer: \"image-tool__image\",\n      imagePreloader: \"image-tool__image-preloader\",\n      imageEl: \"image-tool__image-picture\",\n      caption: \"image-tool__caption\"\n    };\n  }\n  /**\n   * Creates upload-file button\n   */\n  createFileButton() {\n    const i = M(\"div\", [this.CSS.button]);\n    return i.innerHTML = this.config.buttonContent ?? `${L} ${this.api.i18n.t(\"Select an Image\")}`, i.addEventListener(\"click\", () => {\n      this.onSelectFile();\n    }), i;\n  }\n  /**\n   * Changes UI status\n   * @param status - see {@link Ui.status} constants\n   */\n  toggleStatus(i) {\n    for (const a in S)\n      Object.prototype.hasOwnProperty.call(S, a) && this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${S[a]}`, i === S[a]);\n  }\n}\nfunction D(C) {\n  return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, \"default\") ? C.default : C;\n}\nvar H = { exports: {} };\n(function(C, i) {\n  (function(a, s) {\n    C.exports = s();\n  })(window, function() {\n    return function(a) {\n      var s = {};\n      function r(e) {\n        if (s[e]) return s[e].exports;\n        var o = s[e] = { i: e, l: !1, exports: {} };\n        return a[e].call(o.exports, o, o.exports, r), o.l = !0, o.exports;\n      }\n      return r.m = a, r.c = s, r.d = function(e, o, d) {\n        r.o(e, o) || Object.defineProperty(e, o, { enumerable: !0, get: d });\n      }, r.r = function(e) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e, \"__esModule\", { value: !0 });\n      }, r.t = function(e, o) {\n        if (1 & o && (e = r(e)), 8 & o || 4 & o && typeof e == \"object\" && e && e.__esModule) return e;\n        var d = /* @__PURE__ */ Object.create(null);\n        if (r.r(d), Object.defineProperty(d, \"default\", { enumerable: !0, value: e }), 2 & o && typeof e != \"string\") for (var v in e) r.d(d, v, (function(l) {\n          return e[l];\n        }).bind(null, v));\n        return d;\n      }, r.n = function(e) {\n        var o = e && e.__esModule ? function() {\n          return e.default;\n        } : function() {\n          return e;\n        };\n        return r.d(o, \"a\", o), o;\n      }, r.o = function(e, o) {\n        return Object.prototype.hasOwnProperty.call(e, o);\n      }, r.p = \"\", r(r.s = 3);\n    }([function(a, s) {\n      var r;\n      r = /* @__PURE__ */ function() {\n        return this;\n      }();\n      try {\n        r = r || new Function(\"return this\")();\n      } catch {\n        typeof window == \"object\" && (r = window);\n      }\n      a.exports = r;\n    }, function(a, s, r) {\n      (function(e) {\n        var o = r(2), d = setTimeout;\n        function v() {\n        }\n        function l(n) {\n          if (!(this instanceof l)) throw new TypeError(\"Promises must be constructed via new\");\n          if (typeof n != \"function\") throw new TypeError(\"not a function\");\n          this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], t(n, this);\n        }\n        function f(n, c) {\n          for (; n._state === 3; ) n = n._value;\n          n._state !== 0 ? (n._handled = !0, l._immediateFn(function() {\n            var u = n._state === 1 ? c.onFulfilled : c.onRejected;\n            if (u !== null) {\n              var g;\n              try {\n                g = u(n._value);\n              } catch (m) {\n                return void y(c.promise, m);\n              }\n              p(c.promise, g);\n            } else (n._state === 1 ? p : y)(c.promise, n._value);\n          })) : n._deferreds.push(c);\n        }\n        function p(n, c) {\n          try {\n            if (c === n) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            if (c && (typeof c == \"object\" || typeof c == \"function\")) {\n              var u = c.then;\n              if (c instanceof l) return n._state = 3, n._value = c, void w(n);\n              if (typeof u == \"function\") return void t((g = u, m = c, function() {\n                g.apply(m, arguments);\n              }), n);\n            }\n            n._state = 1, n._value = c, w(n);\n          } catch (h) {\n            y(n, h);\n          }\n          var g, m;\n        }\n        function y(n, c) {\n          n._state = 2, n._value = c, w(n);\n        }\n        function w(n) {\n          n._state === 2 && n._deferreds.length === 0 && l._immediateFn(function() {\n            n._handled || l._unhandledRejectionFn(n._value);\n          });\n          for (var c = 0, u = n._deferreds.length; c < u; c++) f(n, n._deferreds[c]);\n          n._deferreds = null;\n        }\n        function b(n, c, u) {\n          this.onFulfilled = typeof n == \"function\" ? n : null, this.onRejected = typeof c == \"function\" ? c : null, this.promise = u;\n        }\n        function t(n, c) {\n          var u = !1;\n          try {\n            n(function(g) {\n              u || (u = !0, p(c, g));\n            }, function(g) {\n              u || (u = !0, y(c, g));\n            });\n          } catch (g) {\n            if (u) return;\n            u = !0, y(c, g);\n          }\n        }\n        l.prototype.catch = function(n) {\n          return this.then(null, n);\n        }, l.prototype.then = function(n, c) {\n          var u = new this.constructor(v);\n          return f(this, new b(n, c, u)), u;\n        }, l.prototype.finally = o.a, l.all = function(n) {\n          return new l(function(c, u) {\n            if (!n || n.length === void 0) throw new TypeError(\"Promise.all accepts an array\");\n            var g = Array.prototype.slice.call(n);\n            if (g.length === 0) return c([]);\n            var m = g.length;\n            function h(T, E) {\n              try {\n                if (E && (typeof E == \"object\" || typeof E == \"function\")) {\n                  var j = E.then;\n                  if (typeof j == \"function\") return void j.call(E, function(F) {\n                    h(T, F);\n                  }, u);\n                }\n                g[T] = E, --m == 0 && c(g);\n              } catch (F) {\n                u(F);\n              }\n            }\n            for (var k = 0; k < g.length; k++) h(k, g[k]);\n          });\n        }, l.resolve = function(n) {\n          return n && typeof n == \"object\" && n.constructor === l ? n : new l(function(c) {\n            c(n);\n          });\n        }, l.reject = function(n) {\n          return new l(function(c, u) {\n            u(n);\n          });\n        }, l.race = function(n) {\n          return new l(function(c, u) {\n            for (var g = 0, m = n.length; g < m; g++) n[g].then(c, u);\n          });\n        }, l._immediateFn = typeof e == \"function\" && function(n) {\n          e(n);\n        } || function(n) {\n          d(n, 0);\n        }, l._unhandledRejectionFn = function(n) {\n          typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", n);\n        }, s.a = l;\n      }).call(this, r(5).setImmediate);\n    }, function(a, s, r) {\n      s.a = function(e) {\n        var o = this.constructor;\n        return this.then(function(d) {\n          return o.resolve(e()).then(function() {\n            return d;\n          });\n        }, function(d) {\n          return o.resolve(e()).then(function() {\n            return o.reject(d);\n          });\n        });\n      };\n    }, function(a, s, r) {\n      function e(t) {\n        return (e = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(n) {\n          return typeof n;\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : typeof n;\n        })(t);\n      }\n      r(4);\n      var o, d, v, l, f, p, y, w = r(8), b = (d = function(t) {\n        return new Promise(function(n, c) {\n          t = l(t), (t = f(t)).beforeSend && t.beforeSend();\n          var u = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n          u.open(t.method, t.url), u.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), Object.keys(t.headers).forEach(function(m) {\n            var h = t.headers[m];\n            u.setRequestHeader(m, h);\n          });\n          var g = t.ratio;\n          u.upload.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * g / 100);\n            t.progress(Math.min(k, 100));\n          }, !1), u.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * (100 - g) / 100) + g;\n            t.progress(Math.min(k, 100));\n          }, !1), u.onreadystatechange = function() {\n            if (u.readyState === 4) {\n              var m = u.response;\n              try {\n                m = JSON.parse(m);\n              } catch {\n              }\n              var h = w.parseHeaders(u.getAllResponseHeaders()), k = { body: m, code: u.status, headers: h };\n              y(u.status) ? n(k) : c(k);\n            }\n          }, u.send(t.data);\n        });\n      }, v = function(t) {\n        return t.method = \"POST\", d(t);\n      }, l = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (t.url && typeof t.url != \"string\") throw new Error(\"Url must be a string\");\n        if (t.url = t.url || \"\", t.method && typeof t.method != \"string\") throw new Error(\"`method` must be a string or null\");\n        if (t.method = t.method ? t.method.toUpperCase() : \"GET\", t.headers && e(t.headers) !== \"object\") throw new Error(\"`headers` must be an object or null\");\n        if (t.headers = t.headers || {}, t.type && (typeof t.type != \"string\" || !Object.values(o).includes(t.type))) throw new Error(\"`type` must be taken from module's «contentType» library\");\n        if (t.progress && typeof t.progress != \"function\") throw new Error(\"`progress` must be a function or null\");\n        if (t.progress = t.progress || function(n) {\n        }, t.beforeSend = t.beforeSend || function(n) {\n        }, t.ratio && typeof t.ratio != \"number\") throw new Error(\"`ratio` must be a number\");\n        if (t.ratio < 0 || t.ratio > 100) throw new Error(\"`ratio` must be in a 0-100 interval\");\n        if (t.ratio = t.ratio || 90, t.accept && typeof t.accept != \"string\") throw new Error(\"`accept` must be a string with a list of allowed mime-types\");\n        if (t.accept = t.accept || \"*/*\", t.multiple && typeof t.multiple != \"boolean\") throw new Error(\"`multiple` must be a true or false\");\n        if (t.multiple = t.multiple || !1, t.fieldName && typeof t.fieldName != \"string\") throw new Error(\"`fieldName` must be a string\");\n        return t.fieldName = t.fieldName || \"files\", t;\n      }, f = function(t) {\n        switch (t.method) {\n          case \"GET\":\n            var n = p(t.data, o.URLENCODED);\n            delete t.data, t.url = /\\?/.test(t.url) ? t.url + \"&\" + n : t.url + \"?\" + n;\n            break;\n          case \"POST\":\n          case \"PUT\":\n          case \"DELETE\":\n          case \"UPDATE\":\n            var c = function() {\n              return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || o.JSON;\n            }(t);\n            (w.isFormData(t.data) || w.isFormElement(t.data)) && (c = o.FORM), t.data = p(t.data, c), c !== b.contentType.FORM && (t.headers[\"content-type\"] = c);\n        }\n        return t;\n      }, p = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        switch (arguments.length > 1 ? arguments[1] : void 0) {\n          case o.URLENCODED:\n            return w.urlEncode(t);\n          case o.JSON:\n            return w.jsonEncode(t);\n          case o.FORM:\n            return w.formEncode(t);\n          default:\n            return t;\n        }\n      }, y = function(t) {\n        return t >= 200 && t < 300;\n      }, { contentType: o = { URLENCODED: \"application/x-www-form-urlencoded; charset=utf-8\", FORM: \"multipart/form-data\", JSON: \"application/json; charset=utf-8\" }, request: d, get: function(t) {\n        return t.method = \"GET\", d(t);\n      }, post: v, transport: function(t) {\n        return t = l(t), w.selectFiles(t).then(function(n) {\n          for (var c = new FormData(), u = 0; u < n.length; u++) c.append(t.fieldName, n[u], n[u].name);\n          w.isObject(t.data) && Object.keys(t.data).forEach(function(m) {\n            var h = t.data[m];\n            c.append(m, h);\n          });\n          var g = t.beforeSend;\n          return t.beforeSend = function() {\n            return g(n);\n          }, t.data = c, v(t);\n        });\n      }, selectFiles: function(t) {\n        return delete (t = l(t)).beforeSend, w.selectFiles(t);\n      } });\n      a.exports = b;\n    }, function(a, s, r) {\n      r.r(s);\n      var e = r(1);\n      window.Promise = window.Promise || e.a;\n    }, function(a, s, r) {\n      (function(e) {\n        var o = e !== void 0 && e || typeof self < \"u\" && self || window, d = Function.prototype.apply;\n        function v(l, f) {\n          this._id = l, this._clearFn = f;\n        }\n        s.setTimeout = function() {\n          return new v(d.call(setTimeout, o, arguments), clearTimeout);\n        }, s.setInterval = function() {\n          return new v(d.call(setInterval, o, arguments), clearInterval);\n        }, s.clearTimeout = s.clearInterval = function(l) {\n          l && l.close();\n        }, v.prototype.unref = v.prototype.ref = function() {\n        }, v.prototype.close = function() {\n          this._clearFn.call(o, this._id);\n        }, s.enroll = function(l, f) {\n          clearTimeout(l._idleTimeoutId), l._idleTimeout = f;\n        }, s.unenroll = function(l) {\n          clearTimeout(l._idleTimeoutId), l._idleTimeout = -1;\n        }, s._unrefActive = s.active = function(l) {\n          clearTimeout(l._idleTimeoutId);\n          var f = l._idleTimeout;\n          f >= 0 && (l._idleTimeoutId = setTimeout(function() {\n            l._onTimeout && l._onTimeout();\n          }, f));\n        }, r(6), s.setImmediate = typeof self < \"u\" && self.setImmediate || e !== void 0 && e.setImmediate || this && this.setImmediate, s.clearImmediate = typeof self < \"u\" && self.clearImmediate || e !== void 0 && e.clearImmediate || this && this.clearImmediate;\n      }).call(this, r(0));\n    }, function(a, s, r) {\n      (function(e, o) {\n        (function(d, v) {\n          if (!d.setImmediate) {\n            var l, f, p, y, w, b = 1, t = {}, n = !1, c = d.document, u = Object.getPrototypeOf && Object.getPrototypeOf(d);\n            u = u && u.setTimeout ? u : d, {}.toString.call(d.process) === \"[object process]\" ? l = function(h) {\n              o.nextTick(function() {\n                m(h);\n              });\n            } : function() {\n              if (d.postMessage && !d.importScripts) {\n                var h = !0, k = d.onmessage;\n                return d.onmessage = function() {\n                  h = !1;\n                }, d.postMessage(\"\", \"*\"), d.onmessage = k, h;\n              }\n            }() ? (y = \"setImmediate$\" + Math.random() + \"$\", w = function(h) {\n              h.source === d && typeof h.data == \"string\" && h.data.indexOf(y) === 0 && m(+h.data.slice(y.length));\n            }, d.addEventListener ? d.addEventListener(\"message\", w, !1) : d.attachEvent(\"onmessage\", w), l = function(h) {\n              d.postMessage(y + h, \"*\");\n            }) : d.MessageChannel ? ((p = new MessageChannel()).port1.onmessage = function(h) {\n              m(h.data);\n            }, l = function(h) {\n              p.port2.postMessage(h);\n            }) : c && \"onreadystatechange\" in c.createElement(\"script\") ? (f = c.documentElement, l = function(h) {\n              var k = c.createElement(\"script\");\n              k.onreadystatechange = function() {\n                m(h), k.onreadystatechange = null, f.removeChild(k), k = null;\n              }, f.appendChild(k);\n            }) : l = function(h) {\n              setTimeout(m, 0, h);\n            }, u.setImmediate = function(h) {\n              typeof h != \"function\" && (h = new Function(\"\" + h));\n              for (var k = new Array(arguments.length - 1), T = 0; T < k.length; T++) k[T] = arguments[T + 1];\n              var E = { callback: h, args: k };\n              return t[b] = E, l(b), b++;\n            }, u.clearImmediate = g;\n          }\n          function g(h) {\n            delete t[h];\n          }\n          function m(h) {\n            if (n) setTimeout(m, 0, h);\n            else {\n              var k = t[h];\n              if (k) {\n                n = !0;\n                try {\n                  (function(T) {\n                    var E = T.callback, j = T.args;\n                    switch (j.length) {\n                      case 0:\n                        E();\n                        break;\n                      case 1:\n                        E(j[0]);\n                        break;\n                      case 2:\n                        E(j[0], j[1]);\n                        break;\n                      case 3:\n                        E(j[0], j[1], j[2]);\n                        break;\n                      default:\n                        E.apply(v, j);\n                    }\n                  })(k);\n                } finally {\n                  g(h), n = !1;\n                }\n              }\n            }\n          }\n        })(typeof self > \"u\" ? e === void 0 ? this : e : self);\n      }).call(this, r(0), r(7));\n    }, function(a, s) {\n      var r, e, o = a.exports = {};\n      function d() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function v() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      function l(u) {\n        if (r === setTimeout) return setTimeout(u, 0);\n        if ((r === d || !r) && setTimeout) return r = setTimeout, setTimeout(u, 0);\n        try {\n          return r(u, 0);\n        } catch {\n          try {\n            return r.call(null, u, 0);\n          } catch {\n            return r.call(this, u, 0);\n          }\n        }\n      }\n      (function() {\n        try {\n          r = typeof setTimeout == \"function\" ? setTimeout : d;\n        } catch {\n          r = d;\n        }\n        try {\n          e = typeof clearTimeout == \"function\" ? clearTimeout : v;\n        } catch {\n          e = v;\n        }\n      })();\n      var f, p = [], y = !1, w = -1;\n      function b() {\n        y && f && (y = !1, f.length ? p = f.concat(p) : w = -1, p.length && t());\n      }\n      function t() {\n        if (!y) {\n          var u = l(b);\n          y = !0;\n          for (var g = p.length; g; ) {\n            for (f = p, p = []; ++w < g; ) f && f[w].run();\n            w = -1, g = p.length;\n          }\n          f = null, y = !1, function(m) {\n            if (e === clearTimeout) return clearTimeout(m);\n            if ((e === v || !e) && clearTimeout) return e = clearTimeout, clearTimeout(m);\n            try {\n              e(m);\n            } catch {\n              try {\n                return e.call(null, m);\n              } catch {\n                return e.call(this, m);\n              }\n            }\n          }(u);\n        }\n      }\n      function n(u, g) {\n        this.fun = u, this.array = g;\n      }\n      function c() {\n      }\n      o.nextTick = function(u) {\n        var g = new Array(arguments.length - 1);\n        if (arguments.length > 1) for (var m = 1; m < arguments.length; m++) g[m - 1] = arguments[m];\n        p.push(new n(u, g)), p.length !== 1 || y || l(t);\n      }, n.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      }, o.title = \"browser\", o.browser = !0, o.env = {}, o.argv = [], o.version = \"\", o.versions = {}, o.on = c, o.addListener = c, o.once = c, o.off = c, o.removeListener = c, o.removeAllListeners = c, o.emit = c, o.prependListener = c, o.prependOnceListener = c, o.listeners = function(u) {\n        return [];\n      }, o.binding = function(u) {\n        throw new Error(\"process.binding is not supported\");\n      }, o.cwd = function() {\n        return \"/\";\n      }, o.chdir = function(u) {\n        throw new Error(\"process.chdir is not supported\");\n      }, o.umask = function() {\n        return 0;\n      };\n    }, function(a, s, r) {\n      function e(d, v) {\n        for (var l = 0; l < v.length; l++) {\n          var f = v[l];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(d, f.key, f);\n        }\n      }\n      var o = r(9);\n      a.exports = function() {\n        function d() {\n          (function(p, y) {\n            if (!(p instanceof y)) throw new TypeError(\"Cannot call a class as a function\");\n          })(this, d);\n        }\n        var v, l, f;\n        return v = d, f = [{ key: \"urlEncode\", value: function(p) {\n          return o(p);\n        } }, { key: \"jsonEncode\", value: function(p) {\n          return JSON.stringify(p);\n        } }, { key: \"formEncode\", value: function(p) {\n          if (this.isFormData(p)) return p;\n          if (this.isFormElement(p)) return new FormData(p);\n          if (this.isObject(p)) {\n            var y = new FormData();\n            return Object.keys(p).forEach(function(w) {\n              var b = p[w];\n              y.append(w, b);\n            }), y;\n          }\n          throw new Error(\"`data` must be an instance of Object, FormData or <FORM> HTMLElement\");\n        } }, { key: \"isObject\", value: function(p) {\n          return Object.prototype.toString.call(p) === \"[object Object]\";\n        } }, { key: \"isFormData\", value: function(p) {\n          return p instanceof FormData;\n        } }, { key: \"isFormElement\", value: function(p) {\n          return p instanceof HTMLFormElement;\n        } }, { key: \"selectFiles\", value: function() {\n          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n          return new Promise(function(y, w) {\n            var b = document.createElement(\"INPUT\");\n            b.type = \"file\", p.multiple && b.setAttribute(\"multiple\", \"multiple\"), p.accept && b.setAttribute(\"accept\", p.accept), b.style.display = \"none\", document.body.appendChild(b), b.addEventListener(\"change\", function(t) {\n              var n = t.target.files;\n              y(n), document.body.removeChild(b);\n            }, !1), b.click();\n          });\n        } }, { key: \"parseHeaders\", value: function(p) {\n          var y = p.trim().split(/[\\r\\n]+/), w = {};\n          return y.forEach(function(b) {\n            var t = b.split(\": \"), n = t.shift(), c = t.join(\": \");\n            n && (w[n] = c);\n          }), w;\n        } }], (l = null) && e(v.prototype, l), f && e(v, f), d;\n      }();\n    }, function(a, s) {\n      var r = function(o) {\n        return encodeURIComponent(o).replace(/[!'()*]/g, escape).replace(/%20/g, \"+\");\n      }, e = function(o, d, v, l) {\n        return d = d || null, v = v || \"&\", l = l || null, o ? function(f) {\n          for (var p = new Array(), y = 0; y < f.length; y++) f[y] && p.push(f[y]);\n          return p;\n        }(Object.keys(o).map(function(f) {\n          var p, y, w = f;\n          if (l && (w = l + \"[\" + w + \"]\"), typeof o[f] == \"object\" && o[f] !== null) p = e(o[f], null, v, w);\n          else {\n            d && (y = w, w = !isNaN(parseFloat(y)) && isFinite(y) ? d + Number(w) : w);\n            var b = o[f];\n            b = (b = (b = (b = b === !0 ? \"1\" : b) === !1 ? \"0\" : b) === 0 ? \"0\" : b) || \"\", p = r(w) + \"=\" + r(b);\n          }\n          return p;\n        })).join(v).replace(/[!'()*]/g, \"\") : \"\";\n      };\n      a.exports = e;\n    }]);\n  });\n})(H);\nvar q = H.exports;\nconst _ = /* @__PURE__ */ D(q);\nfunction O(C) {\n  return C !== void 0 && typeof C.then == \"function\";\n}\nclass A {\n  /**\n   * @param params - uploader module params\n   * @param params.config - image tool config\n   * @param params.onUpload - one callback for all uploading (file, url, d-n-d, pasting)\n   * @param params.onError - callback for uploading errors\n   */\n  constructor({ config: i, onUpload: a, onError: s }) {\n    this.config = i, this.onUpload = a, this.onError = s;\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.transport()\n   * @param onPreview - callback fired when preview is ready\n   */\n  uploadSelectedFile({ onPreview: i }) {\n    const a = function(r) {\n      const e = new FileReader();\n      e.readAsDataURL(r), e.onload = (o) => {\n        i(o.target.result);\n      };\n    };\n    let s;\n    if (this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\") {\n      const r = this.config.uploader.uploadByFile;\n      s = _.selectFiles({ accept: this.config.types ?? \"image/*\" }).then((e) => {\n        a(e[0]);\n        const o = r(e[0]);\n        return O(o) || console.warn(\"Custom uploader method uploadByFile should return a Promise\"), o;\n      });\n    } else\n      s = _.transport({\n        url: this.config.endpoints.byFile,\n        data: this.config.additionalRequestData,\n        accept: this.config.types ?? \"image/*\",\n        headers: this.config.additionalRequestHeaders,\n        beforeSend: (r) => {\n          a(r[0]);\n        },\n        fieldName: this.config.field ?? \"image\"\n      }).then((r) => r.body);\n    s.then((r) => {\n      this.onUpload(r);\n    }).catch((r) => {\n      this.onError(r);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   * @param url - image source url\n   */\n  uploadByUrl(i) {\n    let a;\n    this.config.uploader && typeof this.config.uploader.uploadByUrl == \"function\" ? (a = this.config.uploader.uploadByUrl(i), O(a) || console.warn(\"Custom uploader method uploadByUrl should return a Promise\")) : a = _.post({\n      url: this.config.endpoints.byUrl,\n      data: Object.assign({\n        url: i\n      }, this.config.additionalRequestData),\n      type: _.contentType.JSON,\n      headers: this.config.additionalRequestHeaders\n    }).then((s) => s.body), a.then((s) => {\n      this.onUpload(s);\n    }).catch((s) => {\n      this.onError(s);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   * @param file - file pasted by drag-n-drop\n   * @param onPreview - file pasted by drag-n-drop\n   */\n  uploadByFile(i, { onPreview: a }) {\n    const s = new FileReader();\n    s.readAsDataURL(i), s.onload = (e) => {\n      a(e.target.result);\n    };\n    let r;\n    if (this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\")\n      r = this.config.uploader.uploadByFile(i), O(r) || console.warn(\"Custom uploader method uploadByFile should return a Promise\");\n    else {\n      const e = new FormData();\n      e.append(this.config.field ?? \"image\", i), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(([o, d]) => {\n        e.append(o, d);\n      }), r = _.post({\n        url: this.config.endpoints.byFile,\n        data: e,\n        type: _.contentType.JSON,\n        headers: this.config.additionalRequestHeaders\n      }).then((o) => o.body);\n    }\n    r.then((e) => {\n      this.onUpload(e);\n    }).catch((e) => {\n      this.onError(e);\n    });\n  }\n}\n/**\n * Image Tool for the Editor.js\n * @author CodeX <team@codex.so>\n * @license MIT\n * @see {@link https://github.com/editor-js/image}\n *\n * To developers.\n * To simplify Tool structure, we split it to 4 parts:\n *  1) index.ts — main Tool's interface, public API and methods for working with data\n *  2) uploader.ts — module that has methods for sending files via AJAX: from device, by URL or File pasting\n *  3) ui.ts — module for UI manipulations: render, showing preloader, etc\n *\n * For debug purposes there is a testing server\n * that can save uploaded files and return a Response {@link UploadResponseFormat}\n *\n *       $ node dev/server.js\n *\n * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:\n *\n * image: {\n *   class: ImageTool,\n *   config: {\n *     endpoints: {\n *       byFile: 'http://localhost:8008/uploadFile',\n *       byUrl: 'http://localhost:8008/fetchUrl',\n *     }\n *   },\n * },\n */\nclass P {\n  /**\n   * @param tool - tool properties got from editor.js\n   * @param tool.data - previously saved data\n   * @param tool.config - user config for Tool\n   * @param tool.api - Editor.js API\n   * @param tool.readOnly - read-only mode flag\n   * @param tool.block - current Block API\n   */\n  constructor({ data: i, config: a, api: s, readOnly: r, block: e }) {\n    this.api = s, this.block = e, this.config = {\n      endpoints: a.endpoints,\n      additionalRequestData: a.additionalRequestData,\n      additionalRequestHeaders: a.additionalRequestHeaders,\n      field: a.field,\n      types: a.types,\n      captionPlaceholder: this.api.i18n.t(a.captionPlaceholder ?? \"Caption\"),\n      buttonContent: a.buttonContent,\n      uploader: a.uploader,\n      actions: a.actions,\n      features: a.features || {}\n    }, this.uploader = new A({\n      config: this.config,\n      onUpload: (o) => this.onUpload(o),\n      onError: (o) => this.uploadingFailed(o)\n    }), this.ui = new U({\n      api: s,\n      config: this.config,\n      onSelectFile: () => {\n        this.uploader.uploadSelectedFile({\n          onPreview: (o) => {\n            this.ui.showPreloader(o);\n          }\n        });\n      },\n      readOnly: r\n    }), this._data = {\n      caption: \"\",\n      withBorder: !1,\n      withBackground: !1,\n      stretched: !1,\n      file: {\n        url: \"\"\n      }\n    }, this.data = i;\n  }\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   */\n  static get toolbox() {\n    return {\n      icon: L,\n      title: \"Image\"\n    };\n  }\n  /**\n   * Available image tools\n   */\n  static get tunes() {\n    return [\n      {\n        name: \"withBorder\",\n        icon: I,\n        title: \"With border\",\n        toggle: !0\n      },\n      {\n        name: \"stretched\",\n        icon: x,\n        title: \"Stretch image\",\n        toggle: !0\n      },\n      {\n        name: \"withBackground\",\n        icon: R,\n        title: \"With background\",\n        toggle: !0\n      }\n    ];\n  }\n  /**\n   * Renders Block content\n   */\n  render() {\n    var i, a, s;\n    return (((i = this.config.features) == null ? void 0 : i.caption) === !0 || ((a = this.config.features) == null ? void 0 : a.caption) === void 0 || ((s = this.config.features) == null ? void 0 : s.caption) === \"optional\" && this.data.caption) && this.ui.applyTune(\"caption\", !0), this.ui.render(this.data);\n  }\n  /**\n   * Validate data: check if Image exists\n   * @param savedData — data received after saving\n   * @returns false if saved data is not correct, otherwise true\n   */\n  validate(i) {\n    return !!i.file.url;\n  }\n  /**\n   * Return Block data\n   */\n  save() {\n    const i = this.ui.nodes.caption;\n    return this._data.caption = i.innerHTML, this.data;\n  }\n  /**\n   * Returns configuration for block tunes: add background, add border, stretch image\n   * @returns TunesMenuConfig\n   */\n  renderSettings() {\n    var r;\n    const i = P.tunes.concat(this.config.actions || []), a = {\n      border: \"withBorder\",\n      background: \"withBackground\",\n      stretch: \"stretched\",\n      caption: \"caption\"\n    };\n    return ((r = this.config.features) == null ? void 0 : r.caption) === \"optional\" && i.push({\n      name: \"caption\",\n      icon: B,\n      title: \"With caption\",\n      toggle: !0\n    }), i.filter((e) => {\n      var d, v;\n      const o = Object.keys(a).find((l) => a[l] === e.name);\n      return o === \"caption\" ? ((d = this.config.features) == null ? void 0 : d.caption) !== !1 : o == null || ((v = this.config.features) == null ? void 0 : v[o]) !== !1;\n    }).map((e) => ({\n      icon: e.icon,\n      label: this.api.i18n.t(e.title),\n      name: e.name,\n      toggle: e.toggle,\n      isActive: this.data[e.name],\n      onActivate: () => {\n        if (typeof e.action == \"function\") {\n          e.action(e.name);\n          return;\n        }\n        this.tuneToggled(e.name);\n      }\n    }));\n  }\n  /**\n   * Fires after clicks on the Toolbox Image Icon\n   * Initiates click on the Select File button\n   */\n  appendCallback() {\n    this.ui.nodes.fileButton.click();\n  }\n  /**\n   * Specify paste substitutes\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   */\n  static get pasteConfig() {\n    return {\n      /**\n       * Paste HTML into Editor\n       */\n      tags: [\n        {\n          img: { src: !0 }\n        }\n      ],\n      /**\n       * Paste URL of image into the Editor\n       */\n      patterns: {\n        image: /https?:\\/\\/\\S+\\.(gif|jpe?g|tiff|png|svg|webp)(\\?[a-z0-9=]*)?$/i\n      },\n      /**\n       * Drag n drop file from into the Editor\n       */\n      files: {\n        mimeTypes: [\"image/*\"]\n      }\n    };\n  }\n  /**\n   * Specify paste handlers\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   * @param event - editor.js custom paste event\n   *                              {@link https://github.com/codex-team/editor.js/blob/master/types/tools/paste-events.d.ts}\n   */\n  async onPaste(i) {\n    switch (i.type) {\n      case \"tag\": {\n        const a = i.detail.data;\n        if (/^blob:/.test(a.src)) {\n          const r = await (await fetch(a.src)).blob();\n          this.uploadFile(r);\n          break;\n        }\n        this.uploadUrl(a.src);\n        break;\n      }\n      case \"pattern\": {\n        const a = i.detail.data;\n        this.uploadUrl(a);\n        break;\n      }\n      case \"file\": {\n        const a = i.detail.file;\n        this.uploadFile(a);\n        break;\n      }\n    }\n  }\n  /**\n   * Private methods\n   * ̿̿ ̿̿ ̿̿ ̿'̿'\\̵͇̿̿\\з= ( ▀ ͜͞ʖ▀) =ε/̵͇̿̿/’̿’̿ ̿ ̿̿ ̿̿ ̿̿\n   */\n  /**\n   * Stores all Tool's data\n   * @param data - data in Image Tool format\n   */\n  set data(i) {\n    this.image = i.file, this._data.caption = i.caption || \"\", this.ui.fillCaption(this._data.caption), P.tunes.forEach(({ name: a }) => {\n      const s = typeof i[a] < \"u\" ? i[a] === !0 || i[a] === \"true\" : !1;\n      this.setTune(a, s);\n    });\n  }\n  /**\n   * Return Tool data\n   */\n  get data() {\n    return this._data;\n  }\n  /**\n   * Set new image file\n   * @param file - uploaded file data\n   */\n  set image(i) {\n    this._data.file = i || { url: \"\" }, i && i.url && this.ui.fillImage(i.url);\n  }\n  /**\n   * File uploading callback\n   * @param response - uploading server response\n   */\n  onUpload(i) {\n    i.success && i.file ? this.image = i.file : this.uploadingFailed(\"incorrect response: \" + JSON.stringify(i));\n  }\n  /**\n   * Handle uploader errors\n   * @param errorText - uploading error info\n   */\n  uploadingFailed(i) {\n    console.log(\"Image Tool: uploading failed because of\", i), this.api.notifier.show({\n      message: this.api.i18n.t(\"Couldn’t upload image. Please try another.\"),\n      style: \"error\"\n    }), this.ui.hidePreloader();\n  }\n  /**\n   * Callback fired when Block Tune is activated\n   * @param tuneName - tune that has been clicked\n   */\n  tuneToggled(i) {\n    this.setTune(i, !this._data[i]), i === \"caption\" && !this._data[i] && (this._data.caption = \"\", this.ui.fillCaption(\"\"));\n  }\n  /**\n   * Set one tune\n   * @param tuneName - {@link Tunes.tunes}\n   * @param value - tune state\n   */\n  setTune(i, a) {\n    this._data[i] = a, this.ui.applyTune(i, a), i === \"stretched\" && Promise.resolve().then(() => {\n      this.block.stretched = a;\n    }).catch((s) => {\n      console.error(s);\n    });\n  }\n  /**\n   * Show preloader and upload image file\n   * @param file - file that is currently uploading (from paste)\n   */\n  uploadFile(i) {\n    this.uploader.uploadByFile(i, {\n      onPreview: (a) => {\n        this.ui.showPreloader(a);\n      }\n    });\n  }\n  /**\n   * Show preloader and upload image by target url\n   * @param url - url pasted\n   */\n  uploadUrl(i) {\n    this.ui.showPreloader(i), this.uploader.uploadByUrl(i);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2ltYWdlL2Rpc3QvaW1hZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLG1EQUFtRCxvQkFBb0IsdUJBQXVCLHdCQUF3QixtQkFBbUIsa0JBQWtCLGdCQUFnQixtQkFBbUIsMkJBQTJCLGVBQWUsc0JBQXNCLGNBQWMsNkJBQTZCLFdBQVcsWUFBWSxrQkFBa0Isc0JBQXNCLFlBQVksa0JBQWtCLGlDQUFpQyxrQ0FBa0MsbUNBQW1DLFdBQVcsa0JBQWtCLFVBQVUsV0FBVyxZQUFZLGtCQUFrQixpQ0FBaUMsb0NBQW9DLFNBQVMsUUFBUSxpQkFBaUIsa0JBQWtCLGtEQUFrRCxzQkFBc0IscUJBQXFCLGFBQWEsb0VBQW9FLDRCQUE0QiwrQkFBK0IsY0FBYyxnQkFBZ0IsYUFBYSwwRUFBMEUsY0FBYyxnRkFBZ0YsYUFBYSxzQ0FBc0MsYUFBYSxvRkFBb0YsdUJBQXVCLHdCQUF3QixhQUFhLG1CQUFtQix1QkFBdUIsNEJBQTRCLFlBQVksaUJBQWlCLGlGQUFpRixhQUFhLDBDQUEwQyxpQkFBaUIsYUFBYSxxQ0FBcUMsc0JBQXNCLHFGQUFxRixhQUFhLDJDQUEyQyxxQ0FBcUMsK0NBQStDLGFBQWEsMkJBQTJCLHVEQUF1RCxjQUFjLGNBQWMsa0RBQWtELFdBQVcsMENBQTBDLGNBQWMsZ0NBQWdDLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUNuMkU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNB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QUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsU0FBUztBQUNwSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2ltYWdlL2Rpc3QvaW1hZ2UubWpzPzczYTkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO28uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy5pbWFnZS10b29sey0tYmctY29sb3I6ICNjZGQxZTA7LS1mcm9udC1jb2xvcjogIzM4OGFlNTstLWJvcmRlci1jb2xvcjogI2U4ZThlYn0uaW1hZ2UtdG9vbF9faW1hZ2V7Ym9yZGVyLXJhZGl1czozcHg7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206MTBweH0uaW1hZ2UtdG9vbF9faW1hZ2UtcGljdHVyZXttYXgtd2lkdGg6MTAwJTt2ZXJ0aWNhbC1hbGlnbjpib3R0b207ZGlzcGxheTpibG9ja30uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1zaXplOmNvdmVyO21hcmdpbjphdXRvO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYmctY29sb3IpO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcn0uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVyOmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjM7d2lkdGg6NjBweDtoZWlnaHQ6NjBweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkIHZhcigtLWJnLWNvbG9yKTtib3JkZXItdG9wLWNvbG9yOnZhcigtLWZyb250LWNvbG9yKTtsZWZ0OjUwJTt0b3A6NTAlO21hcmdpbi10b3A6LTMwcHg7bWFyZ2luLWxlZnQ6LTMwcHg7YW5pbWF0aW9uOmltYWdlLXByZWxvYWRlci1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmltYWdlLXRvb2xfX2NhcHRpb257ZGlzcGxheTpub25lfS5pbWFnZS10b29sX19jYXB0aW9uW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyKTtjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjQwMDtkaXNwbGF5Om5vbmV9LmltYWdlLXRvb2xfX2NhcHRpb25bY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmJlZm9yZXtkaXNwbGF5OmJsb2NrfS5pbWFnZS10b29sX19jYXB0aW9uW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7ZGlzcGxheTpub25lfS5pbWFnZS10b29sLS1lbXB0eSAuaW1hZ2UtdG9vbF9faW1hZ2V7ZGlzcGxheTpub25lfS5pbWFnZS10b29sLS1lbXB0eSAuaW1hZ2UtdG9vbF9fY2FwdGlvbiwuaW1hZ2UtdG9vbC0tdXBsb2FkaW5nIC5pbWFnZS10b29sX19jYXB0aW9ue2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmltYWdlLXRvb2wgLmNkeC1idXR0b257ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5pbWFnZS10b29sIC5jZHgtYnV0dG9uIHN2Z3toZWlnaHQ6YXV0bzttYXJnaW46MCA2cHggMCAwfS5pbWFnZS10b29sLS1maWxsZWQgLmNkeC1idXR0b24sLmltYWdlLXRvb2wtLWZpbGxlZCAuaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye2Rpc3BsYXk6bm9uZX0uaW1hZ2UtdG9vbC0tdXBsb2FkaW5nIC5pbWFnZS10b29sX19pbWFnZXttaW4taGVpZ2h0OjIwMHB4O2Rpc3BsYXk6ZmxleDtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWJvcmRlci1jb2xvcik7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5pbWFnZS10b29sLS11cGxvYWRpbmcgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmUsLmltYWdlLXRvb2wtLXVwbG9hZGluZyAuY2R4LWJ1dHRvbntkaXNwbGF5Om5vbmV9LmltYWdlLXRvb2wtLXdpdGhCb3JkZXIgLmltYWdlLXRvb2xfX2ltYWdle2JvcmRlcjoxcHggc29saWQgdmFyKC0tYm9yZGVyLWNvbG9yKX0uaW1hZ2UtdG9vbC0td2l0aEJhY2tncm91bmQgLmltYWdlLXRvb2xfX2ltYWdle3BhZGRpbmc6MTVweDtiYWNrZ3JvdW5kOnZhcigtLWJnLWNvbG9yKX0uaW1hZ2UtdG9vbC0td2l0aEJhY2tncm91bmQgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmV7bWF4LXdpZHRoOjYwJTttYXJnaW46MCBhdXRvfS5pbWFnZS10b29sLS1zdHJldGNoZWQgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmV7d2lkdGg6MTAwJX0uaW1hZ2UtdG9vbC0tY2FwdGlvbiAuaW1hZ2UtdG9vbF9fY2FwdGlvbntkaXNwbGF5OmJsb2NrfUBrZXlmcmFtZXMgaW1hZ2UtcHJlbG9hZGVyLXNwaW57MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3t0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fScpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG8pfX1jYXRjaChlKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsZSl9fSkoKTtcbmNvbnN0IFIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTEgMTlWMTlDOS4xMzYyMyAxOSA4LjIwNDM1IDE5IDcuNDY5MjcgMTguNjk1NUM2LjQ4OTE1IDE4LjI4OTUgNS43MTA0NiAxNy41MTA4IDUuMzA0NDggMTYuNTMwN0M1IDE1Ljc5NTYgNSAxNC44NjM4IDUgMTNWMTJDNSA5LjE5MTA4IDUgNy43ODY2MSA1LjY3NDEyIDYuNzc3NzJDNS45NjU5NiA2LjM0MDk2IDYuMzQwOTYgNS45NjU5NiA2Ljc3NzcyIDUuNjc0MTJDNy43ODY2MSA1IDkuMTkxMDggNSAxMiA1SDEzLjVDMTQuODk1NiA1IDE1LjU5MzMgNSAxNi4xNjExIDUuMTcyMjRDMTcuNDM5NSA1LjU2MDA0IDE4LjQ0IDYuNTYwNDYgMTguODI3OCA3LjgzODg2QzE5IDguNDA2NjYgMTkgOS4xMDQ0NCAxOSAxMC41VjEwLjVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDEzVjE2TTE2IDE5VjE2TTE5IDE2SDE2TTE2IDE2SDEzXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYuNSAxNy41TDE3LjUgNi41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4Ljk5MTkgMTAuNUgxOS4wMDE1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEwLjk5MTkgMTlIMTEuMDAxNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDEzTDEzIDVcIi8+PC9zdmc+JywgSSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOC45OTE5IDkuNUgxOS4wMDE1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0LjUgNUgxNC41MDk2XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC42MjUgNUgxNUMxNy4yMDkxIDUgMTkgNi43OTA4NiAxOSA5VjkuMzc1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkuMzc1IDVMOSA1QzYuNzkwODYgNSA1IDYuNzkwODYgNSA5VjkuMzc1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkuMzcyNSA1SDkuMzgyMDdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSA5LjVINS4wMDk1N1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjM3NSAxOUg5QzYuNzkwODYgMTkgNSAxNy4yMDkxIDUgMTVWMTQuNjI1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkuMzcyNSAxOUg5LjM4MjA3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgMTQuNTVINS4wMDk1N1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTNWMTZNMTYgMTlWMTZNMTkgMTZIMTZNMTYgMTZIMTNcIi8+PC9zdmc+JywgTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cmVjdCB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB4PVwiNVwiIHk9XCI1XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHJ4PVwiNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjEzOTY4IDE1LjMyTDguNjkwNTggMTEuNTY2MUM5LjAyOTM0IDExLjIwMzYgOS40ODg3MyAxMSA5Ljk2Nzc0IDExQzEwLjQ0NjcgMTEgMTAuOTA2MSAxMS4yMDM2IDExLjI0NDkgMTEuNTY2MUwxNS4zODcxIDE2TTEzLjU4MDYgMTQuMDY2NEwxNS4wMTMyIDEyLjUzM0MxNS4zNTE5IDEyLjE3MDUgMTUuODExMyAxMS45NjY4IDE2LjI5MDMgMTEuOTY2OEMxNi43NjkzIDExLjk2NjggMTcuMjI4NyAxMi4xNzA1IDE3LjU2NzUgMTIuNTMzTDE4Ljg0MSAxMy45NjM0XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEzLjc3NzggOS4zMzMzMUgxMy43ODY3XCIvPjwvc3ZnPicsIHggPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTcgOUwyMCAxMkwxNyAxNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNCAxMkgyMFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDlMNCAxMkw3IDE1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTQgMTJIMTBcIi8+PC9zdmc+JywgQiA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xuZnVuY3Rpb24gTShDLCBpID0gbnVsbCwgYSA9IHt9KSB7XG4gIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEMpO1xuICBBcnJheS5pc0FycmF5KGkpID8gcy5jbGFzc0xpc3QuYWRkKC4uLmkpIDogaSAhPT0gbnVsbCAmJiBzLmNsYXNzTGlzdC5hZGQoaSk7XG4gIGZvciAoY29uc3QgciBpbiBhKVxuICAgIGEuaGFzT3duUHJvcGVydHkocikgJiYgKHNbcl0gPSBhW3JdKTtcbiAgcmV0dXJuIHM7XG59XG52YXIgUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEMpID0+IChDLkVtcHR5ID0gXCJlbXB0eVwiLCBDLlVwbG9hZGluZyA9IFwidXBsb2FkaW5nXCIsIEMuRmlsbGVkID0gXCJmaWxsZWRcIiwgQykpKFMgfHwge30pO1xuY2xhc3MgVSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdWkgLSBpbWFnZSB0b29sIFVpIG1vZHVsZVxuICAgKiBAcGFyYW0gdWkuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0gdWkuY29uZmlnIC0gdXNlciBjb25maWdcbiAgICogQHBhcmFtIHVpLm9uU2VsZWN0RmlsZSAtIGNhbGxiYWNrIGZvciBjbGlja3Mgb24gU2VsZWN0IGZpbGUgYnV0dG9uXG4gICAqIEBwYXJhbSB1aS5yZWFkT25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBpLCBjb25maWc6IGEsIG9uU2VsZWN0RmlsZTogcywgcmVhZE9ubHk6IHIgfSkge1xuICAgIHRoaXMuYXBpID0gaSwgdGhpcy5jb25maWcgPSBhLCB0aGlzLm9uU2VsZWN0RmlsZSA9IHMsIHRoaXMucmVhZE9ubHkgPSByLCB0aGlzLm5vZGVzID0ge1xuICAgICAgd3JhcHBlcjogTShcImRpdlwiLCBbdGhpcy5DU1MuYmFzZUNsYXNzLCB0aGlzLkNTUy53cmFwcGVyXSksXG4gICAgICBpbWFnZUNvbnRhaW5lcjogTShcImRpdlwiLCBbdGhpcy5DU1MuaW1hZ2VDb250YWluZXJdKSxcbiAgICAgIGZpbGVCdXR0b246IHRoaXMuY3JlYXRlRmlsZUJ1dHRvbigpLFxuICAgICAgaW1hZ2VFbDogdm9pZCAwLFxuICAgICAgaW1hZ2VQcmVsb2FkZXI6IE0oXCJkaXZcIiwgdGhpcy5DU1MuaW1hZ2VQcmVsb2FkZXIpLFxuICAgICAgY2FwdGlvbjogTShcImRpdlwiLCBbdGhpcy5DU1MuaW5wdXQsIHRoaXMuQ1NTLmNhcHRpb25dLCB7XG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogIXRoaXMucmVhZE9ubHlcbiAgICAgIH0pXG4gICAgfSwgdGhpcy5ub2Rlcy5jYXB0aW9uLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmNvbmZpZy5jYXB0aW9uUGxhY2Vob2xkZXIsIHRoaXMubm9kZXMuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlciksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmltYWdlQ29udGFpbmVyKSwgdGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuY2FwdGlvbiksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmZpbGVCdXR0b24pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBseSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgYWN0aXZhdGVkIHR1bmVcbiAgICogQHBhcmFtIHR1bmVOYW1lIC0gb25lIG9mIGF2YWlsYWJsZSB0dW5lcyB7QGxpbmsgVHVuZXMudHVuZXN9XG4gICAqIEBwYXJhbSBzdGF0dXMgLSB0cnVlIGZvciBlbmFibGUsIGZhbHNlIGZvciBkaXNhYmxlXG4gICAqL1xuICBhcHBseVR1bmUoaSwgYSkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKGAke3RoaXMuQ1NTLndyYXBwZXJ9LS0ke2l9YCwgYSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgdG9vbCBVSVxuICAgKiBAcGFyYW0gdG9vbERhdGEgLSBzYXZlZCB0b29sIGRhdGFcbiAgICovXG4gIHJlbmRlcihpKSB7XG4gICAgcmV0dXJuIGkuZmlsZSA9PT0gdm9pZCAwIHx8IE9iamVjdC5rZXlzKGkuZmlsZSkubGVuZ3RoID09PSAwID8gdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICBcImVtcHR5XCJcbiAgICAgIC8qIEVtcHR5ICovXG4gICAgKSA6IHRoaXMudG9nZ2xlU3RhdHVzKFxuICAgICAgXCJ1cGxvYWRpbmdcIlxuICAgICAgLyogVXBsb2FkaW5nICovXG4gICAgKSwgdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB1cGxvYWRpbmcgcHJlbG9hZGVyXG4gICAqIEBwYXJhbSBzcmMgLSBwcmV2aWV3IHNvdXJjZVxuICAgKi9cbiAgc2hvd1ByZWxvYWRlcihpKSB7XG4gICAgdGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7aX0pYCwgdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICBcInVwbG9hZGluZ1wiXG4gICAgICAvKiBVcGxvYWRpbmcgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlIHVwbG9hZGluZyBwcmVsb2FkZXJcbiAgICovXG4gIGhpZGVQcmVsb2FkZXIoKSB7XG4gICAgdGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcIlwiLCB0aGlzLnRvZ2dsZVN0YXR1cyhcbiAgICAgIFwiZW1wdHlcIlxuICAgICAgLyogRW1wdHkgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyBhbiBpbWFnZVxuICAgKiBAcGFyYW0gdXJsIC0gaW1hZ2Ugc291cmNlXG4gICAqL1xuICBmaWxsSW1hZ2UoaSkge1xuICAgIGNvbnN0IGEgPSAvXFwubXA0JC8udGVzdChpKSA/IFwiVklERU9cIiA6IFwiSU1HXCIsIHMgPSB7XG4gICAgICBzcmM6IGlcbiAgICB9O1xuICAgIGxldCByID0gXCJsb2FkXCI7XG4gICAgYSA9PT0gXCJWSURFT1wiICYmIChzLmF1dG9wbGF5ID0gITAsIHMubG9vcCA9ICEwLCBzLm11dGVkID0gITAsIHMucGxheXNpbmxpbmUgPSAhMCwgciA9IFwibG9hZGVkZGF0YVwiKSwgdGhpcy5ub2Rlcy5pbWFnZUVsID0gTShhLCB0aGlzLkNTUy5pbWFnZUVsLCBzKSwgdGhpcy5ub2Rlcy5pbWFnZUVsLmFkZEV2ZW50TGlzdGVuZXIociwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICAgIFwiZmlsbGVkXCJcbiAgICAgICAgLyogRmlsbGVkICovXG4gICAgICApLCB0aGlzLm5vZGVzLmltYWdlUHJlbG9hZGVyICE9PSB2b2lkIDAgJiYgKHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJcIik7XG4gICAgfSksIHRoaXMubm9kZXMuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZUVsKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgY2FwdGlvbiBpbnB1dFxuICAgKiBAcGFyYW0gdGV4dCAtIGNhcHRpb24gY29udGVudCB0ZXh0XG4gICAqL1xuICBmaWxsQ2FwdGlvbihpKSB7XG4gICAgdGhpcy5ub2Rlcy5jYXB0aW9uICE9PSB2b2lkIDAgJiYgKHRoaXMubm9kZXMuY2FwdGlvbi5pbm5lckhUTUwgPSBpKTtcbiAgfVxuICAvKipcbiAgICogQ1NTIGNsYXNzZXNcbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VDbGFzczogdGhpcy5hcGkuc3R5bGVzLmJsb2NrLFxuICAgICAgbG9hZGluZzogdGhpcy5hcGkuc3R5bGVzLmxvYWRlcixcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICBidXR0b246IHRoaXMuYXBpLnN0eWxlcy5idXR0b24sXG4gICAgICAvKipcbiAgICAgICAqIFRvb2wncyBjbGFzc2VzXG4gICAgICAgKi9cbiAgICAgIHdyYXBwZXI6IFwiaW1hZ2UtdG9vbFwiLFxuICAgICAgaW1hZ2VDb250YWluZXI6IFwiaW1hZ2UtdG9vbF9faW1hZ2VcIixcbiAgICAgIGltYWdlUHJlbG9hZGVyOiBcImltYWdlLXRvb2xfX2ltYWdlLXByZWxvYWRlclwiLFxuICAgICAgaW1hZ2VFbDogXCJpbWFnZS10b29sX19pbWFnZS1waWN0dXJlXCIsXG4gICAgICBjYXB0aW9uOiBcImltYWdlLXRvb2xfX2NhcHRpb25cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdXBsb2FkLWZpbGUgYnV0dG9uXG4gICAqL1xuICBjcmVhdGVGaWxlQnV0dG9uKCkge1xuICAgIGNvbnN0IGkgPSBNKFwiZGl2XCIsIFt0aGlzLkNTUy5idXR0b25dKTtcbiAgICByZXR1cm4gaS5pbm5lckhUTUwgPSB0aGlzLmNvbmZpZy5idXR0b25Db250ZW50ID8/IGAke0x9ICR7dGhpcy5hcGkuaTE4bi50KFwiU2VsZWN0IGFuIEltYWdlXCIpfWAsIGkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMub25TZWxlY3RGaWxlKCk7XG4gICAgfSksIGk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgVUkgc3RhdHVzXG4gICAqIEBwYXJhbSBzdGF0dXMgLSBzZWUge0BsaW5rIFVpLnN0YXR1c30gY29uc3RhbnRzXG4gICAqL1xuICB0b2dnbGVTdGF0dXMoaSkge1xuICAgIGZvciAoY29uc3QgYSBpbiBTKVxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFMsIGEpICYmIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKGAke3RoaXMuQ1NTLndyYXBwZXJ9LS0ke1NbYV19YCwgaSA9PT0gU1thXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEQoQykge1xuICByZXR1cm4gQyAmJiBDLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEMsIFwiZGVmYXVsdFwiKSA/IEMuZGVmYXVsdCA6IEM7XG59XG52YXIgSCA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihDLCBpKSB7XG4gIChmdW5jdGlvbihhLCBzKSB7XG4gICAgQy5leHBvcnRzID0gcygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgcyA9IHt9O1xuICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgIGlmIChzW2VdKSByZXR1cm4gc1tlXS5leHBvcnRzO1xuICAgICAgICB2YXIgbyA9IHNbZV0gPSB7IGk6IGUsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gYVtlXS5jYWxsKG8uZXhwb3J0cywgbywgby5leHBvcnRzLCByKSwgby5sID0gITAsIG8uZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiByLm0gPSBhLCByLmMgPSBzLCByLmQgPSBmdW5jdGlvbihlLCBvLCBkKSB7XG4gICAgICAgIHIubyhlLCBvKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbywgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBkIH0pO1xuICAgICAgfSwgci5yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCByLnQgPSBmdW5jdGlvbihlLCBvKSB7XG4gICAgICAgIGlmICgxICYgbyAmJiAoZSA9IHIoZSkpLCA4ICYgbyB8fCA0ICYgbyAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICAgICAgdmFyIGQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHIucihkKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogZSB9KSwgMiAmIG8gJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIikgZm9yICh2YXIgdiBpbiBlKSByLmQoZCwgdiwgKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICByZXR1cm4gZVtsXTtcbiAgICAgICAgfSkuYmluZChudWxsLCB2KSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSwgci5uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbyA9IGUgJiYgZS5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZGVmYXVsdDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gci5kKG8sIFwiYVwiLCBvKSwgbztcbiAgICAgIH0sIHIubyA9IGZ1bmN0aW9uKGUsIG8pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBvKTtcbiAgICAgIH0sIHIucCA9IFwiXCIsIHIoci5zID0gMyk7XG4gICAgfShbZnVuY3Rpb24oYSwgcykge1xuICAgICAgdmFyIHI7XG4gICAgICByID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIgPSByIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiICYmIChyID0gd2luZG93KTtcbiAgICAgIH1cbiAgICAgIGEuZXhwb3J0cyA9IHI7XG4gICAgfSwgZnVuY3Rpb24oYSwgcywgcikge1xuICAgICAgKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIG8gPSByKDIpLCBkID0gc2V0VGltZW91dDtcbiAgICAgICAgZnVuY3Rpb24gdigpIHtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsKG4pIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXdcIik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gMCwgdGhpcy5faGFuZGxlZCA9ICExLCB0aGlzLl92YWx1ZSA9IHZvaWQgMCwgdGhpcy5fZGVmZXJyZWRzID0gW10sIHQobiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZihuLCBjKSB7XG4gICAgICAgICAgZm9yICg7IG4uX3N0YXRlID09PSAzOyApIG4gPSBuLl92YWx1ZTtcbiAgICAgICAgICBuLl9zdGF0ZSAhPT0gMCA/IChuLl9oYW5kbGVkID0gITAsIGwuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHUgPSBuLl9zdGF0ZSA9PT0gMSA/IGMub25GdWxmaWxsZWQgOiBjLm9uUmVqZWN0ZWQ7XG4gICAgICAgICAgICBpZiAodSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZztcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnID0gdShuLl92YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCB5KGMucHJvbWlzZSwgbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcChjLnByb21pc2UsIGcpO1xuICAgICAgICAgICAgfSBlbHNlIChuLl9zdGF0ZSA9PT0gMSA/IHAgOiB5KShjLnByb21pc2UsIG4uX3ZhbHVlKTtcbiAgICAgICAgICB9KSkgOiBuLl9kZWZlcnJlZHMucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwKG4sIGMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGMgPT09IG4pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLlwiKTtcbiAgICAgICAgICAgIGlmIChjICYmICh0eXBlb2YgYyA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBjLnRoZW47XG4gICAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgbCkgcmV0dXJuIG4uX3N0YXRlID0gMywgbi5fdmFsdWUgPSBjLCB2b2lkIHcobik7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2b2lkIHQoKGcgPSB1LCBtID0gYywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZy5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9KSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuLl9zdGF0ZSA9IDEsIG4uX3ZhbHVlID0gYywgdyhuKTtcbiAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICB5KG4sIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZywgbTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB5KG4sIGMpIHtcbiAgICAgICAgICBuLl9zdGF0ZSA9IDIsIG4uX3ZhbHVlID0gYywgdyhuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3KG4pIHtcbiAgICAgICAgICBuLl9zdGF0ZSA9PT0gMiAmJiBuLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwICYmIGwuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbi5faGFuZGxlZCB8fCBsLl91bmhhbmRsZWRSZWplY3Rpb25GbihuLl92YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDAsIHUgPSBuLl9kZWZlcnJlZHMubGVuZ3RoOyBjIDwgdTsgYysrKSBmKG4sIG4uX2RlZmVycmVkc1tjXSk7XG4gICAgICAgICAgbi5fZGVmZXJyZWRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiKG4sIGMsIHUpIHtcbiAgICAgICAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiID8gbiA6IG51bGwsIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIiA/IGMgOiBudWxsLCB0aGlzLnByb21pc2UgPSB1O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHQobiwgYykge1xuICAgICAgICAgIHZhciB1ID0gITE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG4oZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgICB1IHx8ICh1ID0gITAsIHAoYywgZykpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgICB1IHx8ICh1ID0gITAsIHkoYywgZykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICAgICAgaWYgKHUpIHJldHVybjtcbiAgICAgICAgICAgIHUgPSAhMCwgeShjLCBnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbC5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBuKTtcbiAgICAgICAgfSwgbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG4sIGMpIHtcbiAgICAgICAgICB2YXIgdSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHYpO1xuICAgICAgICAgIHJldHVybiBmKHRoaXMsIG5ldyBiKG4sIGMsIHUpKSwgdTtcbiAgICAgICAgfSwgbC5wcm90b3R5cGUuZmluYWxseSA9IG8uYSwgbC5hbGwgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgICAgIGlmICghbiB8fCBuLmxlbmd0aCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIHZhciBnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobik7XG4gICAgICAgICAgICBpZiAoZy5sZW5ndGggPT09IDApIHJldHVybiBjKFtdKTtcbiAgICAgICAgICAgIHZhciBtID0gZy5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiBoKFQsIEUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoRSAmJiAodHlwZW9mIEUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaiA9IEUudGhlbjtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaiA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2b2lkIGouY2FsbChFLCBmdW5jdGlvbihGKSB7XG4gICAgICAgICAgICAgICAgICAgIGgoVCwgRik7XG4gICAgICAgICAgICAgICAgICB9LCB1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ1tUXSA9IEUsIC0tbSA9PSAwICYmIGMoZyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKEYpIHtcbiAgICAgICAgICAgICAgICB1KEYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGcubGVuZ3RoOyBrKyspIGgoaywgZ1trXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGwucmVzb2x2ZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbiAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIG4uY29uc3RydWN0b3IgPT09IGwgPyBuIDogbmV3IGwoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgYyhuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbC5yZWplY3QgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgICAgIHUobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGwucmFjZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGwoZnVuY3Rpb24oYywgdSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDAsIG0gPSBuLmxlbmd0aDsgZyA8IG07IGcrKykgbltnXS50aGVuKGMsIHUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBsLl9pbW1lZGlhdGVGbiA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgZShuKTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgZChuLCAwKTtcbiAgICAgICAgfSwgbC5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybihcIlBvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjpcIiwgbik7XG4gICAgICAgIH0sIHMuYSA9IGw7XG4gICAgICB9KS5jYWxsKHRoaXMsIHIoNSkuc2V0SW1tZWRpYXRlKTtcbiAgICB9LCBmdW5jdGlvbihhLCBzLCByKSB7XG4gICAgICBzLmEgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIG8ucmVzb2x2ZShlKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBvLnJlc29sdmUoZSgpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG8ucmVqZWN0KGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSwgZnVuY3Rpb24oYSwgcywgcikge1xuICAgICAgZnVuY3Rpb24gZSh0KSB7XG4gICAgICAgIHJldHVybiAoZSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIG47XG4gICAgICAgIH0gOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIG4gJiYgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgbi5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG4gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG47XG4gICAgICAgIH0pKHQpO1xuICAgICAgfVxuICAgICAgcig0KTtcbiAgICAgIHZhciBvLCBkLCB2LCBsLCBmLCBwLCB5LCB3ID0gcig4KSwgYiA9IChkID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obiwgYykge1xuICAgICAgICAgIHQgPSBsKHQpLCAodCA9IGYodCkpLmJlZm9yZVNlbmQgJiYgdC5iZWZvcmVTZW5kKCk7XG4gICAgICAgICAgdmFyIHUgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgPyBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCkgOiBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgICB1Lm9wZW4odC5tZXRob2QsIHQudXJsKSwgdS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpLCBPYmplY3Qua2V5cyh0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGggPSB0LmhlYWRlcnNbbV07XG4gICAgICAgICAgICB1LnNldFJlcXVlc3RIZWFkZXIobSwgaCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGcgPSB0LnJhdGlvO1xuICAgICAgICAgIHUudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQobS5sb2FkZWQgLyBtLnRvdGFsICogMTAwKSwgayA9IE1hdGguY2VpbChoICogZyAvIDEwMCk7XG4gICAgICAgICAgICB0LnByb2dyZXNzKE1hdGgubWluKGssIDEwMCkpO1xuICAgICAgICAgIH0sICExKSwgdS5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGggPSBNYXRoLnJvdW5kKG0ubG9hZGVkIC8gbS50b3RhbCAqIDEwMCksIGsgPSBNYXRoLmNlaWwoaCAqICgxMDAgLSBnKSAvIDEwMCkgKyBnO1xuICAgICAgICAgICAgdC5wcm9ncmVzcyhNYXRoLm1pbihrLCAxMDApKTtcbiAgICAgICAgICB9LCAhMSksIHUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgIHZhciBtID0gdS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtID0gSlNPTi5wYXJzZShtKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGggPSB3LnBhcnNlSGVhZGVycyh1LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSwgayA9IHsgYm9keTogbSwgY29kZTogdS5zdGF0dXMsIGhlYWRlcnM6IGggfTtcbiAgICAgICAgICAgICAgeSh1LnN0YXR1cykgPyBuKGspIDogYyhrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB1LnNlbmQodC5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCB2ID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5tZXRob2QgPSBcIlBPU1RcIiwgZCh0KTtcbiAgICAgIH0sIGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICBpZiAodC51cmwgJiYgdHlwZW9mIHQudXJsICE9IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlVybCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICBpZiAodC51cmwgPSB0LnVybCB8fCBcIlwiLCB0Lm1ldGhvZCAmJiB0eXBlb2YgdC5tZXRob2QgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiYG1ldGhvZGAgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsXCIpO1xuICAgICAgICBpZiAodC5tZXRob2QgPSB0Lm1ldGhvZCA/IHQubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiLCB0LmhlYWRlcnMgJiYgZSh0LmhlYWRlcnMpICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgaGVhZGVyc2AgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbFwiKTtcbiAgICAgICAgaWYgKHQuaGVhZGVycyA9IHQuaGVhZGVycyB8fCB7fSwgdC50eXBlICYmICh0eXBlb2YgdC50eXBlICE9IFwic3RyaW5nXCIgfHwgIU9iamVjdC52YWx1ZXMobykuaW5jbHVkZXModC50eXBlKSkpIHRocm93IG5ldyBFcnJvcihcImB0eXBlYCBtdXN0IGJlIHRha2VuIGZyb20gbW9kdWxlJ3Mgwqtjb250ZW50VHlwZcK7IGxpYnJhcnlcIik7XG4gICAgICAgIGlmICh0LnByb2dyZXNzICYmIHR5cGVvZiB0LnByb2dyZXNzICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiYHByb2dyZXNzYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbFwiKTtcbiAgICAgICAgaWYgKHQucHJvZ3Jlc3MgPSB0LnByb2dyZXNzIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgfSwgdC5iZWZvcmVTZW5kID0gdC5iZWZvcmVTZW5kIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgfSwgdC5yYXRpbyAmJiB0eXBlb2YgdC5yYXRpbyAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgcmF0aW9gIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgIGlmICh0LnJhdGlvIDwgMCB8fCB0LnJhdGlvID4gMTAwKSB0aHJvdyBuZXcgRXJyb3IoXCJgcmF0aW9gIG11c3QgYmUgaW4gYSAwLTEwMCBpbnRlcnZhbFwiKTtcbiAgICAgICAgaWYgKHQucmF0aW8gPSB0LnJhdGlvIHx8IDkwLCB0LmFjY2VwdCAmJiB0eXBlb2YgdC5hY2NlcHQgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiYGFjY2VwdGAgbXVzdCBiZSBhIHN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGxvd2VkIG1pbWUtdHlwZXNcIik7XG4gICAgICAgIGlmICh0LmFjY2VwdCA9IHQuYWNjZXB0IHx8IFwiKi8qXCIsIHQubXVsdGlwbGUgJiYgdHlwZW9mIHQubXVsdGlwbGUgIT0gXCJib29sZWFuXCIpIHRocm93IG5ldyBFcnJvcihcImBtdWx0aXBsZWAgbXVzdCBiZSBhIHRydWUgb3IgZmFsc2VcIik7XG4gICAgICAgIGlmICh0Lm11bHRpcGxlID0gdC5tdWx0aXBsZSB8fCAhMSwgdC5maWVsZE5hbWUgJiYgdHlwZW9mIHQuZmllbGROYW1lICE9IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcImBmaWVsZE5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybiB0LmZpZWxkTmFtZSA9IHQuZmllbGROYW1lIHx8IFwiZmlsZXNcIiwgdDtcbiAgICAgIH0sIGYgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN3aXRjaCAodC5tZXRob2QpIHtcbiAgICAgICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgICAgICB2YXIgbiA9IHAodC5kYXRhLCBvLlVSTEVOQ09ERUQpO1xuICAgICAgICAgICAgZGVsZXRlIHQuZGF0YSwgdC51cmwgPSAvXFw/Ly50ZXN0KHQudXJsKSA/IHQudXJsICsgXCImXCIgKyBuIDogdC51cmwgKyBcIj9cIiArIG47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICAgIGNhc2UgXCJQVVRcIjpcbiAgICAgICAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICAgICAgY2FzZSBcIlVQREFURVwiOlxuICAgICAgICAgICAgdmFyIGMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IHt9KS50eXBlIHx8IG8uSlNPTjtcbiAgICAgICAgICAgIH0odCk7XG4gICAgICAgICAgICAody5pc0Zvcm1EYXRhKHQuZGF0YSkgfHwgdy5pc0Zvcm1FbGVtZW50KHQuZGF0YSkpICYmIChjID0gby5GT1JNKSwgdC5kYXRhID0gcCh0LmRhdGEsIGMpLCBjICE9PSBiLmNvbnRlbnRUeXBlLkZPUk0gJiYgKHQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSwgcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDApIHtcbiAgICAgICAgICBjYXNlIG8uVVJMRU5DT0RFRDpcbiAgICAgICAgICAgIHJldHVybiB3LnVybEVuY29kZSh0KTtcbiAgICAgICAgICBjYXNlIG8uSlNPTjpcbiAgICAgICAgICAgIHJldHVybiB3Lmpzb25FbmNvZGUodCk7XG4gICAgICAgICAgY2FzZSBvLkZPUk06XG4gICAgICAgICAgICByZXR1cm4gdy5mb3JtRW5jb2RlKHQpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgfSwgeSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMjAwICYmIHQgPCAzMDA7XG4gICAgICB9LCB7IGNvbnRlbnRUeXBlOiBvID0geyBVUkxFTkNPREVEOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOFwiLCBGT1JNOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgSlNPTjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIgfSwgcmVxdWVzdDogZCwgZ2V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1ldGhvZCA9IFwiR0VUXCIsIGQodCk7XG4gICAgICB9LCBwb3N0OiB2LCB0cmFuc3BvcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPSBsKHQpLCB3LnNlbGVjdEZpbGVzKHQpLnRoZW4oZnVuY3Rpb24obikge1xuICAgICAgICAgIGZvciAodmFyIGMgPSBuZXcgRm9ybURhdGEoKSwgdSA9IDA7IHUgPCBuLmxlbmd0aDsgdSsrKSBjLmFwcGVuZCh0LmZpZWxkTmFtZSwgblt1XSwgblt1XS5uYW1lKTtcbiAgICAgICAgICB3LmlzT2JqZWN0KHQuZGF0YSkgJiYgT2JqZWN0LmtleXModC5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBoID0gdC5kYXRhW21dO1xuICAgICAgICAgICAgYy5hcHBlbmQobSwgaCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGcgPSB0LmJlZm9yZVNlbmQ7XG4gICAgICAgICAgcmV0dXJuIHQuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGcobik7XG4gICAgICAgICAgfSwgdC5kYXRhID0gYywgdih0KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBzZWxlY3RGaWxlczogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlICh0ID0gbCh0KSkuYmVmb3JlU2VuZCwgdy5zZWxlY3RGaWxlcyh0KTtcbiAgICAgIH0gfSk7XG4gICAgICBhLmV4cG9ydHMgPSBiO1xuICAgIH0sIGZ1bmN0aW9uKGEsIHMsIHIpIHtcbiAgICAgIHIucihzKTtcbiAgICAgIHZhciBlID0gcigxKTtcbiAgICAgIHdpbmRvdy5Qcm9taXNlID0gd2luZG93LlByb21pc2UgfHwgZS5hO1xuICAgIH0sIGZ1bmN0aW9uKGEsIHMsIHIpIHtcbiAgICAgIChmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBvID0gZSAhPT0gdm9pZCAwICYmIGUgfHwgdHlwZW9mIHNlbGYgPCBcInVcIiAmJiBzZWxmIHx8IHdpbmRvdywgZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbiAgICAgICAgZnVuY3Rpb24gdihsLCBmKSB7XG4gICAgICAgICAgdGhpcy5faWQgPSBsLCB0aGlzLl9jbGVhckZuID0gZjtcbiAgICAgICAgfVxuICAgICAgICBzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHYoZC5jYWxsKHNldFRpbWVvdXQsIG8sIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG4gICAgICAgIH0sIHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHYoZC5jYWxsKHNldEludGVydmFsLCBvLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbiAgICAgICAgfSwgcy5jbGVhclRpbWVvdXQgPSBzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgbCAmJiBsLmNsb3NlKCk7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLnVucmVmID0gdi5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIHYucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fY2xlYXJGbi5jYWxsKG8sIHRoaXMuX2lkKTtcbiAgICAgICAgfSwgcy5lbnJvbGwgPSBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGwuX2lkbGVUaW1lb3V0SWQpLCBsLl9pZGxlVGltZW91dCA9IGY7XG4gICAgICAgIH0sIHMudW5lbnJvbGwgPSBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGwuX2lkbGVUaW1lb3V0SWQpLCBsLl9pZGxlVGltZW91dCA9IC0xO1xuICAgICAgICB9LCBzLl91bnJlZkFjdGl2ZSA9IHMuYWN0aXZlID0gZnVuY3Rpb24obCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChsLl9pZGxlVGltZW91dElkKTtcbiAgICAgICAgICB2YXIgZiA9IGwuX2lkbGVUaW1lb3V0O1xuICAgICAgICAgIGYgPj0gMCAmJiAobC5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsLl9vblRpbWVvdXQgJiYgbC5fb25UaW1lb3V0KCk7XG4gICAgICAgICAgfSwgZikpO1xuICAgICAgICB9LCByKDYpLCBzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUgfHwgZSAhPT0gdm9pZCAwICYmIGUuc2V0SW1tZWRpYXRlIHx8IHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUsIHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUgfHwgZSAhPT0gdm9pZCAwICYmIGUuY2xlYXJJbW1lZGlhdGUgfHwgdGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlO1xuICAgICAgfSkuY2FsbCh0aGlzLCByKDApKTtcbiAgICB9LCBmdW5jdGlvbihhLCBzLCByKSB7XG4gICAgICAoZnVuY3Rpb24oZSwgbykge1xuICAgICAgICAoZnVuY3Rpb24oZCwgdikge1xuICAgICAgICAgIGlmICghZC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHZhciBsLCBmLCBwLCB5LCB3LCBiID0gMSwgdCA9IHt9LCBuID0gITEsIGMgPSBkLmRvY3VtZW50LCB1ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihkKTtcbiAgICAgICAgICAgIHUgPSB1ICYmIHUuc2V0VGltZW91dCA/IHUgOiBkLCB7fS50b1N0cmluZy5jYWxsKGQucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiID8gbCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgby5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtKGgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGQucG9zdE1lc3NhZ2UgJiYgIWQuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgICAgIHZhciBoID0gITAsIGsgPSBkLm9ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGggPSAhMTtcbiAgICAgICAgICAgICAgICB9LCBkLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKSwgZC5vbm1lc3NhZ2UgPSBrLCBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkgPyAoeSA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiLCB3ID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICBoLnNvdXJjZSA9PT0gZCAmJiB0eXBlb2YgaC5kYXRhID09IFwic3RyaW5nXCIgJiYgaC5kYXRhLmluZGV4T2YoeSkgPT09IDAgJiYgbSgraC5kYXRhLnNsaWNlKHkubGVuZ3RoKSk7XG4gICAgICAgICAgICB9LCBkLmFkZEV2ZW50TGlzdGVuZXIgPyBkLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHcsICExKSA6IGQuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgdyksIGwgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIGQucG9zdE1lc3NhZ2UoeSArIGgsIFwiKlwiKTtcbiAgICAgICAgICAgIH0pIDogZC5NZXNzYWdlQ2hhbm5lbCA/ICgocCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpKS5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIG0oaC5kYXRhKTtcbiAgICAgICAgICAgIH0sIGwgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHAucG9ydDIucG9zdE1lc3NhZ2UoaCk7XG4gICAgICAgICAgICB9KSA6IGMgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBjLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikgPyAoZiA9IGMuZG9jdW1lbnRFbGVtZW50LCBsID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICB2YXIgayA9IGMuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgay5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBtKGgpLCBrLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIGYucmVtb3ZlQ2hpbGQoayksIGsgPSBudWxsO1xuICAgICAgICAgICAgICB9LCBmLmFwcGVuZENoaWxkKGspO1xuICAgICAgICAgICAgfSkgOiBsID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KG0sIDAsIGgpO1xuICAgICAgICAgICAgfSwgdS5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHR5cGVvZiBoICE9IFwiZnVuY3Rpb25cIiAmJiAoaCA9IG5ldyBGdW5jdGlvbihcIlwiICsgaCkpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSwgVCA9IDA7IFQgPCBrLmxlbmd0aDsgVCsrKSBrW1RdID0gYXJndW1lbnRzW1QgKyAxXTtcbiAgICAgICAgICAgICAgdmFyIEUgPSB7IGNhbGxiYWNrOiBoLCBhcmdzOiBrIH07XG4gICAgICAgICAgICAgIHJldHVybiB0W2JdID0gRSwgbChiKSwgYisrO1xuICAgICAgICAgICAgfSwgdS5jbGVhckltbWVkaWF0ZSA9IGc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGcoaCkge1xuICAgICAgICAgICAgZGVsZXRlIHRbaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG0oaCkge1xuICAgICAgICAgICAgaWYgKG4pIHNldFRpbWVvdXQobSwgMCwgaCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSB0W2hdO1xuICAgICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICAgIG4gPSAhMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIEUgPSBULmNhbGxiYWNrLCBqID0gVC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgRSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgRShqWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIEUoalswXSwgalsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBFKGpbMF0sIGpbMV0sIGpbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEUuYXBwbHkodiwgaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pKGspO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBnKGgpLCBuID0gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0eXBlb2Ygc2VsZiA+IFwidVwiID8gZSA9PT0gdm9pZCAwID8gdGhpcyA6IGUgOiBzZWxmKTtcbiAgICAgIH0pLmNhbGwodGhpcywgcigwKSwgcig3KSk7XG4gICAgfSwgZnVuY3Rpb24oYSwgcykge1xuICAgICAgdmFyIHIsIGUsIG8gPSBhLmV4cG9ydHMgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsKHUpIHtcbiAgICAgICAgaWYgKHIgPT09IHNldFRpbWVvdXQpIHJldHVybiBzZXRUaW1lb3V0KHUsIDApO1xuICAgICAgICBpZiAoKHIgPT09IGQgfHwgIXIpICYmIHNldFRpbWVvdXQpIHJldHVybiByID0gc2V0VGltZW91dCwgc2V0VGltZW91dCh1LCAwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcih1LCAwKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiByLmNhbGwobnVsbCwgdSwgMCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gci5jYWxsKHRoaXMsIHUsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHIgPSB0eXBlb2Ygc2V0VGltZW91dCA9PSBcImZ1bmN0aW9uXCIgPyBzZXRUaW1lb3V0IDogZDtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgciA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PSBcImZ1bmN0aW9uXCIgPyBjbGVhclRpbWVvdXQgOiB2O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBlID0gdjtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICAgIHZhciBmLCBwID0gW10sIHkgPSAhMSwgdyA9IC0xO1xuICAgICAgZnVuY3Rpb24gYigpIHtcbiAgICAgICAgeSAmJiBmICYmICh5ID0gITEsIGYubGVuZ3RoID8gcCA9IGYuY29uY2F0KHApIDogdyA9IC0xLCBwLmxlbmd0aCAmJiB0KCkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdCgpIHtcbiAgICAgICAgaWYgKCF5KSB7XG4gICAgICAgICAgdmFyIHUgPSBsKGIpO1xuICAgICAgICAgIHkgPSAhMDtcbiAgICAgICAgICBmb3IgKHZhciBnID0gcC5sZW5ndGg7IGc7ICkge1xuICAgICAgICAgICAgZm9yIChmID0gcCwgcCA9IFtdOyArK3cgPCBnOyApIGYgJiYgZlt3XS5ydW4oKTtcbiAgICAgICAgICAgIHcgPSAtMSwgZyA9IHAubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmID0gbnVsbCwgeSA9ICExLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gY2xlYXJUaW1lb3V0KSByZXR1cm4gY2xlYXJUaW1lb3V0KG0pO1xuICAgICAgICAgICAgaWYgKChlID09PSB2IHx8ICFlKSAmJiBjbGVhclRpbWVvdXQpIHJldHVybiBlID0gY2xlYXJUaW1lb3V0LCBjbGVhclRpbWVvdXQobSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlKG0pO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuY2FsbChudWxsLCBtKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzLCBtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0odSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG4odSwgZykge1xuICAgICAgICB0aGlzLmZ1biA9IHUsIHRoaXMuYXJyYXkgPSBnO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgIH1cbiAgICAgIG8ubmV4dFRpY2sgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHZhciBnID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBmb3IgKHZhciBtID0gMTsgbSA8IGFyZ3VtZW50cy5sZW5ndGg7IG0rKykgZ1ttIC0gMV0gPSBhcmd1bWVudHNbbV07XG4gICAgICAgIHAucHVzaChuZXcgbih1LCBnKSksIHAubGVuZ3RoICE9PSAxIHx8IHkgfHwgbCh0KTtcbiAgICAgIH0sIG4ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbiAgICAgIH0sIG8udGl0bGUgPSBcImJyb3dzZXJcIiwgby5icm93c2VyID0gITAsIG8uZW52ID0ge30sIG8uYXJndiA9IFtdLCBvLnZlcnNpb24gPSBcIlwiLCBvLnZlcnNpb25zID0ge30sIG8ub24gPSBjLCBvLmFkZExpc3RlbmVyID0gYywgby5vbmNlID0gYywgby5vZmYgPSBjLCBvLnJlbW92ZUxpc3RlbmVyID0gYywgby5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBjLCBvLmVtaXQgPSBjLCBvLnByZXBlbmRMaXN0ZW5lciA9IGMsIG8ucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGMsIG8ubGlzdGVuZXJzID0gZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LCBvLmJpbmRpbmcgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfSwgby5jd2QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgICAgfSwgby5jaGRpciA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfSwgby51bWFzayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfSwgZnVuY3Rpb24oYSwgcywgcikge1xuICAgICAgZnVuY3Rpb24gZShkLCB2KSB7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdi5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBmID0gdltsXTtcbiAgICAgICAgICBmLmVudW1lcmFibGUgPSBmLmVudW1lcmFibGUgfHwgITEsIGYuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBmICYmIChmLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZCwgZi5rZXksIGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbyA9IHIoOSk7XG4gICAgICBhLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgICAoZnVuY3Rpb24ocCwgeSkge1xuICAgICAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIHkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgIH0pKHRoaXMsIGQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2LCBsLCBmO1xuICAgICAgICByZXR1cm4gdiA9IGQsIGYgPSBbeyBrZXk6IFwidXJsRW5jb2RlXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIG8ocCk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwianNvbkVuY29kZVwiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJmb3JtRW5jb2RlXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGb3JtRGF0YShwKSkgcmV0dXJuIHA7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGb3JtRWxlbWVudChwKSkgcmV0dXJuIG5ldyBGb3JtRGF0YShwKTtcbiAgICAgICAgICBpZiAodGhpcy5pc09iamVjdChwKSkge1xuICAgICAgICAgICAgdmFyIHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwKS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSBwW3ddO1xuICAgICAgICAgICAgICB5LmFwcGVuZCh3LCBiKTtcbiAgICAgICAgICAgIH0pLCB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGF0YWAgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBPYmplY3QsIEZvcm1EYXRhIG9yIDxGT1JNPiBIVE1MRWxlbWVudFwiKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpc09iamVjdFwiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaXNGb3JtRGF0YVwiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgRm9ybURhdGE7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiaXNGb3JtRWxlbWVudFwiLCB2YWx1ZTogZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50O1xuICAgICAgICB9IH0sIHsga2V5OiBcInNlbGVjdEZpbGVzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHksIHcpIHtcbiAgICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIklOUFVUXCIpO1xuICAgICAgICAgICAgYi50eXBlID0gXCJmaWxlXCIsIHAubXVsdGlwbGUgJiYgYi5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlXCIpLCBwLmFjY2VwdCAmJiBiLnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLCBwLmFjY2VwdCksIGIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGIpLCBiLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB2YXIgbiA9IHQudGFyZ2V0LmZpbGVzO1xuICAgICAgICAgICAgICB5KG4pLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIpO1xuICAgICAgICAgICAgfSwgITEpLCBiLmNsaWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicGFyc2VIZWFkZXJzXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIHkgPSBwLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyksIHcgPSB7fTtcbiAgICAgICAgICByZXR1cm4geS5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gYi5zcGxpdChcIjogXCIpLCBuID0gdC5zaGlmdCgpLCBjID0gdC5qb2luKFwiOiBcIik7XG4gICAgICAgICAgICBuICYmICh3W25dID0gYyk7XG4gICAgICAgICAgfSksIHc7XG4gICAgICAgIH0gfV0sIChsID0gbnVsbCkgJiYgZSh2LnByb3RvdHlwZSwgbCksIGYgJiYgZSh2LCBmKSwgZDtcbiAgICAgIH0oKTtcbiAgICB9LCBmdW5jdGlvbihhLCBzKSB7XG4gICAgICB2YXIgciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChvKS5yZXBsYWNlKC9bIScoKSpdL2csIGVzY2FwZSkucmVwbGFjZSgvJTIwL2csIFwiK1wiKTtcbiAgICAgIH0sIGUgPSBmdW5jdGlvbihvLCBkLCB2LCBsKSB7XG4gICAgICAgIHJldHVybiBkID0gZCB8fCBudWxsLCB2ID0gdiB8fCBcIiZcIiwgbCA9IGwgfHwgbnVsbCwgbyA/IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBmb3IgKHZhciBwID0gbmV3IEFycmF5KCksIHkgPSAwOyB5IDwgZi5sZW5ndGg7IHkrKykgZlt5XSAmJiBwLnB1c2goZlt5XSk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0oT2JqZWN0LmtleXMobykubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB2YXIgcCwgeSwgdyA9IGY7XG4gICAgICAgICAgaWYgKGwgJiYgKHcgPSBsICsgXCJbXCIgKyB3ICsgXCJdXCIpLCB0eXBlb2Ygb1tmXSA9PSBcIm9iamVjdFwiICYmIG9bZl0gIT09IG51bGwpIHAgPSBlKG9bZl0sIG51bGwsIHYsIHcpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZCAmJiAoeSA9IHcsIHcgPSAhaXNOYU4ocGFyc2VGbG9hdCh5KSkgJiYgaXNGaW5pdGUoeSkgPyBkICsgTnVtYmVyKHcpIDogdyk7XG4gICAgICAgICAgICB2YXIgYiA9IG9bZl07XG4gICAgICAgICAgICBiID0gKGIgPSAoYiA9IChiID0gYiA9PT0gITAgPyBcIjFcIiA6IGIpID09PSAhMSA/IFwiMFwiIDogYikgPT09IDAgPyBcIjBcIiA6IGIpIHx8IFwiXCIsIHAgPSByKHcpICsgXCI9XCIgKyByKGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSkpLmpvaW4odikucmVwbGFjZSgvWyEnKCkqXS9nLCBcIlwiKSA6IFwiXCI7XG4gICAgICB9O1xuICAgICAgYS5leHBvcnRzID0gZTtcbiAgICB9XSk7XG4gIH0pO1xufSkoSCk7XG52YXIgcSA9IEguZXhwb3J0cztcbmNvbnN0IF8gPSAvKiBAX19QVVJFX18gKi8gRChxKTtcbmZ1bmN0aW9uIE8oQykge1xuICByZXR1cm4gQyAhPT0gdm9pZCAwICYmIHR5cGVvZiBDLnRoZW4gPT0gXCJmdW5jdGlvblwiO1xufVxuY2xhc3MgQSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gdXBsb2FkZXIgbW9kdWxlIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmZpZyAtIGltYWdlIHRvb2wgY29uZmlnXG4gICAqIEBwYXJhbSBwYXJhbXMub25VcGxvYWQgLSBvbmUgY2FsbGJhY2sgZm9yIGFsbCB1cGxvYWRpbmcgKGZpbGUsIHVybCwgZC1uLWQsIHBhc3RpbmcpXG4gICAqIEBwYXJhbSBwYXJhbXMub25FcnJvciAtIGNhbGxiYWNrIGZvciB1cGxvYWRpbmcgZXJyb3JzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogaSwgb25VcGxvYWQ6IGEsIG9uRXJyb3I6IHMgfSkge1xuICAgIHRoaXMuY29uZmlnID0gaSwgdGhpcy5vblVwbG9hZCA9IGEsIHRoaXMub25FcnJvciA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gdGhlIHVwbG9hZCBmaWxlIGJ1dHRvblxuICAgKiBGaXJlcyBhamF4LnRyYW5zcG9ydCgpXG4gICAqIEBwYXJhbSBvblByZXZpZXcgLSBjYWxsYmFjayBmaXJlZCB3aGVuIHByZXZpZXcgaXMgcmVhZHlcbiAgICovXG4gIHVwbG9hZFNlbGVjdGVkRmlsZSh7IG9uUHJldmlldzogaSB9KSB7XG4gICAgY29uc3QgYSA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZS5yZWFkQXNEYXRhVVJMKHIpLCBlLm9ubG9hZCA9IChvKSA9PiB7XG4gICAgICAgIGkoby50YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBsZXQgcztcbiAgICBpZiAodGhpcy5jb25maWcudXBsb2FkZXIgJiYgdHlwZW9mIHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNvbmZpZy51cGxvYWRlci51cGxvYWRCeUZpbGU7XG4gICAgICBzID0gXy5zZWxlY3RGaWxlcyh7IGFjY2VwdDogdGhpcy5jb25maWcudHlwZXMgPz8gXCJpbWFnZS8qXCIgfSkudGhlbigoZSkgPT4ge1xuICAgICAgICBhKGVbMF0pO1xuICAgICAgICBjb25zdCBvID0gcihlWzBdKTtcbiAgICAgICAgcmV0dXJuIE8obykgfHwgY29uc29sZS53YXJuKFwiQ3VzdG9tIHVwbG9hZGVyIG1ldGhvZCB1cGxvYWRCeUZpbGUgc2hvdWxkIHJldHVybiBhIFByb21pc2VcIiksIG87XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHMgPSBfLnRyYW5zcG9ydCh7XG4gICAgICAgIHVybDogdGhpcy5jb25maWcuZW5kcG9pbnRzLmJ5RmlsZSxcbiAgICAgICAgZGF0YTogdGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhLFxuICAgICAgICBhY2NlcHQ6IHRoaXMuY29uZmlnLnR5cGVzID8/IFwiaW1hZ2UvKlwiLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnMsXG4gICAgICAgIGJlZm9yZVNlbmQ6IChyKSA9PiB7XG4gICAgICAgICAgYShyWzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmllbGROYW1lOiB0aGlzLmNvbmZpZy5maWVsZCA/PyBcImltYWdlXCJcbiAgICAgIH0pLnRoZW4oKHIpID0+IHIuYm9keSk7XG4gICAgcy50aGVuKChyKSA9PiB7XG4gICAgICB0aGlzLm9uVXBsb2FkKHIpO1xuICAgIH0pLmNhdGNoKChyKSA9PiB7XG4gICAgICB0aGlzLm9uRXJyb3Iocik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gdGhlIHVwbG9hZCBmaWxlIGJ1dHRvblxuICAgKiBGaXJlcyBhamF4LnBvc3QoKVxuICAgKiBAcGFyYW0gdXJsIC0gaW1hZ2Ugc291cmNlIHVybFxuICAgKi9cbiAgdXBsb2FkQnlVcmwoaSkge1xuICAgIGxldCBhO1xuICAgIHRoaXMuY29uZmlnLnVwbG9hZGVyICYmIHR5cGVvZiB0aGlzLmNvbmZpZy51cGxvYWRlci51cGxvYWRCeVVybCA9PSBcImZ1bmN0aW9uXCIgPyAoYSA9IHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5VXJsKGkpLCBPKGEpIHx8IGNvbnNvbGUud2FybihcIkN1c3RvbSB1cGxvYWRlciBtZXRob2QgdXBsb2FkQnlVcmwgc2hvdWxkIHJldHVybiBhIFByb21pc2VcIikpIDogYSA9IF8ucG9zdCh7XG4gICAgICB1cmw6IHRoaXMuY29uZmlnLmVuZHBvaW50cy5ieVVybCxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB1cmw6IGlcbiAgICAgIH0sIHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSksXG4gICAgICB0eXBlOiBfLmNvbnRlbnRUeXBlLkpTT04sXG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnNcbiAgICB9KS50aGVuKChzKSA9PiBzLmJvZHkpLCBhLnRoZW4oKHMpID0+IHtcbiAgICAgIHRoaXMub25VcGxvYWQocyk7XG4gICAgfSkuY2F0Y2goKHMpID0+IHtcbiAgICAgIHRoaXMub25FcnJvcihzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgdXBsb2FkIGZpbGUgYnV0dG9uXG4gICAqIEZpcmVzIGFqYXgucG9zdCgpXG4gICAqIEBwYXJhbSBmaWxlIC0gZmlsZSBwYXN0ZWQgYnkgZHJhZy1uLWRyb3BcbiAgICogQHBhcmFtIG9uUHJldmlldyAtIGZpbGUgcGFzdGVkIGJ5IGRyYWctbi1kcm9wXG4gICAqL1xuICB1cGxvYWRCeUZpbGUoaSwgeyBvblByZXZpZXc6IGEgfSkge1xuICAgIGNvbnN0IHMgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHMucmVhZEFzRGF0YVVSTChpKSwgcy5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgYShlLnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgbGV0IHI7XG4gICAgaWYgKHRoaXMuY29uZmlnLnVwbG9hZGVyICYmIHR5cGVvZiB0aGlzLmNvbmZpZy51cGxvYWRlci51cGxvYWRCeUZpbGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgciA9IHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZShpKSwgTyhyKSB8fCBjb25zb2xlLndhcm4oXCJDdXN0b20gdXBsb2FkZXIgbWV0aG9kIHVwbG9hZEJ5RmlsZSBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZVwiKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGUgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGUuYXBwZW5kKHRoaXMuY29uZmlnLmZpZWxkID8/IFwiaW1hZ2VcIiwgaSksIHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSAmJiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdERhdGEpLmxlbmd0aCAmJiBPYmplY3QuZW50cmllcyh0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdERhdGEpLmZvckVhY2goKFtvLCBkXSkgPT4ge1xuICAgICAgICBlLmFwcGVuZChvLCBkKTtcbiAgICAgIH0pLCByID0gXy5wb3N0KHtcbiAgICAgICAgdXJsOiB0aGlzLmNvbmZpZy5lbmRwb2ludHMuYnlGaWxlLFxuICAgICAgICBkYXRhOiBlLFxuICAgICAgICB0eXBlOiBfLmNvbnRlbnRUeXBlLkpTT04sXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0SGVhZGVyc1xuICAgICAgfSkudGhlbigobykgPT4gby5ib2R5KTtcbiAgICB9XG4gICAgci50aGVuKChlKSA9PiB7XG4gICAgICB0aGlzLm9uVXBsb2FkKGUpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICB0aGlzLm9uRXJyb3IoZSk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogSW1hZ2UgVG9vbCBmb3IgdGhlIEVkaXRvci5qc1xuICogQGF1dGhvciBDb2RlWCA8dGVhbUBjb2RleC5zbz5cbiAqIEBsaWNlbnNlIE1JVFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VkaXRvci1qcy9pbWFnZX1cbiAqXG4gKiBUbyBkZXZlbG9wZXJzLlxuICogVG8gc2ltcGxpZnkgVG9vbCBzdHJ1Y3R1cmUsIHdlIHNwbGl0IGl0IHRvIDQgcGFydHM6XG4gKiAgMSkgaW5kZXgudHMg4oCUIG1haW4gVG9vbCdzIGludGVyZmFjZSwgcHVibGljIEFQSSBhbmQgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIGRhdGFcbiAqICAyKSB1cGxvYWRlci50cyDigJQgbW9kdWxlIHRoYXQgaGFzIG1ldGhvZHMgZm9yIHNlbmRpbmcgZmlsZXMgdmlhIEFKQVg6IGZyb20gZGV2aWNlLCBieSBVUkwgb3IgRmlsZSBwYXN0aW5nXG4gKiAgMykgdWkudHMg4oCUIG1vZHVsZSBmb3IgVUkgbWFuaXB1bGF0aW9uczogcmVuZGVyLCBzaG93aW5nIHByZWxvYWRlciwgZXRjXG4gKlxuICogRm9yIGRlYnVnIHB1cnBvc2VzIHRoZXJlIGlzIGEgdGVzdGluZyBzZXJ2ZXJcbiAqIHRoYXQgY2FuIHNhdmUgdXBsb2FkZWQgZmlsZXMgYW5kIHJldHVybiBhIFJlc3BvbnNlIHtAbGluayBVcGxvYWRSZXNwb25zZUZvcm1hdH1cbiAqXG4gKiAgICAgICAkIG5vZGUgZGV2L3NlcnZlci5qc1xuICpcbiAqIEl0IHdpbGwgZXhwb3NlIDgwMDggcG9ydCwgc28geW91IGNhbiBwYXNzIGh0dHA6Ly9sb2NhbGhvc3Q6ODAwOCB3aXRoIHRoZSBUb29scyBjb25maWc6XG4gKlxuICogaW1hZ2U6IHtcbiAqICAgY2xhc3M6IEltYWdlVG9vbCxcbiAqICAgY29uZmlnOiB7XG4gKiAgICAgZW5kcG9pbnRzOiB7XG4gKiAgICAgICBieUZpbGU6ICdodHRwOi8vbG9jYWxob3N0OjgwMDgvdXBsb2FkRmlsZScsXG4gKiAgICAgICBieVVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwOC9mZXRjaFVybCcsXG4gKiAgICAgfVxuICogICB9LFxuICogfSxcbiAqL1xuY2xhc3MgUCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdG9vbCAtIHRvb2wgcHJvcGVydGllcyBnb3QgZnJvbSBlZGl0b3IuanNcbiAgICogQHBhcmFtIHRvb2wuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0gdG9vbC5jb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0gdG9vbC5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSB0b29sLnJlYWRPbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKiBAcGFyYW0gdG9vbC5ibG9jayAtIGN1cnJlbnQgQmxvY2sgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGksIGNvbmZpZzogYSwgYXBpOiBzLCByZWFkT25seTogciwgYmxvY2s6IGUgfSkge1xuICAgIHRoaXMuYXBpID0gcywgdGhpcy5ibG9jayA9IGUsIHRoaXMuY29uZmlnID0ge1xuICAgICAgZW5kcG9pbnRzOiBhLmVuZHBvaW50cyxcbiAgICAgIGFkZGl0aW9uYWxSZXF1ZXN0RGF0YTogYS5hZGRpdGlvbmFsUmVxdWVzdERhdGEsXG4gICAgICBhZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnM6IGEuYWRkaXRpb25hbFJlcXVlc3RIZWFkZXJzLFxuICAgICAgZmllbGQ6IGEuZmllbGQsXG4gICAgICB0eXBlczogYS50eXBlcyxcbiAgICAgIGNhcHRpb25QbGFjZWhvbGRlcjogdGhpcy5hcGkuaTE4bi50KGEuY2FwdGlvblBsYWNlaG9sZGVyID8/IFwiQ2FwdGlvblwiKSxcbiAgICAgIGJ1dHRvbkNvbnRlbnQ6IGEuYnV0dG9uQ29udGVudCxcbiAgICAgIHVwbG9hZGVyOiBhLnVwbG9hZGVyLFxuICAgICAgYWN0aW9uczogYS5hY3Rpb25zLFxuICAgICAgZmVhdHVyZXM6IGEuZmVhdHVyZXMgfHwge31cbiAgICB9LCB0aGlzLnVwbG9hZGVyID0gbmV3IEEoe1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIG9uVXBsb2FkOiAobykgPT4gdGhpcy5vblVwbG9hZChvKSxcbiAgICAgIG9uRXJyb3I6IChvKSA9PiB0aGlzLnVwbG9hZGluZ0ZhaWxlZChvKVxuICAgIH0pLCB0aGlzLnVpID0gbmV3IFUoe1xuICAgICAgYXBpOiBzLFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIG9uU2VsZWN0RmlsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnVwbG9hZGVyLnVwbG9hZFNlbGVjdGVkRmlsZSh7XG4gICAgICAgICAgb25QcmV2aWV3OiAobykgPT4ge1xuICAgICAgICAgICAgdGhpcy51aS5zaG93UHJlbG9hZGVyKG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVhZE9ubHk6IHJcbiAgICB9KSwgdGhpcy5fZGF0YSA9IHtcbiAgICAgIGNhcHRpb246IFwiXCIsXG4gICAgICB3aXRoQm9yZGVyOiAhMSxcbiAgICAgIHdpdGhCYWNrZ3JvdW5kOiAhMSxcbiAgICAgIHN0cmV0Y2hlZDogITEsXG4gICAgICBmaWxlOiB7XG4gICAgICAgIHVybDogXCJcIlxuICAgICAgfVxuICAgIH0sIHRoaXMuZGF0YSA9IGk7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICovXG4gIHN0YXRpYyBnZXQgdG9vbGJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogTCxcbiAgICAgIHRpdGxlOiBcIkltYWdlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgaW1hZ2UgdG9vbHNcbiAgICovXG4gIHN0YXRpYyBnZXQgdHVuZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJ3aXRoQm9yZGVyXCIsXG4gICAgICAgIGljb246IEksXG4gICAgICAgIHRpdGxlOiBcIldpdGggYm9yZGVyXCIsXG4gICAgICAgIHRvZ2dsZTogITBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwic3RyZXRjaGVkXCIsXG4gICAgICAgIGljb246IHgsXG4gICAgICAgIHRpdGxlOiBcIlN0cmV0Y2ggaW1hZ2VcIixcbiAgICAgICAgdG9nZ2xlOiAhMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJ3aXRoQmFja2dyb3VuZFwiLFxuICAgICAgICBpY29uOiBSLFxuICAgICAgICB0aXRsZTogXCJXaXRoIGJhY2tncm91bmRcIixcbiAgICAgICAgdG9nZ2xlOiAhMFxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgQmxvY2sgY29udGVudFxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHZhciBpLCBhLCBzO1xuICAgIHJldHVybiAoKChpID0gdGhpcy5jb25maWcuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiBpLmNhcHRpb24pID09PSAhMCB8fCAoKGEgPSB0aGlzLmNvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FwdGlvbikgPT09IHZvaWQgMCB8fCAoKHMgPSB0aGlzLmNvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY2FwdGlvbikgPT09IFwib3B0aW9uYWxcIiAmJiB0aGlzLmRhdGEuY2FwdGlvbikgJiYgdGhpcy51aS5hcHBseVR1bmUoXCJjYXB0aW9uXCIsICEwKSwgdGhpcy51aS5yZW5kZXIodGhpcy5kYXRhKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgZGF0YTogY2hlY2sgaWYgSW1hZ2UgZXhpc3RzXG4gICAqIEBwYXJhbSBzYXZlZERhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIGZhbHNlIGlmIHNhdmVkIGRhdGEgaXMgbm90IGNvcnJlY3QsIG90aGVyd2lzZSB0cnVlXG4gICAqL1xuICB2YWxpZGF0ZShpKSB7XG4gICAgcmV0dXJuICEhaS5maWxlLnVybDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEJsb2NrIGRhdGFcbiAgICovXG4gIHNhdmUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMudWkubm9kZXMuY2FwdGlvbjtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5jYXB0aW9uID0gaS5pbm5lckhUTUwsIHRoaXMuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb25maWd1cmF0aW9uIGZvciBibG9jayB0dW5lczogYWRkIGJhY2tncm91bmQsIGFkZCBib3JkZXIsIHN0cmV0Y2ggaW1hZ2VcbiAgICogQHJldHVybnMgVHVuZXNNZW51Q29uZmlnXG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBpID0gUC50dW5lcy5jb25jYXQodGhpcy5jb25maWcuYWN0aW9ucyB8fCBbXSksIGEgPSB7XG4gICAgICBib3JkZXI6IFwid2l0aEJvcmRlclwiLFxuICAgICAgYmFja2dyb3VuZDogXCJ3aXRoQmFja2dyb3VuZFwiLFxuICAgICAgc3RyZXRjaDogXCJzdHJldGNoZWRcIixcbiAgICAgIGNhcHRpb246IFwiY2FwdGlvblwiXG4gICAgfTtcbiAgICByZXR1cm4gKChyID0gdGhpcy5jb25maWcuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiByLmNhcHRpb24pID09PSBcIm9wdGlvbmFsXCIgJiYgaS5wdXNoKHtcbiAgICAgIG5hbWU6IFwiY2FwdGlvblwiLFxuICAgICAgaWNvbjogQixcbiAgICAgIHRpdGxlOiBcIldpdGggY2FwdGlvblwiLFxuICAgICAgdG9nZ2xlOiAhMFxuICAgIH0pLCBpLmZpbHRlcigoZSkgPT4ge1xuICAgICAgdmFyIGQsIHY7XG4gICAgICBjb25zdCBvID0gT2JqZWN0LmtleXMoYSkuZmluZCgobCkgPT4gYVtsXSA9PT0gZS5uYW1lKTtcbiAgICAgIHJldHVybiBvID09PSBcImNhcHRpb25cIiA/ICgoZCA9IHRoaXMuY29uZmlnLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogZC5jYXB0aW9uKSAhPT0gITEgOiBvID09IG51bGwgfHwgKCh2ID0gdGhpcy5jb25maWcuZmVhdHVyZXMpID09IG51bGwgPyB2b2lkIDAgOiB2W29dKSAhPT0gITE7XG4gICAgfSkubWFwKChlKSA9PiAoe1xuICAgICAgaWNvbjogZS5pY29uLFxuICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChlLnRpdGxlKSxcbiAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgIHRvZ2dsZTogZS50b2dnbGUsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5kYXRhW2UubmFtZV0sXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5hY3Rpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZS5hY3Rpb24oZS5uYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50dW5lVG9nZ2xlZChlLm5hbWUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmlyZXMgYWZ0ZXIgY2xpY2tzIG9uIHRoZSBUb29sYm94IEltYWdlIEljb25cbiAgICogSW5pdGlhdGVzIGNsaWNrIG9uIHRoZSBTZWxlY3QgRmlsZSBidXR0b25cbiAgICovXG4gIGFwcGVuZENhbGxiYWNrKCkge1xuICAgIHRoaXMudWkubm9kZXMuZmlsZUJ1dHRvbi5jbGljaygpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHBhc3RlIHN1YnN0aXR1dGVzXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RleC10ZWFtL2VkaXRvci5qcy9ibG9iL21hc3Rlci9kb2NzL3Rvb2xzLm1kI3Bhc3RlLWhhbmRsaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBQYXN0ZSBIVE1MIGludG8gRWRpdG9yXG4gICAgICAgKi9cbiAgICAgIHRhZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGltZzogeyBzcmM6ICEwIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIC8qKlxuICAgICAgICogUGFzdGUgVVJMIG9mIGltYWdlIGludG8gdGhlIEVkaXRvclxuICAgICAgICovXG4gICAgICBwYXR0ZXJuczoge1xuICAgICAgICBpbWFnZTogL2h0dHBzPzpcXC9cXC9cXFMrXFwuKGdpZnxqcGU/Z3x0aWZmfHBuZ3xzdmd8d2VicCkoXFw/W2EtejAtOT1dKik/JC9pXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBEcmFnIG4gZHJvcCBmaWxlIGZyb20gaW50byB0aGUgRWRpdG9yXG4gICAgICAgKi9cbiAgICAgIGZpbGVzOiB7XG4gICAgICAgIG1pbWVUeXBlczogW1wiaW1hZ2UvKlwiXVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZnkgcGFzdGUgaGFuZGxlcnNcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL2RvY3MvdG9vbHMubWQjcGFzdGUtaGFuZGxpbmd9XG4gICAqIEBwYXJhbSBldmVudCAtIGVkaXRvci5qcyBjdXN0b20gcGFzdGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL3R5cGVzL3Rvb2xzL3Bhc3RlLWV2ZW50cy5kLnRzfVxuICAgKi9cbiAgYXN5bmMgb25QYXN0ZShpKSB7XG4gICAgc3dpdGNoIChpLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0YWdcIjoge1xuICAgICAgICBjb25zdCBhID0gaS5kZXRhaWwuZGF0YTtcbiAgICAgICAgaWYgKC9eYmxvYjovLnRlc3QoYS5zcmMpKSB7XG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IChhd2FpdCBmZXRjaChhLnNyYykpLmJsb2IoKTtcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGUocik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGxvYWRVcmwoYS5zcmMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJwYXR0ZXJuXCI6IHtcbiAgICAgICAgY29uc3QgYSA9IGkuZGV0YWlsLmRhdGE7XG4gICAgICAgIHRoaXMudXBsb2FkVXJsKGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgY29uc3QgYSA9IGkuZGV0YWlsLmZpbGU7XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZShhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICogzL/MvyDMv8y/IMy/zL8gzL8nzL8nXFzMtc2HzL/Mv1xc0Lc9ICgg4paAIM2czZ7KluKWgCkgPc61L8y1zYfMv8y/L+KAmcy/4oCZzL8gzL8gzL/MvyDMv8y/IMy/zL9cbiAgICovXG4gIC8qKlxuICAgKiBTdG9yZXMgYWxsIFRvb2wncyBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBpbiBJbWFnZSBUb29sIGZvcm1hdFxuICAgKi9cbiAgc2V0IGRhdGEoaSkge1xuICAgIHRoaXMuaW1hZ2UgPSBpLmZpbGUsIHRoaXMuX2RhdGEuY2FwdGlvbiA9IGkuY2FwdGlvbiB8fCBcIlwiLCB0aGlzLnVpLmZpbGxDYXB0aW9uKHRoaXMuX2RhdGEuY2FwdGlvbiksIFAudHVuZXMuZm9yRWFjaCgoeyBuYW1lOiBhIH0pID0+IHtcbiAgICAgIGNvbnN0IHMgPSB0eXBlb2YgaVthXSA8IFwidVwiID8gaVthXSA9PT0gITAgfHwgaVthXSA9PT0gXCJ0cnVlXCIgOiAhMTtcbiAgICAgIHRoaXMuc2V0VHVuZShhLCBzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wgZGF0YVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBuZXcgaW1hZ2UgZmlsZVxuICAgKiBAcGFyYW0gZmlsZSAtIHVwbG9hZGVkIGZpbGUgZGF0YVxuICAgKi9cbiAgc2V0IGltYWdlKGkpIHtcbiAgICB0aGlzLl9kYXRhLmZpbGUgPSBpIHx8IHsgdXJsOiBcIlwiIH0sIGkgJiYgaS51cmwgJiYgdGhpcy51aS5maWxsSW1hZ2UoaS51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBGaWxlIHVwbG9hZGluZyBjYWxsYmFja1xuICAgKiBAcGFyYW0gcmVzcG9uc2UgLSB1cGxvYWRpbmcgc2VydmVyIHJlc3BvbnNlXG4gICAqL1xuICBvblVwbG9hZChpKSB7XG4gICAgaS5zdWNjZXNzICYmIGkuZmlsZSA/IHRoaXMuaW1hZ2UgPSBpLmZpbGUgOiB0aGlzLnVwbG9hZGluZ0ZhaWxlZChcImluY29ycmVjdCByZXNwb25zZTogXCIgKyBKU09OLnN0cmluZ2lmeShpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSB1cGxvYWRlciBlcnJvcnNcbiAgICogQHBhcmFtIGVycm9yVGV4dCAtIHVwbG9hZGluZyBlcnJvciBpbmZvXG4gICAqL1xuICB1cGxvYWRpbmdGYWlsZWQoaSkge1xuICAgIGNvbnNvbGUubG9nKFwiSW1hZ2UgVG9vbDogdXBsb2FkaW5nIGZhaWxlZCBiZWNhdXNlIG9mXCIsIGkpLCB0aGlzLmFwaS5ub3RpZmllci5zaG93KHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMuYXBpLmkxOG4udChcIkNvdWxkbuKAmXQgdXBsb2FkIGltYWdlLiBQbGVhc2UgdHJ5IGFub3RoZXIuXCIpLFxuICAgICAgc3R5bGU6IFwiZXJyb3JcIlxuICAgIH0pLCB0aGlzLnVpLmhpZGVQcmVsb2FkZXIoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiBCbG9jayBUdW5lIGlzIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0gdHVuZU5hbWUgLSB0dW5lIHRoYXQgaGFzIGJlZW4gY2xpY2tlZFxuICAgKi9cbiAgdHVuZVRvZ2dsZWQoaSkge1xuICAgIHRoaXMuc2V0VHVuZShpLCAhdGhpcy5fZGF0YVtpXSksIGkgPT09IFwiY2FwdGlvblwiICYmICF0aGlzLl9kYXRhW2ldICYmICh0aGlzLl9kYXRhLmNhcHRpb24gPSBcIlwiLCB0aGlzLnVpLmZpbGxDYXB0aW9uKFwiXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9uZSB0dW5lXG4gICAqIEBwYXJhbSB0dW5lTmFtZSAtIHtAbGluayBUdW5lcy50dW5lc31cbiAgICogQHBhcmFtIHZhbHVlIC0gdHVuZSBzdGF0ZVxuICAgKi9cbiAgc2V0VHVuZShpLCBhKSB7XG4gICAgdGhpcy5fZGF0YVtpXSA9IGEsIHRoaXMudWkuYXBwbHlUdW5lKGksIGEpLCBpID09PSBcInN0cmV0Y2hlZFwiICYmIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ibG9jay5zdHJldGNoZWQgPSBhO1xuICAgIH0pLmNhdGNoKChzKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKHMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaG93IHByZWxvYWRlciBhbmQgdXBsb2FkIGltYWdlIGZpbGVcbiAgICogQHBhcmFtIGZpbGUgLSBmaWxlIHRoYXQgaXMgY3VycmVudGx5IHVwbG9hZGluZyAoZnJvbSBwYXN0ZSlcbiAgICovXG4gIHVwbG9hZEZpbGUoaSkge1xuICAgIHRoaXMudXBsb2FkZXIudXBsb2FkQnlGaWxlKGksIHtcbiAgICAgIG9uUHJldmlldzogKGEpID0+IHtcbiAgICAgICAgdGhpcy51aS5zaG93UHJlbG9hZGVyKGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaG93IHByZWxvYWRlciBhbmQgdXBsb2FkIGltYWdlIGJ5IHRhcmdldCB1cmxcbiAgICogQHBhcmFtIHVybCAtIHVybCBwYXN0ZWRcbiAgICovXG4gIHVwbG9hZFVybChpKSB7XG4gICAgdGhpcy51aS5zaG93UHJlbG9hZGVyKGkpLCB0aGlzLnVwbG9hZGVyLnVwbG9hZEJ5VXJsKGkpO1xuICB9XG59XG5leHBvcnQge1xuICBQIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/image/dist/image.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/list/dist/editorjs-list.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@editorjs/list/dist/editorjs-list.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ G)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.cdx-list{margin:0;padding:0;outline:none;display:grid;counter-reset:item;gap:var(--spacing-s);padding:var(--spacing-xs);--spacing-s: 8px;--spacing-xs: 6px;--list-counter-type: numeric;--radius-border: 5px;--checkbox-background: #fff;--color-border: #C9C9C9;--color-bg-checked: #369FFF;--line-height: 1.45em;--color-bg-checked-hover: #0059AB;--color-tick: #fff;--size-checkbox: 1.2em}.cdx-list__item{line-height:var(--line-height);display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto auto;grid-template-areas:\"checkbox content\" \". child\"}.cdx-list__item-children{display:grid;grid-area:child;gap:var(--spacing-s);padding-top:var(--spacing-s)}.cdx-list__item [contenteditable]{outline:none}.cdx-list__item-content{word-break:break-word;white-space:pre-wrap;grid-area:content;padding-left:var(--spacing-s)}.cdx-list__item:before{counter-increment:item;white-space:nowrap}.cdx-list-ordered .cdx-list__item:before{content:counters(item,\".\",var(--list-counter-type)) \".\"}.cdx-list-ordered{counter-reset:item}.cdx-list-unordered .cdx-list__item:before{content:\"•\"}.cdx-list-checklist .cdx-list__item:before{content:\"\"}.cdx-list__settings .cdx-settings-button{width:50%}.cdx-list__checkbox{padding-top:calc((var(--line-height) - var(--size-checkbox)) / 2);grid-area:checkbox;width:var(--size-checkbox);height:var(--size-checkbox);display:flex;cursor:pointer}.cdx-list__checkbox svg{opacity:0;height:var(--size-checkbox);width:var(--size-checkbox);left:-1px;top:-1px;position:absolute}@media (hover: hover){.cdx-list__checkbox:not(.cdx-list__checkbox--no-hover):hover .cdx-list__checkbox-check svg{opacity:1}}.cdx-list__checkbox--checked{line-height:var(--line-height)}@media (hover: hover){.cdx-list__checkbox--checked:not(.cdx-list__checkbox--checked--no-hover):hover .cdx-checklist__checkbox-check{background:var(--color-bg-checked-hover);border-color:var(--color-bg-checked-hover)}}.cdx-list__checkbox--checked .cdx-list__checkbox-check{background:var(--color-bg-checked);border-color:var(--color-bg-checked)}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg{opacity:1}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg path{stroke:var(--color-tick)}.cdx-list__checkbox--checked .cdx-list__checkbox-check:before{opacity:0;visibility:visible;transform:scale(2.5)}.cdx-list__checkbox-check{cursor:pointer;display:inline-block;position:relative;margin:0 auto;width:var(--size-checkbox);height:var(--size-checkbox);box-sizing:border-box;border-radius:var(--radius-border);border:1px solid var(--color-border);background:var(--checkbox-background)}.cdx-list__checkbox-check:before{content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;border-radius:100%;background-color:var(--color-bg-checked);visibility:hidden;pointer-events:none;transform:scale(1);transition:transform .4s ease-out,opacity .4s}.cdx-list-start-with-field{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-list-start-with-field--invalid{background:#FFECED;border:1px solid #E13F3F}.cdx-list-start-with-field--invalid .cdx-list-start-with-field__input{color:#e13f3f}.cdx-list-start-with-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - var(--toolbox-buttons-size) - var(--icon-margin-right))}.cdx-list-start-with-field__input::placeholder{color:var(--grayText);font-weight:500}')),document.head.appendChild(e)}}catch(c){console.error(\"vite-plugin-css-injected-by-js\",c)}})();\nconst Ct = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 12L10.4884 15.8372C10.5677 15.9245 10.705 15.9245 10.7844 15.8372L17 9\"/></svg>', Ae = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9.2 12L11.0586 13.8586C11.1367 13.9367 11.2633 13.9367 11.3414 13.8586L14.7 10.5\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', $e = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"9\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 17H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 12H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 7H4.99002\"/></svg>', Be = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"12\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5\"/></svg>', St = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 14.2L10 7.4135C10 7.32872 9.90111 7.28241 9.83598 7.33668L7 9.7\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', Ot = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 14.2L10 9.5\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 7.01L10 7\" stroke=\"black\" stroke-width=\"1.8\" stroke-linecap=\"round\"/></svg>', kt = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 14.2L10 7.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', _t = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.0087 14.2H16\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M7 14.2L7.78865 12M13 14.2L12.1377 12M7.78865 12C7.78865 12 9.68362 7 10 7C10.3065 7 12.1377 12 12.1377 12M7.78865 12L12.1377 12\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', Et = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14.2087 14.2H14.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M11.5 14.5C11.5 14.5 11 13.281 11 12.5M7 9.5C7 9.5 7.5 8.5 9 8.5C10.5 8.5 11 9.5 11 10.5L11 11.5M11 11.5L11 12.5M11 11.5C11 11.5 7 11 7 13C7 15.3031 11 15 11 12.5\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', It = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8 14.2L8 7.4135C8 7.32872 7.90111 7.28241 7.83598 7.33668L5 9.7\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M14 13L16.4167 10.7778M16.4167 10.7778L14 8.5M16.4167 10.7778H11.6562\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>';\nvar A = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction wt(e) {\n  if (e.__esModule)\n    return e;\n  var t = e.default;\n  if (typeof t == \"function\") {\n    var n = function r() {\n      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);\n    };\n    n.prototype = t.prototype;\n  } else\n    n = {};\n  return Object.defineProperty(n, \"__esModule\", { value: !0 }), Object.keys(e).forEach(function(r) {\n    var i = Object.getOwnPropertyDescriptor(e, r);\n    Object.defineProperty(n, r, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return e[r];\n      }\n    });\n  }), n;\n}\nvar c = {}, V = {}, Y = {};\nObject.defineProperty(Y, \"__esModule\", { value: !0 });\nY.allInputsSelector = Pt;\nfunction Pt() {\n  var e = [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"];\n  return \"[contenteditable=true], textarea, input:not([type]), \" + e.map(function(t) {\n    return 'input[type=\"'.concat(t, '\"]');\n  }).join(\", \");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.allInputsSelector = void 0;\n  var t = Y;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n})(V);\nvar k = {}, J = {};\nObject.defineProperty(J, \"__esModule\", { value: !0 });\nJ.isNativeInput = jt;\nfunction jt(e) {\n  var t = [\n    \"INPUT\",\n    \"TEXTAREA\"\n  ];\n  return e && e.tagName ? t.includes(e.tagName) : !1;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNativeInput = void 0;\n  var t = J;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return t.isNativeInput;\n  } });\n})(k);\nvar Fe = {}, Q = {};\nObject.defineProperty(Q, \"__esModule\", { value: !0 });\nQ.append = Tt;\nfunction Tt(e, t) {\n  Array.isArray(t) ? t.forEach(function(n) {\n    e.appendChild(n);\n  }) : e.appendChild(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.append = void 0;\n  var t = Q;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return t.append;\n  } });\n})(Fe);\nvar Z = {}, x = {};\nObject.defineProperty(x, \"__esModule\", { value: !0 });\nx.blockElements = Lt;\nfunction Lt() {\n  return [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"canvas\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"noscript\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tr\",\n    \"tfoot\",\n    \"ul\",\n    \"video\"\n  ];\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.blockElements = void 0;\n  var t = x;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return t.blockElements;\n  } });\n})(Z);\nvar Re = {}, ee = {};\nObject.defineProperty(ee, \"__esModule\", { value: !0 });\nee.calculateBaseline = Mt;\nfunction Mt(e) {\n  var t = window.getComputedStyle(e), n = parseFloat(t.fontSize), r = parseFloat(t.lineHeight) || n * 1.2, i = parseFloat(t.paddingTop), a = parseFloat(t.borderTopWidth), l = parseFloat(t.marginTop), s = n * 0.8, o = (r - n) / 2, d = l + a + i + o + s;\n  return d;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.calculateBaseline = void 0;\n  var t = ee;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return t.calculateBaseline;\n  } });\n})(Re);\nvar qe = {}, te = {}, ne = {}, re = {};\nObject.defineProperty(re, \"__esModule\", { value: !0 });\nre.isContentEditable = Nt;\nfunction Nt(e) {\n  return e.contentEditable === \"true\";\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isContentEditable = void 0;\n  var t = re;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return t.isContentEditable;\n  } });\n})(ne);\nObject.defineProperty(te, \"__esModule\", { value: !0 });\nte.canSetCaret = Bt;\nvar At = k, $t = ne;\nfunction Bt(e) {\n  var t = !0;\n  if ((0, At.isNativeInput)(e))\n    switch (e.type) {\n      case \"file\":\n      case \"checkbox\":\n      case \"radio\":\n      case \"hidden\":\n      case \"submit\":\n      case \"button\":\n      case \"image\":\n      case \"reset\":\n        t = !1;\n        break;\n    }\n  else\n    t = (0, $t.isContentEditable)(e);\n  return t;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.canSetCaret = void 0;\n  var t = te;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return t.canSetCaret;\n  } });\n})(qe);\nvar $ = {}, ie = {};\nfunction Wt(e, t, n) {\n  const r = n.value !== void 0 ? \"value\" : \"get\", i = n[r], a = `#${t}Cache`;\n  if (n[r] = function(...l) {\n    return this[a] === void 0 && (this[a] = i.apply(this, l)), this[a];\n  }, r === \"get\" && n.set) {\n    const l = n.set;\n    n.set = function(s) {\n      delete e[a], l.apply(this, s);\n    };\n  }\n  return n;\n}\nfunction Ue() {\n  const e = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, t = Object.keys(e).find((n) => window.navigator.appVersion.toLowerCase().indexOf(n) !== -1);\n  return t !== void 0 && (e[t] = !0), e;\n}\nfunction ae(e) {\n  return e != null && e !== \"\" && (typeof e != \"object\" || Object.keys(e).length > 0);\n}\nfunction Dt(e) {\n  return !ae(e);\n}\nconst Ht = () => typeof window < \"u\" && window.navigator !== null && ae(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Ft(e) {\n  const t = Ue();\n  return e = e.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \"+\"), t.mac ? e = e.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : e = e.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), e;\n}\nfunction Rt(e) {\n  return e[0].toUpperCase() + e.slice(1);\n}\nfunction qt(e) {\n  const t = document.createElement(\"div\");\n  t.style.position = \"absolute\", t.style.left = \"-999px\", t.style.bottom = \"-999px\", t.innerHTML = e, document.body.appendChild(t);\n  const n = window.getSelection(), r = document.createRange();\n  if (r.selectNode(t), n === null)\n    throw new Error(\"Cannot copy text to clipboard\");\n  n.removeAllRanges(), n.addRange(r), document.execCommand(\"copy\"), document.body.removeChild(t);\n}\nfunction Ut(e, t, n) {\n  let r;\n  return (...i) => {\n    const a = this, l = () => {\n      r = void 0, n !== !0 && e.apply(a, i);\n    }, s = n === !0 && r !== void 0;\n    window.clearTimeout(r), r = window.setTimeout(l, t), s && e.apply(a, i);\n  };\n}\nfunction S(e) {\n  return Object.prototype.toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction zt(e) {\n  return S(e) === \"boolean\";\n}\nfunction ze(e) {\n  return S(e) === \"function\" || S(e) === \"asyncfunction\";\n}\nfunction Kt(e) {\n  return ze(e) && /^\\s*class\\s+/.test(e.toString());\n}\nfunction Xt(e) {\n  return S(e) === \"number\";\n}\nfunction M(e) {\n  return S(e) === \"object\";\n}\nfunction Gt(e) {\n  return Promise.resolve(e) === e;\n}\nfunction Vt(e) {\n  return S(e) === \"string\";\n}\nfunction Yt(e) {\n  return S(e) === \"undefined\";\n}\nfunction X(e, ...t) {\n  if (!t.length)\n    return e;\n  const n = t.shift();\n  if (M(e) && M(n))\n    for (const r in n)\n      M(n[r]) ? (e[r] === void 0 && Object.assign(e, { [r]: {} }), X(e[r], n[r])) : Object.assign(e, { [r]: n[r] });\n  return X(e, ...t);\n}\nfunction Jt(e, t, n) {\n  const r = `«${t}» is deprecated and will be removed in the next major release. Please use the «${n}» instead.`;\n  e && console.warn(r);\n}\nfunction Qt(e) {\n  try {\n    return new URL(e).href;\n  } catch {\n  }\n  return e.substring(0, 2) === \"//\" ? window.location.protocol + e : window.location.origin + e;\n}\nfunction Zt(e) {\n  return e > 47 && e < 58 || e === 32 || e === 13 || e === 229 || e > 64 && e < 91 || e > 95 && e < 112 || e > 185 && e < 193 || e > 218 && e < 223;\n}\nconst xt = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, en = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nclass tn {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   * @param operation - promise should be added to queue\n   */\n  add(t) {\n    return new Promise((n, r) => {\n      this.completed = this.completed.then(t).then(n).catch(r);\n    });\n  }\n}\nfunction nn(e, t, n = void 0) {\n  let r, i, a, l = null, s = 0;\n  n || (n = {});\n  const o = function() {\n    s = n.leading === !1 ? 0 : Date.now(), l = null, a = e.apply(r, i), l === null && (r = i = null);\n  };\n  return function() {\n    const d = Date.now();\n    !s && n.leading === !1 && (s = d);\n    const u = t - (d - s);\n    return r = this, i = arguments, u <= 0 || u > t ? (l && (clearTimeout(l), l = null), s = d, a = e.apply(r, i), l === null && (r = i = null)) : !l && n.trailing !== !1 && (l = setTimeout(o, u)), a;\n  };\n}\nconst rn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  PromiseQueue: tn,\n  beautifyShortcut: Ft,\n  cacheable: Wt,\n  capitalize: Rt,\n  copyTextToClipboard: qt,\n  debounce: Ut,\n  deepMerge: X,\n  deprecationAssert: Jt,\n  getUserOS: Ue,\n  getValidUrl: Qt,\n  isBoolean: zt,\n  isClass: Kt,\n  isEmpty: Dt,\n  isFunction: ze,\n  isIosDevice: Ht,\n  isNumber: Xt,\n  isObject: M,\n  isPrintableKey: Zt,\n  isPromise: Gt,\n  isString: Vt,\n  isUndefined: Yt,\n  keyCodes: xt,\n  mouseButtons: en,\n  notEmpty: ae,\n  throttle: nn,\n  typeOf: S\n}, Symbol.toStringTag, { value: \"Module\" })), le = /* @__PURE__ */ wt(rn);\nObject.defineProperty(ie, \"__esModule\", { value: !0 });\nie.containsOnlyInlineElements = sn;\nvar an = le, ln = Z;\nfunction sn(e) {\n  var t;\n  (0, an.isString)(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n  var n = function(r) {\n    return !(0, ln.blockElements)().includes(r.tagName.toLowerCase()) && Array.from(r.children).every(n);\n  };\n  return Array.from(t.children).every(n);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.containsOnlyInlineElements = void 0;\n  var t = ie;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return t.containsOnlyInlineElements;\n  } });\n})($);\nvar Ke = {}, se = {}, B = {}, oe = {};\nObject.defineProperty(oe, \"__esModule\", { value: !0 });\noe.make = on;\nfunction on(e, t, n) {\n  var r;\n  t === void 0 && (t = null), n === void 0 && (n = {});\n  var i = document.createElement(e);\n  if (Array.isArray(t)) {\n    var a = t.filter(function(s) {\n      return s !== void 0;\n    });\n    (r = i.classList).add.apply(r, a);\n  } else\n    t !== null && i.classList.add(t);\n  for (var l in n)\n    Object.prototype.hasOwnProperty.call(n, l) && (i[l] = n[l]);\n  return i;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.make = void 0;\n  var t = oe;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return t.make;\n  } });\n})(B);\nObject.defineProperty(se, \"__esModule\", { value: !0 });\nse.fragmentToString = cn;\nvar un = B;\nfunction cn(e) {\n  var t = (0, un.make)(\"div\");\n  return t.appendChild(e), t.innerHTML;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.fragmentToString = void 0;\n  var t = se;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return t.fragmentToString;\n  } });\n})(Ke);\nvar Xe = {}, ue = {};\nObject.defineProperty(ue, \"__esModule\", { value: !0 });\nue.getContentLength = fn;\nvar dn = k;\nfunction fn(e) {\n  var t, n;\n  return (0, dn.isNativeInput)(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : (n = (t = e.textContent) === null || t === void 0 ? void 0 : t.length) !== null && n !== void 0 ? n : 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getContentLength = void 0;\n  var t = ue;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return t.getContentLength;\n  } });\n})(Xe);\nvar ce = {}, de = {}, We = A && A.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(de, \"__esModule\", { value: !0 });\nde.getDeepestBlockElements = Ge;\nvar pn = $;\nfunction Ge(e) {\n  return (0, pn.containsOnlyInlineElements)(e) ? [e] : Array.from(e.children).reduce(function(t, n) {\n    return We(We([], t, !0), Ge(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestBlockElements = void 0;\n  var t = de;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return t.getDeepestBlockElements;\n  } });\n})(ce);\nvar Ve = {}, fe = {}, W = {}, pe = {};\nObject.defineProperty(pe, \"__esModule\", { value: !0 });\npe.isLineBreakTag = mn;\nfunction mn(e) {\n  return [\n    \"BR\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLineBreakTag = void 0;\n  var t = pe;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return t.isLineBreakTag;\n  } });\n})(W);\nvar D = {}, me = {};\nObject.defineProperty(me, \"__esModule\", { value: !0 });\nme.isSingleTag = hn;\nfunction hn(e) {\n  return [\n    \"AREA\",\n    \"BASE\",\n    \"BR\",\n    \"COL\",\n    \"COMMAND\",\n    \"EMBED\",\n    \"HR\",\n    \"IMG\",\n    \"INPUT\",\n    \"KEYGEN\",\n    \"LINK\",\n    \"META\",\n    \"PARAM\",\n    \"SOURCE\",\n    \"TRACK\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isSingleTag = void 0;\n  var t = me;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return t.isSingleTag;\n  } });\n})(D);\nObject.defineProperty(fe, \"__esModule\", { value: !0 });\nfe.getDeepestNode = Ye;\nvar gn = k, vn = W, bn = D;\nfunction Ye(e, t) {\n  t === void 0 && (t = !1);\n  var n = t ? \"lastChild\" : \"firstChild\", r = t ? \"previousSibling\" : \"nextSibling\";\n  if (e.nodeType === Node.ELEMENT_NODE && e[n]) {\n    var i = e[n];\n    if ((0, bn.isSingleTag)(i) && !(0, gn.isNativeInput)(i) && !(0, vn.isLineBreakTag)(i))\n      if (i[r])\n        i = i[r];\n      else if (i.parentNode !== null && i.parentNode[r])\n        i = i.parentNode[r];\n      else\n        return i.parentNode;\n    return Ye(i, t);\n  }\n  return e;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestNode = void 0;\n  var t = fe;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return t.getDeepestNode;\n  } });\n})(Ve);\nvar Je = {}, he = {}, j = A && A.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(he, \"__esModule\", { value: !0 });\nhe.findAllInputs = kn;\nvar yn = $, Cn = ce, Sn = V, On = k;\nfunction kn(e) {\n  return Array.from(e.querySelectorAll((0, Sn.allInputsSelector)())).reduce(function(t, n) {\n    return (0, On.isNativeInput)(n) || (0, yn.containsOnlyInlineElements)(n) ? j(j([], t, !0), [n], !1) : j(j([], t, !0), (0, Cn.getDeepestBlockElements)(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.findAllInputs = void 0;\n  var t = he;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return t.findAllInputs;\n  } });\n})(Je);\nvar Qe = {}, ge = {};\nObject.defineProperty(ge, \"__esModule\", { value: !0 });\nge.isCollapsedWhitespaces = _n;\nfunction _n(e) {\n  return !/[^\\t\\n\\r ]/.test(e);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCollapsedWhitespaces = void 0;\n  var t = ge;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return t.isCollapsedWhitespaces;\n  } });\n})(Qe);\nvar ve = {}, be = {};\nObject.defineProperty(be, \"__esModule\", { value: !0 });\nbe.isElement = In;\nvar En = le;\nfunction In(e) {\n  return (0, En.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isElement = void 0;\n  var t = be;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return t.isElement;\n  } });\n})(ve);\nvar Ze = {}, ye = {}, Ce = {}, Se = {};\nObject.defineProperty(Se, \"__esModule\", { value: !0 });\nSe.isLeaf = wn;\nfunction wn(e) {\n  return e === null ? !1 : e.childNodes.length === 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLeaf = void 0;\n  var t = Se;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return t.isLeaf;\n  } });\n})(Ce);\nvar Oe = {}, ke = {};\nObject.defineProperty(ke, \"__esModule\", { value: !0 });\nke.isNodeEmpty = Mn;\nvar Pn = W, jn = ve, Tn = k, Ln = D;\nfunction Mn(e, t) {\n  var n = \"\";\n  return (0, Ln.isSingleTag)(e) && !(0, Pn.isLineBreakTag)(e) ? !1 : ((0, jn.isElement)(e) && (0, Tn.isNativeInput)(e) ? n = e.value : e.textContent !== null && (n = e.textContent.replace(\"​\", \"\")), t !== void 0 && (n = n.replace(new RegExp(t, \"g\"), \"\")), n.trim().length === 0);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNodeEmpty = void 0;\n  var t = ke;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return t.isNodeEmpty;\n  } });\n})(Oe);\nObject.defineProperty(ye, \"__esModule\", { value: !0 });\nye.isEmpty = $n;\nvar Nn = Ce, An = Oe;\nfunction $n(e, t) {\n  e.normalize();\n  for (var n = [e]; n.length > 0; ) {\n    var r = n.shift();\n    if (r) {\n      if (e = r, (0, Nn.isLeaf)(e) && !(0, An.isNodeEmpty)(e, t))\n        return !1;\n      n.push.apply(n, Array.from(e.childNodes));\n    }\n  }\n  return !0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isEmpty = void 0;\n  var t = ye;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return t.isEmpty;\n  } });\n})(Ze);\nvar xe = {}, _e = {};\nObject.defineProperty(_e, \"__esModule\", { value: !0 });\n_e.isFragment = Wn;\nvar Bn = le;\nfunction Wn(e) {\n  return (0, Bn.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isFragment = void 0;\n  var t = _e;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return t.isFragment;\n  } });\n})(xe);\nvar et = {}, Ee = {};\nObject.defineProperty(Ee, \"__esModule\", { value: !0 });\nEe.isHTMLString = Hn;\nvar Dn = B;\nfunction Hn(e) {\n  var t = (0, Dn.make)(\"div\");\n  return t.innerHTML = e, t.childElementCount > 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isHTMLString = void 0;\n  var t = Ee;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return t.isHTMLString;\n  } });\n})(et);\nvar tt = {}, Ie = {};\nObject.defineProperty(Ie, \"__esModule\", { value: !0 });\nIe.offset = Fn;\nfunction Fn(e) {\n  var t = e.getBoundingClientRect(), n = window.pageXOffset || document.documentElement.scrollLeft, r = window.pageYOffset || document.documentElement.scrollTop, i = t.top + r, a = t.left + n;\n  return {\n    top: i,\n    left: a,\n    bottom: i + t.height,\n    right: a + t.width\n  };\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.offset = void 0;\n  var t = Ie;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return t.offset;\n  } });\n})(tt);\nvar nt = {}, we = {};\nObject.defineProperty(we, \"__esModule\", { value: !0 });\nwe.prepend = Rn;\nfunction Rn(e, t) {\n  Array.isArray(t) ? (t = t.reverse(), t.forEach(function(n) {\n    return e.prepend(n);\n  })) : e.prepend(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = void 0;\n  var t = we;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return t.prepend;\n  } });\n})(nt);\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = e.offset = e.make = e.isLineBreakTag = e.isSingleTag = e.isNodeEmpty = e.isLeaf = e.isHTMLString = e.isFragment = e.isEmpty = e.isElement = e.isContentEditable = e.isCollapsedWhitespaces = e.findAllInputs = e.isNativeInput = e.allInputsSelector = e.getDeepestNode = e.getDeepestBlockElements = e.getContentLength = e.fragmentToString = e.containsOnlyInlineElements = e.canSetCaret = e.calculateBaseline = e.blockElements = e.append = void 0;\n  var t = V;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n  var n = k;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return n.isNativeInput;\n  } });\n  var r = Fe;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return r.append;\n  } });\n  var i = Z;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return i.blockElements;\n  } });\n  var a = Re;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return a.calculateBaseline;\n  } });\n  var l = qe;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return l.canSetCaret;\n  } });\n  var s = $;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return s.containsOnlyInlineElements;\n  } });\n  var o = Ke;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return o.fragmentToString;\n  } });\n  var d = Xe;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return d.getContentLength;\n  } });\n  var u = ce;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return u.getDeepestBlockElements;\n  } });\n  var p = Ve;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return p.getDeepestNode;\n  } });\n  var g = Je;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return g.findAllInputs;\n  } });\n  var w = Qe;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return w.isCollapsedWhitespaces;\n  } });\n  var _ = ne;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return _.isContentEditable;\n  } });\n  var ut = ve;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return ut.isElement;\n  } });\n  var ct = Ze;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return ct.isEmpty;\n  } });\n  var dt = xe;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return dt.isFragment;\n  } });\n  var ft = et;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return ft.isHTMLString;\n  } });\n  var pt = Ce;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return pt.isLeaf;\n  } });\n  var mt = Oe;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return mt.isNodeEmpty;\n  } });\n  var ht = W;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return ht.isLineBreakTag;\n  } });\n  var gt = D;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return gt.isSingleTag;\n  } });\n  var vt = B;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return vt.make;\n  } });\n  var bt = tt;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return bt.offset;\n  } });\n  var yt = nt;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return yt.prepend;\n  } });\n})(c);\nconst h = \"cdx-list\", m = {\n  wrapper: h,\n  item: `${h}__item`,\n  itemContent: `${h}__item-content`,\n  itemChildren: `${h}__item-children`\n};\nclass v {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...m,\n      orderedList: `${h}-ordered`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ol wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ol element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? n = c.make(\"ol\", [v.CSS.wrapper, v.CSS.orderedList]) : n = c.make(\"ol\", [v.CSS.orderedList, v.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param _meta - meta of the list item unused in rendering of the ordered list\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", v.CSS.item), i = c.make(\"div\", v.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    });\n    return r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${v.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Returns item meta, for ordered list\n   * @returns item meta object\n   */\n  getItemMeta() {\n    return {};\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return {};\n  }\n}\nclass b {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...m,\n      unorderedList: `${h}-unordered`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ol wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ul element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? n = c.make(\"ul\", [b.CSS.wrapper, b.CSS.unorderedList]) : n = c.make(\"ul\", [b.CSS.unorderedList, b.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param _meta - meta of the list item unused in rendering of the unordered list\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", b.CSS.item), i = c.make(\"div\", b.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    });\n    return r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${b.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Returns item meta, for unordered list\n   * @returns Item meta object\n   */\n  getItemMeta() {\n    return {};\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return {};\n  }\n}\nfunction O(e) {\n  return e.nodeType === Node.ELEMENT_NODE;\n}\nvar P = {}, Pe = {}, H = {}, F = {};\nObject.defineProperty(F, \"__esModule\", { value: !0 });\nF.getContenteditableSlice = Un;\nvar qn = c;\nfunction Un(e, t, n, r, i) {\n  var a;\n  i === void 0 && (i = !1);\n  var l = document.createRange();\n  if (r === \"left\" ? (l.setStart(e, 0), l.setEnd(t, n)) : (l.setStart(t, n), l.setEnd(e, e.childNodes.length)), i === !0) {\n    var s = l.extractContents();\n    return (0, qn.fragmentToString)(s);\n  }\n  var o = l.cloneContents(), d = document.createElement(\"div\");\n  d.appendChild(o);\n  var u = (a = d.textContent) !== null && a !== void 0 ? a : \"\";\n  return u;\n}\nObject.defineProperty(H, \"__esModule\", { value: !0 });\nH.checkContenteditableSliceForEmptiness = Xn;\nvar zn = c, Kn = F;\nfunction Xn(e, t, n, r) {\n  var i = (0, Kn.getContenteditableSlice)(e, t, n, r);\n  return (0, zn.isCollapsedWhitespaces)(i);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.checkContenteditableSliceForEmptiness = void 0;\n  var t = H;\n  Object.defineProperty(e, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return t.checkContenteditableSliceForEmptiness;\n  } });\n})(Pe);\nvar rt = {};\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getContenteditableSlice = void 0;\n  var t = F;\n  Object.defineProperty(e, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return t.getContenteditableSlice;\n  } });\n})(rt);\nvar it = {}, je = {};\nObject.defineProperty(je, \"__esModule\", { value: !0 });\nje.focus = Vn;\nvar Gn = c;\nfunction Vn(e, t) {\n  var n, r;\n  if (t === void 0 && (t = !0), (0, Gn.isNativeInput)(e)) {\n    e.focus();\n    var i = t ? 0 : e.value.length;\n    e.setSelectionRange(i, i);\n  } else {\n    var a = document.createRange(), l = window.getSelection();\n    if (!l)\n      return;\n    var s = function(g, w) {\n      w === void 0 && (w = !1);\n      var _ = document.createTextNode(\"\");\n      w ? g.insertBefore(_, g.firstChild) : g.appendChild(_), a.setStart(_, 0), a.setEnd(_, 0);\n    }, o = function(g) {\n      return g != null;\n    }, d = e.childNodes, u = t ? d[0] : d[d.length - 1];\n    if (o(u)) {\n      for (; o(u) && u.nodeType !== Node.TEXT_NODE; )\n        u = t ? u.firstChild : u.lastChild;\n      if (o(u) && u.nodeType === Node.TEXT_NODE) {\n        var p = (r = (n = u.textContent) === null || n === void 0 ? void 0 : n.length) !== null && r !== void 0 ? r : 0, i = t ? 0 : p;\n        a.setStart(u, i), a.setEnd(u, i);\n      } else\n        s(e, t);\n    } else\n      s(e);\n    l.removeAllRanges(), l.addRange(a);\n  }\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.focus = void 0;\n  var t = je;\n  Object.defineProperty(e, \"focus\", { enumerable: !0, get: function() {\n    return t.focus;\n  } });\n})(it);\nvar Te = {}, R = {};\nObject.defineProperty(R, \"__esModule\", { value: !0 });\nR.getCaretNodeAndOffset = Yn;\nfunction Yn() {\n  var e = window.getSelection();\n  if (e === null)\n    return [null, 0];\n  var t = e.focusNode, n = e.focusOffset;\n  return t === null ? [null, 0] : (t.nodeType !== Node.TEXT_NODE && t.childNodes.length > 0 && (t.childNodes[n] !== void 0 ? (t = t.childNodes[n], n = 0) : (t = t.childNodes[n - 1], t.textContent !== null && (n = t.textContent.length))), [t, n]);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getCaretNodeAndOffset = void 0;\n  var t = R;\n  Object.defineProperty(e, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return t.getCaretNodeAndOffset;\n  } });\n})(Te);\nvar at = {}, q = {};\nObject.defineProperty(q, \"__esModule\", { value: !0 });\nq.getRange = Jn;\nfunction Jn() {\n  var e = window.getSelection();\n  return e && e.rangeCount ? e.getRangeAt(0) : null;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getRange = void 0;\n  var t = q;\n  Object.defineProperty(e, \"getRange\", { enumerable: !0, get: function() {\n    return t.getRange;\n  } });\n})(at);\nvar lt = {}, Le = {};\nObject.defineProperty(Le, \"__esModule\", { value: !0 });\nLe.isCaretAtEndOfInput = xn;\nvar De = c, Qn = Te, Zn = Pe;\nfunction xn(e) {\n  var t = (0, De.getDeepestNode)(e, !0);\n  if (t === null)\n    return !0;\n  if ((0, De.isNativeInput)(t))\n    return t.selectionEnd === t.value.length;\n  var n = (0, Qn.getCaretNodeAndOffset)(), r = n[0], i = n[1];\n  return r === null ? !1 : (0, Zn.checkContenteditableSliceForEmptiness)(e, r, i, \"right\");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCaretAtEndOfInput = void 0;\n  var t = Le;\n  Object.defineProperty(e, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return t.isCaretAtEndOfInput;\n  } });\n})(lt);\nvar st = {}, Me = {};\nObject.defineProperty(Me, \"__esModule\", { value: !0 });\nMe.isCaretAtStartOfInput = nr;\nvar T = c, er = R, tr = H;\nfunction nr(e) {\n  var t = (0, T.getDeepestNode)(e);\n  if (t === null || (0, T.isEmpty)(e))\n    return !0;\n  if ((0, T.isNativeInput)(t))\n    return t.selectionEnd === 0;\n  if ((0, T.isEmpty)(e))\n    return !0;\n  var n = (0, er.getCaretNodeAndOffset)(), r = n[0], i = n[1];\n  return r === null ? !1 : (0, tr.checkContenteditableSliceForEmptiness)(e, r, i, \"left\");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCaretAtStartOfInput = void 0;\n  var t = Me;\n  Object.defineProperty(e, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return t.isCaretAtStartOfInput;\n  } });\n})(st);\nvar ot = {}, Ne = {};\nObject.defineProperty(Ne, \"__esModule\", { value: !0 });\nNe.save = ar;\nvar rr = c, ir = q;\nfunction ar() {\n  var e = (0, ir.getRange)(), t = (0, rr.make)(\"span\");\n  if (t.id = \"cursor\", t.hidden = !0, !!e)\n    return e.insertNode(t), function() {\n      var r = window.getSelection();\n      r && (e.setStartAfter(t), e.setEndAfter(t), r.removeAllRanges(), r.addRange(e), setTimeout(function() {\n        t.remove();\n      }, 150));\n    };\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.save = void 0;\n  var t = Ne;\n  Object.defineProperty(e, \"save\", { enumerable: !0, get: function() {\n    return t.save;\n  } });\n})(ot);\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.save = e.isCaretAtStartOfInput = e.isCaretAtEndOfInput = e.getRange = e.getCaretNodeAndOffset = e.focus = e.getContenteditableSlice = e.checkContenteditableSliceForEmptiness = void 0;\n  var t = Pe;\n  Object.defineProperty(e, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return t.checkContenteditableSliceForEmptiness;\n  } });\n  var n = rt;\n  Object.defineProperty(e, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return n.getContenteditableSlice;\n  } });\n  var r = it;\n  Object.defineProperty(e, \"focus\", { enumerable: !0, get: function() {\n    return r.focus;\n  } });\n  var i = Te;\n  Object.defineProperty(e, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return i.getCaretNodeAndOffset;\n  } });\n  var a = at;\n  Object.defineProperty(e, \"getRange\", { enumerable: !0, get: function() {\n    return a.getRange;\n  } });\n  var l = lt;\n  Object.defineProperty(e, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return l.isCaretAtEndOfInput;\n  } });\n  var s = st;\n  Object.defineProperty(e, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return s.isCaretAtStartOfInput;\n  } });\n  var o = ot;\n  Object.defineProperty(e, \"save\", { enumerable: !0, get: function() {\n    return o.save;\n  } });\n})(P);\nclass f {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...m,\n      checklist: `${h}-checklist`,\n      itemChecked: `${h}__checkbox--checked`,\n      noHover: `${h}__checkbox--no-hover`,\n      checkbox: `${h}__checkbox-check`,\n      checkboxContainer: `${h}__checkbox`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ul wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ul element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? (n = c.make(\"ul\", [f.CSS.wrapper, f.CSS.checklist]), n.addEventListener(\"click\", (r) => {\n      const i = r.target;\n      if (i) {\n        const a = i.closest(`.${f.CSS.checkboxContainer}`);\n        a && a.contains(i) && this.toggleCheckbox(a);\n      }\n    })) : n = c.make(\"ul\", [f.CSS.checklist, f.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param meta - meta of the list item used in rendering of the checklist\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", [f.CSS.item, f.CSS.item]), i = c.make(\"div\", f.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    }), a = c.make(\"span\", f.CSS.checkbox), l = c.make(\"div\", f.CSS.checkboxContainer);\n    return n.checked === !0 && l.classList.add(f.CSS.itemChecked), a.innerHTML = Ct, l.appendChild(a), r.appendChild(l), r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${f.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Return meta object of certain element\n   * @param item - will be returned meta information of this item\n   * @returns Item meta object\n   */\n  getItemMeta(t) {\n    const n = t.querySelector(`.${f.CSS.checkboxContainer}`);\n    return {\n      checked: n ? n.classList.contains(f.CSS.itemChecked) : !1\n    };\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return { checked: !1 };\n  }\n  /**\n   * Toggle checklist item state\n   * @param checkbox - checkbox element to be toggled\n   */\n  toggleCheckbox(t) {\n    t.classList.toggle(f.CSS.itemChecked), t.classList.add(f.CSS.noHover), t.addEventListener(\"mouseleave\", () => this.removeSpecialHoverBehavior(t), { once: !0 });\n  }\n  /**\n   * Removes class responsible for special hover behavior on an item\n   * @param el - item wrapper\n   */\n  removeSpecialHoverBehavior(t) {\n    t.classList.remove(f.CSS.noHover);\n  }\n}\nfunction U(e, t = \"after\") {\n  const n = [];\n  let r;\n  function i(a) {\n    switch (t) {\n      case \"after\":\n        return a.nextElementSibling;\n      case \"before\":\n        return a.previousElementSibling;\n    }\n  }\n  for (r = i(e); r !== null; )\n    n.push(r), r = i(r);\n  return n.length !== 0 ? n : null;\n}\nfunction y(e, t = !0) {\n  let n = e;\n  return e.classList.contains(m.item) && (n = e.querySelector(`.${m.itemChildren}`)), n === null ? [] : t ? Array.from(n.querySelectorAll(`:scope > .${m.item}`)) : Array.from(n.querySelectorAll(`.${m.item}`));\n}\nfunction lr(e) {\n  return e.nextElementSibling === null;\n}\nfunction sr(e) {\n  return e.querySelector(`.${m.itemChildren}`) !== null;\n}\nfunction C(e) {\n  return e.querySelector(`.${m.itemChildren}`);\n}\nfunction z(e) {\n  let t = e;\n  e.classList.contains(m.item) && (t = C(e)), t !== null && y(t).length === 0 && t.remove();\n}\nfunction N(e) {\n  return e.querySelector(`.${m.itemContent}`);\n}\nfunction E(e, t = !0) {\n  const n = N(e);\n  n && P.focus(n, t);\n}\nclass K {\n  /**\n   * Getter method to get current item\n   * @returns current list item or null if caret position is not undefined\n   */\n  get currentItem() {\n    const t = window.getSelection();\n    if (!t)\n      return null;\n    let n = t.anchorNode;\n    return !n || (O(n) || (n = n.parentNode), !n) || !O(n) ? null : n.closest(`.${m.item}`);\n  }\n  /**\n   * Method that returns nesting level of the current item, null if there is no selection\n   */\n  get currentItemLevel() {\n    const t = this.currentItem;\n    if (t === null)\n      return null;\n    let n = t.parentNode, r = 0;\n    for (; n !== null && n !== this.listWrapper; )\n      O(n) && n.classList.contains(m.item) && (r += 1), n = n.parentNode;\n    return r + 1;\n  }\n  /**\n   * Assign all passed params and renderer to relevant class properties\n   * @param params - tool constructor options\n   * @param params.data - previously saved data\n   * @param params.config - user config for Tool\n   * @param params.api - Editor.js API\n   * @param params.readOnly - read-only mode flag\n   * @param renderer - renderer instance initialized in tool class\n   */\n  constructor({ data: t, config: n, api: r, readOnly: i, block: a }, l) {\n    this.config = n, this.data = t, this.readOnly = i, this.api = r, this.block = a, this.renderer = l;\n  }\n  /**\n   * Function that is responsible for rendering list with contents\n   * @returns Filled with content wrapper element of the list\n   */\n  render() {\n    return this.listWrapper = this.renderer.renderWrapper(!0), this.data.items.length ? this.appendItems(this.data.items, this.listWrapper) : this.appendItems(\n      [\n        {\n          content: \"\",\n          meta: {},\n          items: []\n        }\n      ],\n      this.listWrapper\n    ), this.readOnly || this.listWrapper.addEventListener(\n      \"keydown\",\n      (t) => {\n        switch (t.key) {\n          case \"Enter\":\n            this.enterPressed(t);\n            break;\n          case \"Backspace\":\n            this.backspace(t);\n            break;\n          case \"Tab\":\n            t.shiftKey ? this.shiftTab(t) : this.addTab(t);\n            break;\n        }\n      },\n      !1\n    ), \"start\" in this.data.meta && this.data.meta.start !== void 0 && this.changeStartWith(this.data.meta.start), \"counterType\" in this.data.meta && this.data.meta.counterType !== void 0 && this.changeCounters(this.data.meta.counterType), this.listWrapper;\n  }\n  /**\n   * Function that is responsible for list content saving\n   * @param wrapper - optional argument wrapper\n   * @returns whole list saved data if wrapper not passes, otherwise will return data of the passed wrapper\n   */\n  save(t) {\n    const n = t ?? this.listWrapper, r = (l) => y(l).map((o) => {\n      const d = C(o), u = this.renderer.getItemContent(o), p = this.renderer.getItemMeta(o), g = d ? r(d) : [];\n      return {\n        content: u,\n        meta: p,\n        items: g\n      };\n    }), i = n ? r(n) : [];\n    let a = {\n      style: this.data.style,\n      meta: {},\n      items: i\n    };\n    return this.data.style === \"ordered\" && (a.meta = {\n      start: this.data.meta.start,\n      counterType: this.data.meta.counterType\n    }), a;\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   * @returns - config that determines tags supposted by paste handler\n   * @todo - refactor and move to list instance\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * Method that specified hot to merge two List blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * Content of the first item of the next List would be merged with deepest item in current list\n   * Other items of the next List would be appended to the current list without any changes in nesting levels\n   * @param data - data of the second list to be merged with current\n   */\n  merge(t) {\n    const n = this.block.holder.querySelectorAll(`.${m.item}`), r = n[n.length - 1], i = N(r);\n    if (r === null || i === null || (i.insertAdjacentHTML(\"beforeend\", t.items[0].content), this.listWrapper === void 0))\n      return;\n    const a = y(this.listWrapper);\n    if (a.length === 0)\n      return;\n    const l = a[a.length - 1];\n    let s = C(l);\n    const o = t.items.shift();\n    o !== void 0 && (o.items.length !== 0 && (s === null && (s = this.renderer.renderWrapper(!1)), this.appendItems(o.items, s)), t.items.length > 0 && this.appendItems(t.items, this.listWrapper));\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   * @param event - event with pasted data\n   * @todo - refactor and move to list instance\n   */\n  onPaste(t) {\n    const n = t.detail.data;\n    this.data = this.pasteHandler(n);\n    const r = this.listWrapper;\n    r && r.parentNode && r.parentNode.replaceChild(this.render(), r);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   * @param element - html element that contains whole list\n   * @todo - refactor and move to list instance\n   */\n  pasteHandler(t) {\n    const { tagName: n } = t;\n    let r = \"unordered\", i;\n    switch (n) {\n      case \"OL\":\n        r = \"ordered\", i = \"ol\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        r = \"unordered\", i = \"ul\";\n    }\n    const a = {\n      style: r,\n      meta: {},\n      items: []\n    };\n    r === \"ordered\" && (this.data.meta.counterType = \"numeric\", this.data.meta.start = 1);\n    const l = (s) => Array.from(s.querySelectorAll(\":scope > li\")).map((d) => {\n      const u = d.querySelector(`:scope > ${i}`), p = u ? l(u) : [];\n      return {\n        content: d.innerHTML ?? \"\",\n        meta: {},\n        items: p\n      };\n    });\n    return a.items = l(t), a;\n  }\n  /**\n   * Changes ordered list start property value\n   * @param index - new value of the start property\n   */\n  changeStartWith(t) {\n    this.listWrapper.style.setProperty(\"counter-reset\", `item ${t - 1}`), this.data.meta.start = t;\n  }\n  /**\n   * Changes ordered list counterType property value\n   * @param counterType - new value of the counterType value\n   */\n  changeCounters(t) {\n    this.listWrapper.style.setProperty(\"--list-counter-type\", t), this.data.meta.counterType = t;\n  }\n  /**\n   * Handles Enter keypress\n   * @param event - keydown\n   */\n  enterPressed(t) {\n    var s;\n    const n = this.currentItem;\n    if (t.stopPropagation(), t.preventDefault(), t.isComposing || n === null)\n      return;\n    const r = ((s = this.renderer) == null ? void 0 : s.getItemContent(n).trim().length) === 0, i = n.parentNode === this.listWrapper, a = n.previousElementSibling === null, l = this.api.blocks.getCurrentBlockIndex();\n    if (i && r)\n      if (lr(n) && !sr(n)) {\n        a ? this.convertItemToDefaultBlock(l, !0) : this.convertItemToDefaultBlock();\n        return;\n      } else {\n        this.splitList(n);\n        return;\n      }\n    else if (r) {\n      this.unshiftItem(n);\n      return;\n    } else\n      this.splitItem(n);\n  }\n  /**\n   * Handle backspace\n   * @param event - keydown\n   */\n  backspace(t) {\n    var r;\n    const n = this.currentItem;\n    if (n !== null && P.isCaretAtStartOfInput(n) && ((r = window.getSelection()) == null ? void 0 : r.isCollapsed) !== !1) {\n      if (t.stopPropagation(), n.parentNode === this.listWrapper && n.previousElementSibling === null) {\n        this.convertFirstItemToDefaultBlock();\n        return;\n      }\n      t.preventDefault(), this.mergeItemWithPrevious(n);\n    }\n  }\n  /**\n   * Reduce indentation for current item\n   * @param event - keydown\n   */\n  shiftTab(t) {\n    t.stopPropagation(), t.preventDefault(), this.currentItem !== null && this.unshiftItem(this.currentItem);\n  }\n  /**\n   * Decrease indentation of the passed item\n   * @param item - list item to be unshifted\n   */\n  unshiftItem(t) {\n    if (!t.parentNode || !O(t.parentNode))\n      return;\n    const n = t.parentNode.closest(`.${m.item}`);\n    if (!n)\n      return;\n    let r = C(t);\n    if (t.parentElement === null)\n      return;\n    const i = U(t);\n    i !== null && (r === null && (r = this.renderer.renderWrapper(!1)), i.forEach((a) => {\n      r.appendChild(a);\n    }), t.appendChild(r)), n.after(t), E(t, !1), z(n);\n  }\n  /**\n   * Method that is used for list splitting and moving trailing items to the new separated list\n   * @param item - current item html element\n   */\n  splitList(t) {\n    const n = y(t), r = this.block, i = this.api.blocks.getCurrentBlockIndex();\n    if (n.length !== 0) {\n      const o = n[0];\n      this.unshiftItem(o), E(t, !1);\n    }\n    if (t.previousElementSibling === null && t.parentNode === this.listWrapper) {\n      this.convertItemToDefaultBlock(i);\n      return;\n    }\n    const a = U(t);\n    if (a === null)\n      return;\n    const l = this.renderer.renderWrapper(!0);\n    a.forEach((o) => {\n      l.appendChild(o);\n    });\n    const s = this.save(l);\n    s.meta.start = this.data.style == \"ordered\" ? 1 : void 0, this.api.blocks.insert(r == null ? void 0 : r.name, s, this.config, i + 1), this.convertItemToDefaultBlock(i + 1), l.remove();\n  }\n  /**\n   * Method that is used for splitting item content and moving trailing content to the new sibling item\n   * @param currentItem - current item html element\n   */\n  splitItem(t) {\n    const [n, r] = P.getCaretNodeAndOffset();\n    if (n === null)\n      return;\n    const i = N(t);\n    let a;\n    i === null ? a = \"\" : a = P.getContenteditableSlice(i, n, r, \"right\", !0);\n    const l = C(t), s = this.renderItem(a);\n    t == null || t.after(s), l && s.appendChild(l), E(s);\n  }\n  /**\n   * Method that is used for merging current item with previous one\n   * Content of the current item would be appended to the previous item\n   * Current item children would not change nesting level\n   * @param item - current item html element\n   */\n  mergeItemWithPrevious(t) {\n    const n = t.previousElementSibling, r = t.parentNode;\n    if (r === null || !O(r))\n      return;\n    const i = r.closest(`.${m.item}`);\n    if (!n && !i || n && !O(n))\n      return;\n    let a;\n    if (n) {\n      const p = y(n, !1);\n      p.length !== 0 && p.length !== 0 ? a = p[p.length - 1] : a = n;\n    } else\n      a = i;\n    const l = this.renderer.getItemContent(t);\n    if (!a)\n      return;\n    E(a, !1);\n    const s = N(a);\n    if (s === null)\n      return;\n    s.insertAdjacentHTML(\"beforeend\", l);\n    const o = y(t);\n    if (o.length === 0) {\n      t.remove(), z(a);\n      return;\n    }\n    const d = n || i, u = C(d) ?? this.renderer.renderWrapper(!1);\n    n ? o.forEach((p) => {\n      u.appendChild(p);\n    }) : o.forEach((p) => {\n      u.prepend(p);\n    }), C(d) === null && a.appendChild(u), t.remove();\n  }\n  /**\n   * Add indentation to current item\n   * @param event - keydown\n   */\n  addTab(t) {\n    var a;\n    t.stopPropagation(), t.preventDefault();\n    const n = this.currentItem;\n    if (!n)\n      return;\n    if (((a = this.config) == null ? void 0 : a.maxLevel) !== void 0) {\n      const l = this.currentItemLevel;\n      if (l !== null && l === this.config.maxLevel)\n        return;\n    }\n    const r = n.previousSibling;\n    if (r === null || !O(r))\n      return;\n    const i = C(r);\n    if (i)\n      i.appendChild(n), y(n).forEach((s) => {\n        i.appendChild(s);\n      });\n    else {\n      const l = this.renderer.renderWrapper(!1);\n      l.appendChild(n), y(n).forEach((o) => {\n        l.appendChild(o);\n      }), r.appendChild(l);\n    }\n    z(n), E(n, !1);\n  }\n  /**\n   * Convert current item to default block with passed index\n   * @param newBloxkIndex - optional parameter represents index, where would be inseted default block\n   * @param removeList - optional parameter, that represents condition, if List should be removed\n   */\n  convertItemToDefaultBlock(t, n) {\n    let r;\n    const i = this.currentItem, a = i !== null ? this.renderer.getItemContent(i) : \"\";\n    n === !0 && this.api.blocks.delete(), t !== void 0 ? r = this.api.blocks.insert(void 0, { text: a }, void 0, t) : r = this.api.blocks.insert(), i == null || i.remove(), this.api.caret.setToBlock(r, \"start\");\n  }\n  /**\n   * Convert first item of the list to default block\n   * This method could be called when backspace button pressed at start of the first item of the list\n   * First item of the list would be converted to the paragraph and first item children would be unshifted\n   */\n  convertFirstItemToDefaultBlock() {\n    const t = this.currentItem;\n    if (t === null)\n      return;\n    const n = y(t);\n    if (n.length !== 0) {\n      const l = n[0];\n      this.unshiftItem(l), E(t);\n    }\n    const r = U(t), i = this.api.blocks.getCurrentBlockIndex(), a = r === null;\n    this.convertItemToDefaultBlock(i, a);\n  }\n  /**\n   * Method that calls render function of the renderer with a necessary item meta cast\n   * @param itemContent - content to be rendered in new item\n   * @param meta - meta used in list item rendering\n   * @returns html element of the rendered item\n   */\n  renderItem(t, n) {\n    const r = n ?? this.renderer.composeDefaultMeta();\n    switch (!0) {\n      case this.renderer instanceof v:\n        return this.renderer.renderItem(t, r);\n      case this.renderer instanceof b:\n        return this.renderer.renderItem(t, r);\n      default:\n        return this.renderer.renderItem(t, r);\n    }\n  }\n  /**\n   * Renders children list\n   * @param items - list data used in item rendering\n   * @param parentElement - where to append passed items\n   */\n  appendItems(t, n) {\n    t.forEach((r) => {\n      var a;\n      const i = this.renderItem(r.content, r.meta);\n      if (n.appendChild(i), r.items.length) {\n        const l = (a = this.renderer) == null ? void 0 : a.renderWrapper(!1);\n        this.appendItems(r.items, l), i.appendChild(l);\n      }\n    });\n  }\n}\nconst I = {\n  wrapper: `${h}-start-with-field`,\n  input: `${h}-start-with-field__input`,\n  startWithElementWrapperInvalid: `${h}-start-with-field--invalid`\n};\nfunction or(e, { value: t, placeholder: n, attributes: r, sanitize: i }) {\n  const a = c.make(\"div\", I.wrapper), l = c.make(\"input\", I.input, {\n    placeholder: n,\n    /**\n     * Used to prevent focusing on the input by Tab key\n     * (Popover in the Toolbar lays below the blocks,\n     * so Tab in the last block will focus this hidden input if this property is not set)\n     */\n    tabIndex: -1,\n    /**\n     * Value of the start property, if it is not specified, then it is set to one\n     */\n    value: t\n  });\n  for (const s in r)\n    l.setAttribute(s, r[s]);\n  return a.appendChild(l), l.addEventListener(\"input\", () => {\n    i !== void 0 && (l.value = i(l.value));\n    const s = l.checkValidity();\n    !s && !a.classList.contains(I.startWithElementWrapperInvalid) && a.classList.add(I.startWithElementWrapperInvalid), s && a.classList.contains(I.startWithElementWrapperInvalid) && a.classList.remove(I.startWithElementWrapperInvalid), s && e(l.value);\n  }), a;\n}\nconst L = /* @__PURE__ */ new Map([\n  /**\n   * Value that represents default arabic numbers for counters\n   */\n  [\"Numeric\", \"numeric\"],\n  /**\n   * Value that represents lower roman numbers for counteres\n   */\n  [\"Lower Roman\", \"lower-roman\"],\n  /**\n   * Value that represents upper roman numbers for counters\n   */\n  [\"Upper Roman\", \"upper-roman\"],\n  /**\n   * Value that represents lower alpha characters for counters\n   */\n  [\"Lower Alpha\", \"lower-alpha\"],\n  /**\n   * Value that represents upper alpha characters for counters\n   */\n  [\"Upper Alpha\", \"upper-alpha\"]\n]), He = /* @__PURE__ */ new Map([\n  /**\n   * Value that represents Icon for Numeric counter type\n   */\n  [\"numeric\", St],\n  /**\n   * Value that represents Icon for Lower Roman counter type\n   */\n  [\"lower-roman\", Ot],\n  /**\n   * Value that represents Icon for Upper Roman counter type\n   */\n  [\"upper-roman\", kt],\n  /**\n   * Value that represents Icon for Lower Alpha counter type\n   */\n  [\"lower-alpha\", Et],\n  /**\n   * Value that represents Icon for Upper Alpha counter type\n   */\n  [\"upper-alpha\", _t]\n]);\nfunction ur(e) {\n  return e.replace(/\\D+/g, \"\");\n}\nfunction cr(e) {\n  return typeof e.items[0] == \"string\";\n}\nfunction dr(e) {\n  return !(\"meta\" in e);\n}\nfunction fr(e) {\n  return typeof e.items[0] != \"string\" && \"text\" in e.items[0] && \"checked\" in e.items[0] && typeof e.items[0].text == \"string\" && typeof e.items[0].checked == \"boolean\";\n}\nfunction pr(e) {\n  const t = [];\n  return cr(e) ? (e.items.forEach((n) => {\n    t.push({\n      content: n,\n      meta: {},\n      items: []\n    });\n  }), {\n    style: e.style,\n    meta: {},\n    items: t\n  }) : fr(e) ? (e.items.forEach((n) => {\n    t.push({\n      content: n.text,\n      meta: {\n        checked: n.checked\n      },\n      items: []\n    });\n  }), {\n    style: \"checklist\",\n    meta: {},\n    items: t\n  }) : dr(e) ? {\n    style: e.style,\n    meta: {},\n    items: e.items\n  } : e;\n}\nclass G {\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to use native Enter behaviour\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   */\n  static get toolbox() {\n    return [\n      {\n        icon: $e,\n        title: \"Unordered List\",\n        data: {\n          style: \"unordered\"\n        }\n      },\n      {\n        icon: Be,\n        title: \"Ordered List\",\n        data: {\n          style: \"ordered\"\n        }\n      },\n      {\n        icon: Ae,\n        title: \"Checklist\",\n        data: {\n          style: \"checklist\"\n        }\n      }\n    ];\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   * @returns - paste config object used in editor\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * Convert from text to list with import and export list to text\n   */\n  static get conversionConfig() {\n    return {\n      export: (t) => G.joinRecursive(t),\n      import: (t, n) => ({\n        meta: {},\n        items: [\n          {\n            content: t,\n            meta: {},\n            items: []\n          }\n        ],\n        style: (n == null ? void 0 : n.defaultStyle) !== void 0 ? n.defaultStyle : \"unordered\"\n      })\n    };\n  }\n  /**\n   * Get list style name\n   */\n  get listStyle() {\n    return this.data.style || this.defaultListStyle;\n  }\n  /**\n   * Set list style\n   * @param style - new style to set\n   */\n  set listStyle(t) {\n    var r;\n    this.data.style = t, this.changeTabulatorByStyle();\n    const n = this.list.render();\n    (r = this.listElement) == null || r.replaceWith(n), this.listElement = n;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   * @param params - tool constructor options\n   * @param params.data - previously saved data\n   * @param params.config - user config for Tool\n   * @param params.api - Editor.js API\n   * @param params.readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: n, api: r, readOnly: i, block: a }) {\n    var s;\n    this.api = r, this.readOnly = i, this.config = n, this.block = a, this.defaultListStyle = ((s = this.config) == null ? void 0 : s.defaultStyle) || \"unordered\";\n    const l = {\n      style: this.defaultListStyle,\n      meta: {},\n      items: []\n    };\n    this.data = Object.keys(t).length ? pr(t) : l, this.listStyle === \"ordered\" && this.data.meta.counterType === void 0 && (this.data.meta.counterType = \"numeric\"), this.changeTabulatorByStyle();\n  }\n  /**\n   * Convert from list to text for conversionConfig\n   * @param data - current data of the list\n   * @returns - string of the recursively merged contents of the items of the list\n   */\n  static joinRecursive(t) {\n    return t.items.map((n) => `${n.content} ${G.joinRecursive(n)}`).join(\"\");\n  }\n  /**\n   * Function that is responsible for content rendering\n   * @returns rendered list wrapper with all contents\n   */\n  render() {\n    return this.listElement = this.list.render(), this.listElement;\n  }\n  /**\n   * Function that is responsible for content saving\n   * @returns formatted content used in editor\n   */\n  save() {\n    return this.data = this.list.save(), this.data;\n  }\n  /**\n   * Function that is responsible for mergind two lists into one\n   * @param data - data of the next standing list, that should be merged with current\n   */\n  merge(t) {\n    this.list.merge(t);\n  }\n  /**\n   * Creates Block Tune allowing to change the list style\n   * @returns array of tune configs\n   */\n  renderSettings() {\n    const t = [\n      {\n        label: this.api.i18n.t(\"Unordered\"),\n        icon: $e,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"unordered\",\n        onActivate: () => {\n          this.listStyle = \"unordered\";\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Ordered\"),\n        icon: Be,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"ordered\",\n        onActivate: () => {\n          this.listStyle = \"ordered\";\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Checklist\"),\n        icon: Ae,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"checklist\",\n        onActivate: () => {\n          this.listStyle = \"checklist\";\n        }\n      }\n    ];\n    if (this.listStyle === \"ordered\") {\n      const n = or(\n        (a) => this.changeStartWith(Number(a)),\n        {\n          value: String(this.data.meta.start ?? 1),\n          placeholder: \"\",\n          attributes: {\n            required: \"true\"\n          },\n          sanitize: (a) => ur(a)\n        }\n      ), r = [\n        {\n          label: this.api.i18n.t(\"Start with\"),\n          icon: It,\n          children: {\n            items: [\n              {\n                element: n,\n                // @ts-expect-error ts(2820) can not use PopoverItem enum from editor.js types\n                type: \"html\"\n              }\n            ]\n          }\n        }\n      ], i = {\n        label: this.api.i18n.t(\"Counter type\"),\n        icon: He.get(this.data.meta.counterType),\n        children: {\n          items: []\n        }\n      };\n      L.forEach((a, l) => {\n        i.children.items.push({\n          title: this.api.i18n.t(l),\n          icon: He.get(L.get(l)),\n          isActive: this.data.meta.counterType === L.get(l),\n          closeOnActivate: !0,\n          onActivate: () => {\n            this.changeCounters(L.get(l));\n          }\n        });\n      }), t.push({ type: \"separator\" }, ...r, i);\n    }\n    return t;\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   * @param event - event with pasted data\n   */\n  onPaste(t) {\n    const { tagName: n } = t.detail.data;\n    switch (n) {\n      case \"OL\":\n        this.listStyle = \"ordered\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        this.listStyle = \"unordered\";\n    }\n    this.list.onPaste(t);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   * @param element - html element that contains whole list\n   */\n  pasteHandler(t) {\n    return this.list.pasteHandler(t);\n  }\n  /**\n   * Changes ordered list counterType property value\n   * @param counterType - new value of the counterType value\n   */\n  changeCounters(t) {\n    var n;\n    (n = this.list) == null || n.changeCounters(t), this.data.meta.counterType = t;\n  }\n  /**\n   * Changes ordered list start property value\n   * @param index - new value of the start property\n   */\n  changeStartWith(t) {\n    var n;\n    (n = this.list) == null || n.changeStartWith(t), this.data.meta.start = t;\n  }\n  /**\n   * This method allows changing tabulator respectfully to passed style\n   */\n  changeTabulatorByStyle() {\n    switch (this.listStyle) {\n      case \"ordered\":\n        this.list = new K(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new v(this.readOnly, this.config)\n        );\n        break;\n      case \"unordered\":\n        this.list = new K(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new b(this.readOnly, this.config)\n        );\n        break;\n      case \"checklist\":\n        this.list = new K(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new f(this.readOnly, this.config)\n        );\n        break;\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2xpc3QvZGlzdC9lZGl0b3Jqcy1saXN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxpREFBaUQsU0FBUyxVQUFVLGFBQWEsYUFBYSxtQkFBbUIscUJBQXFCLDBCQUEwQixpQkFBaUIsa0JBQWtCLDZCQUE2QixxQkFBcUIsNEJBQTRCLHdCQUF3Qiw0QkFBNEIsc0JBQXNCLGtDQUFrQyxtQkFBbUIsdUJBQXVCLGdCQUFnQiwrQkFBK0IsYUFBYSwrQkFBK0IsNkJBQTZCLGlEQUFpRCx5QkFBeUIsYUFBYSxnQkFBZ0IscUJBQXFCLDZCQUE2QixrQ0FBa0MsYUFBYSx3QkFBd0Isc0JBQXNCLHFCQUFxQixrQkFBa0IsOEJBQThCLHVCQUF1Qix1QkFBdUIsbUJBQW1CLHlDQUF5Qyx3REFBd0Qsa0JBQWtCLG1CQUFtQiwyQ0FBMkMsWUFBWSwyQ0FBMkMsV0FBVyx5Q0FBeUMsVUFBVSxvQkFBb0Isa0VBQWtFLG1CQUFtQiwyQkFBMkIsNEJBQTRCLGFBQWEsZUFBZSx3QkFBd0IsVUFBVSw0QkFBNEIsMkJBQTJCLFVBQVUsU0FBUyxrQkFBa0Isc0JBQXNCLDJGQUEyRixXQUFXLDZCQUE2QiwrQkFBK0Isc0JBQXNCLDhHQUE4Ryx5Q0FBeUMsNENBQTRDLHVEQUF1RCxtQ0FBbUMscUNBQXFDLDJEQUEyRCxVQUFVLGdFQUFnRSx5QkFBeUIsOERBQThELFVBQVUsbUJBQW1CLHFCQUFxQiwwQkFBMEIsZUFBZSxxQkFBcUIsa0JBQWtCLGNBQWMsMkJBQTJCLDRCQUE0QixzQkFBc0IsbUNBQW1DLHFDQUFxQyxzQ0FBc0MsaUNBQWlDLFdBQVcsa0JBQWtCLE1BQU0sUUFBUSxTQUFTLE9BQU8sbUJBQW1CLHlDQUF5QyxrQkFBa0Isb0JBQW9CLG1CQUFtQiw4Q0FBOEMsMkJBQTJCLG1CQUFtQixzQ0FBc0Msa0JBQWtCLFlBQVksYUFBYSxvQ0FBb0Msd0JBQXdCLG9DQUFvQyxtQkFB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LFdBQVc7QUFDdEQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixrQkFBa0IsRUFBRTtBQUNwQixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxRQUFRO0FBQzNCLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEIsc0JBQXNCLEVBQUU7QUFDeEIsa0JBQWtCLEVBQUU7QUFDcEIsbUJBQW1CLEVBQUU7QUFDckIsNEJBQTRCLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLFVBQVU7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsZUFBZSxzRUFBc0UsT0FBTyx3Q0FBd0MsT0FBTztBQUM3TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixPQUFPO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2xpc3QvZGlzdC9lZGl0b3Jqcy1saXN0Lm1qcz8yZWY0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuY2R4LWxpc3R7bWFyZ2luOjA7cGFkZGluZzowO291dGxpbmU6bm9uZTtkaXNwbGF5OmdyaWQ7Y291bnRlci1yZXNldDppdGVtO2dhcDp2YXIoLS1zcGFjaW5nLXMpO3BhZGRpbmc6dmFyKC0tc3BhY2luZy14cyk7LS1zcGFjaW5nLXM6IDhweDstLXNwYWNpbmcteHM6IDZweDstLWxpc3QtY291bnRlci10eXBlOiBudW1lcmljOy0tcmFkaXVzLWJvcmRlcjogNXB4Oy0tY2hlY2tib3gtYmFja2dyb3VuZDogI2ZmZjstLWNvbG9yLWJvcmRlcjogI0M5QzlDOTstLWNvbG9yLWJnLWNoZWNrZWQ6ICMzNjlGRkY7LS1saW5lLWhlaWdodDogMS40NWVtOy0tY29sb3ItYmctY2hlY2tlZC1ob3ZlcjogIzAwNTlBQjstLWNvbG9yLXRpY2s6ICNmZmY7LS1zaXplLWNoZWNrYm94OiAxLjJlbX0uY2R4LWxpc3RfX2l0ZW17bGluZS1oZWlnaHQ6dmFyKC0tbGluZS1oZWlnaHQpO2Rpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byAxZnI7Z3JpZC10ZW1wbGF0ZS1yb3dzOmF1dG8gYXV0bztncmlkLXRlbXBsYXRlLWFyZWFzOlwiY2hlY2tib3ggY29udGVudFwiIFwiLiBjaGlsZFwifS5jZHgtbGlzdF9faXRlbS1jaGlsZHJlbntkaXNwbGF5OmdyaWQ7Z3JpZC1hcmVhOmNoaWxkO2dhcDp2YXIoLS1zcGFjaW5nLXMpO3BhZGRpbmctdG9wOnZhcigtLXNwYWNpbmctcyl9LmNkeC1saXN0X19pdGVtIFtjb250ZW50ZWRpdGFibGVde291dGxpbmU6bm9uZX0uY2R4LWxpc3RfX2l0ZW0tY29udGVudHt3b3JkLWJyZWFrOmJyZWFrLXdvcmQ7d2hpdGUtc3BhY2U6cHJlLXdyYXA7Z3JpZC1hcmVhOmNvbnRlbnQ7cGFkZGluZy1sZWZ0OnZhcigtLXNwYWNpbmctcyl9LmNkeC1saXN0X19pdGVtOmJlZm9yZXtjb3VudGVyLWluY3JlbWVudDppdGVtO3doaXRlLXNwYWNlOm5vd3JhcH0uY2R4LWxpc3Qtb3JkZXJlZCAuY2R4LWxpc3RfX2l0ZW06YmVmb3Jle2NvbnRlbnQ6Y291bnRlcnMoaXRlbSxcIi5cIix2YXIoLS1saXN0LWNvdW50ZXItdHlwZSkpIFwiLlwifS5jZHgtbGlzdC1vcmRlcmVke2NvdW50ZXItcmVzZXQ6aXRlbX0uY2R4LWxpc3QtdW5vcmRlcmVkIC5jZHgtbGlzdF9faXRlbTpiZWZvcmV7Y29udGVudDpcIuKAolwifS5jZHgtbGlzdC1jaGVja2xpc3QgLmNkeC1saXN0X19pdGVtOmJlZm9yZXtjb250ZW50OlwiXCJ9LmNkeC1saXN0X19zZXR0aW5ncyAuY2R4LXNldHRpbmdzLWJ1dHRvbnt3aWR0aDo1MCV9LmNkeC1saXN0X19jaGVja2JveHtwYWRkaW5nLXRvcDpjYWxjKCh2YXIoLS1saW5lLWhlaWdodCkgLSB2YXIoLS1zaXplLWNoZWNrYm94KSkgLyAyKTtncmlkLWFyZWE6Y2hlY2tib3g7d2lkdGg6dmFyKC0tc2l6ZS1jaGVja2JveCk7aGVpZ2h0OnZhcigtLXNpemUtY2hlY2tib3gpO2Rpc3BsYXk6ZmxleDtjdXJzb3I6cG9pbnRlcn0uY2R4LWxpc3RfX2NoZWNrYm94IHN2Z3tvcGFjaXR5OjA7aGVpZ2h0OnZhcigtLXNpemUtY2hlY2tib3gpO3dpZHRoOnZhcigtLXNpemUtY2hlY2tib3gpO2xlZnQ6LTFweDt0b3A6LTFweDtwb3NpdGlvbjphYnNvbHV0ZX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNkeC1saXN0X19jaGVja2JveDpub3QoLmNkeC1saXN0X19jaGVja2JveC0tbm8taG92ZXIpOmhvdmVyIC5jZHgtbGlzdF9fY2hlY2tib3gtY2hlY2sgc3Zne29wYWNpdHk6MX19LmNkeC1saXN0X19jaGVja2JveC0tY2hlY2tlZHtsaW5lLWhlaWdodDp2YXIoLS1saW5lLWhlaWdodCl9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQ6bm90KC5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQtLW5vLWhvdmVyKTpob3ZlciAuY2R4LWNoZWNrbGlzdF9fY2hlY2tib3gtY2hlY2t7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iZy1jaGVja2VkLWhvdmVyKTtib3JkZXItY29sb3I6dmFyKC0tY29sb3ItYmctY2hlY2tlZC1ob3Zlcil9fS5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQgLmNkeC1saXN0X19jaGVja2JveC1jaGVja3tiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJnLWNoZWNrZWQpO2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvci1iZy1jaGVja2VkKX0uY2R4LWxpc3RfX2NoZWNrYm94LS1jaGVja2VkIC5jZHgtbGlzdF9fY2hlY2tib3gtY2hlY2sgc3Zne29wYWNpdHk6MX0uY2R4LWxpc3RfX2NoZWNrYm94LS1jaGVja2VkIC5jZHgtbGlzdF9fY2hlY2tib3gtY2hlY2sgc3ZnIHBhdGh7c3Ryb2tlOnZhcigtLWNvbG9yLXRpY2spfS5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQgLmNkeC1saXN0X19jaGVja2JveC1jaGVjazpiZWZvcmV7b3BhY2l0eTowO3Zpc2liaWxpdHk6dmlzaWJsZTt0cmFuc2Zvcm06c2NhbGUoMi41KX0uY2R4LWxpc3RfX2NoZWNrYm94LWNoZWNre2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjowIGF1dG87d2lkdGg6dmFyKC0tc2l6ZS1jaGVja2JveCk7aGVpZ2h0OnZhcigtLXNpemUtY2hlY2tib3gpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOnZhcigtLXJhZGl1cy1ib3JkZXIpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY29sb3ItYm9yZGVyKTtiYWNrZ3JvdW5kOnZhcigtLWNoZWNrYm94LWJhY2tncm91bmQpfS5jZHgtbGlzdF9fY2hlY2tib3gtY2hlY2s6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtib3JkZXItcmFkaXVzOjEwMCU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iZy1jaGVja2VkKTt2aXNpYmlsaXR5OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO3RyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgZWFzZS1vdXQsb3BhY2l0eSAuNHN9LmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGR7YmFja2dyb3VuZDojRjhGOEY4O2JvcmRlcjoxcHggc29saWQgcmdiYSgyMjYsMjI2LDIyOSwuMik7Ym9yZGVyLXJhZGl1czo2cHg7cGFkZGluZzoycHg7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIGF1dG8gMWZyO2dyaWQtdGVtcGxhdGUtcm93czphdXRvfS5jZHgtbGlzdC1zdGFydC13aXRoLWZpZWxkLS1pbnZhbGlke2JhY2tncm91bmQ6I0ZGRUNFRDtib3JkZXI6MXB4IHNvbGlkICNFMTNGM0Z9LmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGQtLWludmFsaWQgLmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGRfX2lucHV0e2NvbG9yOiNlMTNmM2Z9LmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGRfX2lucHV0e2ZvbnQtc2l6ZToxNHB4O291dGxpbmU6bm9uZTtmb250LXdlaWdodDo1MDA7Zm9udC1mYW1pbHk6aW5oZXJpdDtib3JkZXI6MDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O21hcmdpbjowO3BhZGRpbmc6MDtsaW5lLWhlaWdodDoyMnB4O21pbi13aWR0aDpjYWxjKDEwMCUgLSB2YXIoLS10b29sYm94LWJ1dHRvbnMtc2l6ZSkgLSB2YXIoLS1pY29uLW1hcmdpbi1yaWdodCkpfS5jZHgtbGlzdC1zdGFydC13aXRoLWZpZWxkX19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6dmFyKC0tZ3JheVRleHQpO2ZvbnQtd2VpZ2h0OjUwMH0nKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2goYyl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLGMpfX0pKCk7XG5jb25zdCBDdCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNyAxMkwxMC40ODg0IDE1LjgzNzJDMTAuNTY3NyAxNS45MjQ1IDEwLjcwNSAxNS45MjQ1IDEwLjc4NDQgMTUuODM3MkwxNyA5XCIvPjwvc3ZnPicsIEFlID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjIgMTJMMTEuMDU4NiAxMy44NTg2QzExLjEzNjcgMTMuOTM2NyAxMS4yNjMzIDEzLjkzNjcgMTEuMzQxNCAxMy44NTg2TDE0LjcgMTAuNVwiLz48cmVjdCB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB4PVwiNVwiIHk9XCI1XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHJ4PVwiNFwiLz48L3N2Zz4nLCAkZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCI3XCIgeTI9XCI3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCI5XCIgeDI9XCIxOVwiIHkxPVwiMTJcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCI5XCIgeDI9XCIxOVwiIHkxPVwiMTdcIiB5Mj1cIjE3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMDAwMDEgMTdINC45OTAwMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4wMDAwMSAxMkg0Ljk5MDAyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjAwMDAxIDdINC45OTAwMlwiLz48L3N2Zz4nLCBCZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48bGluZSB4MT1cIjEyXCIgeDI9XCIxOVwiIHkxPVwiN1wiIHkyPVwiN1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjE5XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjEyXCIgeDI9XCIxOVwiIHkxPVwiMTdcIiB5Mj1cIjE3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcuNzk5OTkgMTRMNy43OTk5OSA3LjIxMzVDNy43OTk5OSA3LjEyODcyIDcuNzAxMSA3LjA4MjQgNy42MzU5NyA3LjEzNjY4TDQuNzk5OTkgOS41XCIvPjwvc3ZnPicsIFN0ID0gJzxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTAgMTQuMkwxMCA3LjQxMzVDMTAgNy4zMjg3MiA5LjkwMTExIDcuMjgyNDEgOS44MzU5OCA3LjMzNjY4TDcgOS43XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNMTMuMjA4NyAxNC4ySDEzLjJcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PC9zdmc+JywgT3QgPSAnPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xMy4yMDg3IDE0LjJIMTMuMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48cGF0aCBkPVwiTTEwIDE0LjJMMTAgOS41XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNMTAgNy4wMUwxMCA3XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjhcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjwvc3ZnPicsIGt0ID0gJzxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTMuMjA4NyAxNC4ySDEzLjJcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PHBhdGggZD1cIk0xMCAxNC4yTDEwIDcuMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48L3N2Zz4nLCBfdCA9ICc8c3ZnIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE2LjAwODcgMTQuMkgxNlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48cGF0aCBkPVwiTTcgMTQuMkw3Ljc4ODY1IDEyTTEzIDE0LjJMMTIuMTM3NyAxMk03Ljc4ODY1IDEyQzcuNzg4NjUgMTIgOS42ODM2MiA3IDEwIDdDMTAuMzA2NSA3IDEyLjEzNzcgMTIgMTIuMTM3NyAxMk03Ljc4ODY1IDEyTDEyLjEzNzcgMTJcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PC9zdmc+JywgRXQgPSAnPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNC4yMDg3IDE0LjJIMTQuMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48cGF0aCBkPVwiTTExLjUgMTQuNUMxMS41IDE0LjUgMTEgMTMuMjgxIDExIDEyLjVNNyA5LjVDNyA5LjUgNy41IDguNSA5IDguNUMxMC41IDguNSAxMSA5LjUgMTEgMTAuNUwxMSAxMS41TTExIDExLjVMMTEgMTIuNU0xMSAxMS41QzExIDExLjUgNyAxMSA3IDEzQzcgMTUuMzAzMSAxMSAxNSAxMSAxMi41XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjwvc3ZnPicsIEl0ID0gJzxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNOCAxNC4yTDggNy40MTM1QzggNy4zMjg3MiA3LjkwMTExIDcuMjgyNDEgNy44MzU5OCA3LjMzNjY4TDUgOS43XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNMTQgMTNMMTYuNDE2NyAxMC43Nzc4TTE2LjQxNjcgMTAuNzc3OEwxNCA4LjVNMTYuNDE2NyAxMC43Nzc4SDExLjY1NjJcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiLz48L3N2Zz4nO1xudmFyIEEgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiB3dChlKSB7XG4gIGlmIChlLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciB0ID0gZS5kZWZhdWx0O1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbiByKCkge1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG4ucHJvdG90eXBlID0gdC5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIG4gPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgciwgaS5nZXQgPyBpIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZVtyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIG47XG59XG52YXIgYyA9IHt9LCBWID0ge30sIFkgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShZLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5ZLmFsbElucHV0c1NlbGVjdG9yID0gUHQ7XG5mdW5jdGlvbiBQdCgpIHtcbiAgdmFyIGUgPSBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIiwgXCJlbWFpbFwiLCBcIm51bWJlclwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiXTtcbiAgcmV0dXJuIFwiW2NvbnRlbnRlZGl0YWJsZT10cnVlXSwgdGV4dGFyZWEsIGlucHV0Om5vdChbdHlwZV0pLCBcIiArIGUubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gJ2lucHV0W3R5cGU9XCInLmNvbmNhdCh0LCAnXCJdJyk7XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuYWxsSW5wdXRzU2VsZWN0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gWTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYWxsSW5wdXRzU2VsZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5hbGxJbnB1dHNTZWxlY3RvcjtcbiAgfSB9KTtcbn0pKFYpO1xudmFyIGsgPSB7fSwgSiA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEosIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkouaXNOYXRpdmVJbnB1dCA9IGp0O1xuZnVuY3Rpb24ganQoZSkge1xuICB2YXIgdCA9IFtcbiAgICBcIklOUFVUXCIsXG4gICAgXCJURVhUQVJFQVwiXG4gIF07XG4gIHJldHVybiBlICYmIGUudGFnTmFtZSA/IHQuaW5jbHVkZXMoZS50YWdOYW1lKSA6ICExO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc05hdGl2ZUlucHV0ID0gdm9pZCAwO1xuICB2YXIgdCA9IEo7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTmF0aXZlSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc05hdGl2ZUlucHV0O1xuICB9IH0pO1xufSkoayk7XG52YXIgRmUgPSB7fSwgUSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFEsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblEuYXBwZW5kID0gVHQ7XG5mdW5jdGlvbiBUdChlLCB0KSB7XG4gIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIGUuYXBwZW5kQ2hpbGQobik7XG4gIH0pIDogZS5hcHBlbmRDaGlsZCh0KTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuYXBwZW5kID0gdm9pZCAwO1xuICB2YXIgdCA9IFE7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImFwcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmFwcGVuZDtcbiAgfSB9KTtcbn0pKEZlKTtcbnZhciBaID0ge30sIHggPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG54LmJsb2NrRWxlbWVudHMgPSBMdDtcbmZ1bmN0aW9uIEx0KCkge1xuICByZXR1cm4gW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJ0aWNsZVwiLFxuICAgIFwiYXNpZGVcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImNhbnZhc1wiLFxuICAgIFwiZGl2XCIsXG4gICAgXCJkbFwiLFxuICAgIFwiZHRcIixcbiAgICBcImZpZWxkc2V0XCIsXG4gICAgXCJmaWdjYXB0aW9uXCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZvb3RlclwiLFxuICAgIFwiZm9ybVwiLFxuICAgIFwiaDFcIixcbiAgICBcImgyXCIsXG4gICAgXCJoM1wiLFxuICAgIFwiaDRcIixcbiAgICBcImg1XCIsXG4gICAgXCJoNlwiLFxuICAgIFwiaGVhZGVyXCIsXG4gICAgXCJoZ3JvdXBcIixcbiAgICBcImhyXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibWFpblwiLFxuICAgIFwibmF2XCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwib2xcIixcbiAgICBcIm91dHB1dFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJydWJ5XCIsXG4gICAgXCJzZWN0aW9uXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGJvZHlcIixcbiAgICBcInRoZWFkXCIsXG4gICAgXCJ0clwiLFxuICAgIFwidGZvb3RcIixcbiAgICBcInVsXCIsXG4gICAgXCJ2aWRlb1wiXG4gIF07XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmJsb2NrRWxlbWVudHMgPSB2b2lkIDA7XG4gIHZhciB0ID0geDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG59KShaKTtcbnZhciBSZSA9IHt9LCBlZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5lZS5jYWxjdWxhdGVCYXNlbGluZSA9IE10O1xuZnVuY3Rpb24gTXQoZSkge1xuICB2YXIgdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpLCBuID0gcGFyc2VGbG9hdCh0LmZvbnRTaXplKSwgciA9IHBhcnNlRmxvYXQodC5saW5lSGVpZ2h0KSB8fCBuICogMS4yLCBpID0gcGFyc2VGbG9hdCh0LnBhZGRpbmdUb3ApLCBhID0gcGFyc2VGbG9hdCh0LmJvcmRlclRvcFdpZHRoKSwgbCA9IHBhcnNlRmxvYXQodC5tYXJnaW5Ub3ApLCBzID0gbiAqIDAuOCwgbyA9IChyIC0gbikgLyAyLCBkID0gbCArIGEgKyBpICsgbyArIHM7XG4gIHJldHVybiBkO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5jYWxjdWxhdGVCYXNlbGluZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBlZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY2FsY3VsYXRlQmFzZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jYWxjdWxhdGVCYXNlbGluZTtcbiAgfSB9KTtcbn0pKFJlKTtcbnZhciBxZSA9IHt9LCB0ZSA9IHt9LCBuZSA9IHt9LCByZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5yZS5pc0NvbnRlbnRFZGl0YWJsZSA9IE50O1xuZnVuY3Rpb24gTnQoZSkge1xuICByZXR1cm4gZS5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0NvbnRlbnRFZGl0YWJsZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSByZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDb250ZW50RWRpdGFibGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgfSB9KTtcbn0pKG5lKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0ZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudGUuY2FuU2V0Q2FyZXQgPSBCdDtcbnZhciBBdCA9IGssICR0ID0gbmU7XG5mdW5jdGlvbiBCdChlKSB7XG4gIHZhciB0ID0gITA7XG4gIGlmICgoMCwgQXQuaXNOYXRpdmVJbnB1dCkoZSkpXG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgY2FzZSBcImhpZGRlblwiOlxuICAgICAgY2FzZSBcInN1Ym1pdFwiOlxuICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgICAgdCA9ICExO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIGVsc2VcbiAgICB0ID0gKDAsICR0LmlzQ29udGVudEVkaXRhYmxlKShlKTtcbiAgcmV0dXJuIHQ7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmNhblNldENhcmV0ID0gdm9pZCAwO1xuICB2YXIgdCA9IHRlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYW5TZXRDYXJldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNhblNldENhcmV0O1xuICB9IH0pO1xufSkocWUpO1xudmFyICQgPSB7fSwgaWUgPSB7fTtcbmZ1bmN0aW9uIFd0KGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IG4udmFsdWUgIT09IHZvaWQgMCA/IFwidmFsdWVcIiA6IFwiZ2V0XCIsIGkgPSBuW3JdLCBhID0gYCMke3R9Q2FjaGVgO1xuICBpZiAobltyXSA9IGZ1bmN0aW9uKC4uLmwpIHtcbiAgICByZXR1cm4gdGhpc1thXSA9PT0gdm9pZCAwICYmICh0aGlzW2FdID0gaS5hcHBseSh0aGlzLCBsKSksIHRoaXNbYV07XG4gIH0sIHIgPT09IFwiZ2V0XCIgJiYgbi5zZXQpIHtcbiAgICBjb25zdCBsID0gbi5zZXQ7XG4gICAgbi5zZXQgPSBmdW5jdGlvbihzKSB7XG4gICAgICBkZWxldGUgZVthXSwgbC5hcHBseSh0aGlzLCBzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gVWUoKSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgd2luOiAhMSxcbiAgICBtYWM6ICExLFxuICAgIHgxMTogITEsXG4gICAgbGludXg6ICExXG4gIH0sIHQgPSBPYmplY3Qua2V5cyhlKS5maW5kKChuKSA9PiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKG4pICE9PSAtMSk7XG4gIHJldHVybiB0ICE9PSB2b2lkIDAgJiYgKGVbdF0gPSAhMCksIGU7XG59XG5mdW5jdGlvbiBhZShlKSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZSAhPT0gXCJcIiAmJiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIiB8fCBPYmplY3Qua2V5cyhlKS5sZW5ndGggPiAwKTtcbn1cbmZ1bmN0aW9uIER0KGUpIHtcbiAgcmV0dXJuICFhZShlKTtcbn1cbmNvbnN0IEh0ID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT09IG51bGwgJiYgYWUod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgJiYgKC9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xuZnVuY3Rpb24gRnQoZSkge1xuICBjb25zdCB0ID0gVWUoKTtcbiAgcmV0dXJuIGUgPSBlLnJlcGxhY2UoL3NoaWZ0L2dpLCBcIuKHp1wiKS5yZXBsYWNlKC9iYWNrc3BhY2UvZ2ksIFwi4oyrXCIpLnJlcGxhY2UoL2VudGVyL2dpLCBcIuKPjlwiKS5yZXBsYWNlKC91cC9naSwgXCLihpFcIikucmVwbGFjZSgvbGVmdC9naSwgXCLihpJcIikucmVwbGFjZSgvZG93bi9naSwgXCLihpNcIikucmVwbGFjZSgvcmlnaHQvZ2ksIFwi4oaQXCIpLnJlcGxhY2UoL2VzY2FwZS9naSwgXCLijotcIikucmVwbGFjZSgvaW5zZXJ0L2dpLCBcIkluc1wiKS5yZXBsYWNlKC9kZWxldGUvZ2ksIFwi4pChXCIpLnJlcGxhY2UoL1xcKy9naSwgXCIrXCIpLCB0Lm1hYyA/IGUgPSBlLnJlcGxhY2UoL2N0cmx8Y21kL2dpLCBcIuKMmFwiKS5yZXBsYWNlKC9hbHQvZ2ksIFwi4oylXCIpIDogZSA9IGUucmVwbGFjZSgvY21kL2dpLCBcIkN0cmxcIikucmVwbGFjZSgvd2luZG93cy9naSwgXCJXSU5cIiksIGU7XG59XG5mdW5jdGlvbiBSdChlKSB7XG4gIHJldHVybiBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gcXQoZSkge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgdC5zdHlsZS5sZWZ0ID0gXCItOTk5cHhcIiwgdC5zdHlsZS5ib3R0b20gPSBcIi05OTlweFwiLCB0LmlubmVySFRNTCA9IGUsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodCk7XG4gIGNvbnN0IG4gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoci5zZWxlY3ROb2RlKHQpLCBuID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb3B5IHRleHQgdG8gY2xpcGJvYXJkXCIpO1xuICBuLnJlbW92ZUFsbFJhbmdlcygpLCBuLmFkZFJhbmdlKHIpLCBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCk7XG59XG5mdW5jdGlvbiBVdChlLCB0LCBuKSB7XG4gIGxldCByO1xuICByZXR1cm4gKC4uLmkpID0+IHtcbiAgICBjb25zdCBhID0gdGhpcywgbCA9ICgpID0+IHtcbiAgICAgIHIgPSB2b2lkIDAsIG4gIT09ICEwICYmIGUuYXBwbHkoYSwgaSk7XG4gICAgfSwgcyA9IG4gPT09ICEwICYmIHIgIT09IHZvaWQgMDtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHIpLCByID0gd2luZG93LnNldFRpbWVvdXQobCwgdCksIHMgJiYgZS5hcHBseShhLCBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFMoZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB6dChlKSB7XG4gIHJldHVybiBTKGUpID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHplKGUpIHtcbiAgcmV0dXJuIFMoZSkgPT09IFwiZnVuY3Rpb25cIiB8fCBTKGUpID09PSBcImFzeW5jZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIEt0KGUpIHtcbiAgcmV0dXJuIHplKGUpICYmIC9eXFxzKmNsYXNzXFxzKy8udGVzdChlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gWHQoZSkge1xuICByZXR1cm4gUyhlKSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIE0oZSkge1xuICByZXR1cm4gUyhlKSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIEd0KGUpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlKSA9PT0gZTtcbn1cbmZ1bmN0aW9uIFZ0KGUpIHtcbiAgcmV0dXJuIFMoZSkgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBZdChlKSB7XG4gIHJldHVybiBTKGUpID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gWChlLCAuLi50KSB7XG4gIGlmICghdC5sZW5ndGgpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IG4gPSB0LnNoaWZ0KCk7XG4gIGlmIChNKGUpICYmIE0obikpXG4gICAgZm9yIChjb25zdCByIGluIG4pXG4gICAgICBNKG5bcl0pID8gKGVbcl0gPT09IHZvaWQgMCAmJiBPYmplY3QuYXNzaWduKGUsIHsgW3JdOiB7fSB9KSwgWChlW3JdLCBuW3JdKSkgOiBPYmplY3QuYXNzaWduKGUsIHsgW3JdOiBuW3JdIH0pO1xuICByZXR1cm4gWChlLCAuLi50KTtcbn1cbmZ1bmN0aW9uIEp0KGUsIHQsIG4pIHtcbiAgY29uc3QgciA9IGDCqyR7dH3CuyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSB0aGUgwqske259wrsgaW5zdGVhZC5gO1xuICBlICYmIGNvbnNvbGUud2FybihyKTtcbn1cbmZ1bmN0aW9uIFF0KGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTChlKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiLy9cIiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIGUgOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgZTtcbn1cbmZ1bmN0aW9uIFp0KGUpIHtcbiAgcmV0dXJuIGUgPiA0NyAmJiBlIDwgNTggfHwgZSA9PT0gMzIgfHwgZSA9PT0gMTMgfHwgZSA9PT0gMjI5IHx8IGUgPiA2NCAmJiBlIDwgOTEgfHwgZSA+IDk1ICYmIGUgPCAxMTIgfHwgZSA+IDE4NSAmJiBlIDwgMTkzIHx8IGUgPiAyMTggJiYgZSA8IDIyMztcbn1cbmNvbnN0IHh0ID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBFU0M6IDI3LFxuICBTUEFDRTogMzIsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIERPV046IDQwLFxuICBSSUdIVDogMzksXG4gIERFTEVURTogNDYsXG4gIE1FVEE6IDkxLFxuICBTTEFTSDogMTkxXG59LCBlbiA9IHtcbiAgTEVGVDogMCxcbiAgV0hFRUw6IDEsXG4gIFJJR0hUOiAyLFxuICBCQUNLV0FSRDogMyxcbiAgRk9SV0FSRDogNFxufTtcbmNsYXNzIHRuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIG5ldyBwcm9taXNlIHRvIHF1ZXVlXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBwcm9taXNlIHNob3VsZCBiZSBhZGRlZCB0byBxdWV1ZVxuICAgKi9cbiAgYWRkKHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKG4sIHIpID0+IHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQudGhlbih0KS50aGVuKG4pLmNhdGNoKHIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBubihlLCB0LCBuID0gdm9pZCAwKSB7XG4gIGxldCByLCBpLCBhLCBsID0gbnVsbCwgcyA9IDA7XG4gIG4gfHwgKG4gPSB7fSk7XG4gIGNvbnN0IG8gPSBmdW5jdGlvbigpIHtcbiAgICBzID0gbi5sZWFkaW5nID09PSAhMSA/IDAgOiBEYXRlLm5vdygpLCBsID0gbnVsbCwgYSA9IGUuYXBwbHkociwgaSksIGwgPT09IG51bGwgJiYgKHIgPSBpID0gbnVsbCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkID0gRGF0ZS5ub3coKTtcbiAgICAhcyAmJiBuLmxlYWRpbmcgPT09ICExICYmIChzID0gZCk7XG4gICAgY29uc3QgdSA9IHQgLSAoZCAtIHMpO1xuICAgIHJldHVybiByID0gdGhpcywgaSA9IGFyZ3VtZW50cywgdSA8PSAwIHx8IHUgPiB0ID8gKGwgJiYgKGNsZWFyVGltZW91dChsKSwgbCA9IG51bGwpLCBzID0gZCwgYSA9IGUuYXBwbHkociwgaSksIGwgPT09IG51bGwgJiYgKHIgPSBpID0gbnVsbCkpIDogIWwgJiYgbi50cmFpbGluZyAhPT0gITEgJiYgKGwgPSBzZXRUaW1lb3V0KG8sIHUpKSwgYTtcbiAgfTtcbn1cbmNvbnN0IHJuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgUHJvbWlzZVF1ZXVlOiB0bixcbiAgYmVhdXRpZnlTaG9ydGN1dDogRnQsXG4gIGNhY2hlYWJsZTogV3QsXG4gIGNhcGl0YWxpemU6IFJ0LFxuICBjb3B5VGV4dFRvQ2xpcGJvYXJkOiBxdCxcbiAgZGVib3VuY2U6IFV0LFxuICBkZWVwTWVyZ2U6IFgsXG4gIGRlcHJlY2F0aW9uQXNzZXJ0OiBKdCxcbiAgZ2V0VXNlck9TOiBVZSxcbiAgZ2V0VmFsaWRVcmw6IFF0LFxuICBpc0Jvb2xlYW46IHp0LFxuICBpc0NsYXNzOiBLdCxcbiAgaXNFbXB0eTogRHQsXG4gIGlzRnVuY3Rpb246IHplLFxuICBpc0lvc0RldmljZTogSHQsXG4gIGlzTnVtYmVyOiBYdCxcbiAgaXNPYmplY3Q6IE0sXG4gIGlzUHJpbnRhYmxlS2V5OiBadCxcbiAgaXNQcm9taXNlOiBHdCxcbiAgaXNTdHJpbmc6IFZ0LFxuICBpc1VuZGVmaW5lZDogWXQsXG4gIGtleUNvZGVzOiB4dCxcbiAgbW91c2VCdXR0b25zOiBlbixcbiAgbm90RW1wdHk6IGFlLFxuICB0aHJvdHRsZTogbm4sXG4gIHR5cGVPZjogU1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgbGUgPSAvKiBAX19QVVJFX18gKi8gd3Qocm4pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGllLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5pZS5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyA9IHNuO1xudmFyIGFuID0gbGUsIGxuID0gWjtcbmZ1bmN0aW9uIHNuKGUpIHtcbiAgdmFyIHQ7XG4gICgwLCBhbi5pc1N0cmluZykoZSkgPyAodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuaW5uZXJIVE1MID0gZSkgOiB0ID0gZTtcbiAgdmFyIG4gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuICEoMCwgbG4uYmxvY2tFbGVtZW50cykoKS5pbmNsdWRlcyhyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgQXJyYXkuZnJvbShyLmNoaWxkcmVuKS5ldmVyeShuKTtcbiAgfTtcbiAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZHJlbikuZXZlcnkobik7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzID0gdm9pZCAwO1xuICB2YXIgdCA9IGllO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjb250YWluc09ubHlJbmxpbmVFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzO1xuICB9IH0pO1xufSkoJCk7XG52YXIgS2UgPSB7fSwgc2UgPSB7fSwgQiA9IHt9LCBvZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5vZS5tYWtlID0gb247XG5mdW5jdGlvbiBvbihlLCB0LCBuKSB7XG4gIHZhciByO1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBudWxsKSwgbiA9PT0gdm9pZCAwICYmIChuID0ge30pO1xuICB2YXIgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgdmFyIGEgPSB0LmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcyAhPT0gdm9pZCAwO1xuICAgIH0pO1xuICAgIChyID0gaS5jbGFzc0xpc3QpLmFkZC5hcHBseShyLCBhKTtcbiAgfSBlbHNlXG4gICAgdCAhPT0gbnVsbCAmJiBpLmNsYXNzTGlzdC5hZGQodCk7XG4gIGZvciAodmFyIGwgaW4gbilcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgbCkgJiYgKGlbbF0gPSBuW2xdKTtcbiAgcmV0dXJuIGk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLm1ha2UgPSB2b2lkIDA7XG4gIHZhciB0ID0gb2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm1ha2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5tYWtlO1xuICB9IH0pO1xufSkoQik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnNlLmZyYWdtZW50VG9TdHJpbmcgPSBjbjtcbnZhciB1biA9IEI7XG5mdW5jdGlvbiBjbihlKSB7XG4gIHZhciB0ID0gKDAsIHVuLm1ha2UpKFwiZGl2XCIpO1xuICByZXR1cm4gdC5hcHBlbmRDaGlsZChlKSwgdC5pbm5lckhUTUw7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmZyYWdtZW50VG9TdHJpbmcgPSB2b2lkIDA7XG4gIHZhciB0ID0gc2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZyYWdtZW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5mcmFnbWVudFRvU3RyaW5nO1xuICB9IH0pO1xufSkoS2UpO1xudmFyIFhlID0ge30sIHVlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnVlLmdldENvbnRlbnRMZW5ndGggPSBmbjtcbnZhciBkbiA9IGs7XG5mdW5jdGlvbiBmbihlKSB7XG4gIHZhciB0LCBuO1xuICByZXR1cm4gKDAsIGRuLmlzTmF0aXZlSW5wdXQpKGUpID8gZS52YWx1ZS5sZW5ndGggOiBlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGUubGVuZ3RoIDogKG4gPSAodCA9IGUudGV4dENvbnRlbnQpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQubGVuZ3RoKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogMDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZ2V0Q29udGVudExlbmd0aCA9IHZvaWQgMDtcbiAgdmFyIHQgPSB1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q29udGVudExlbmd0aFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldENvbnRlbnRMZW5ndGg7XG4gIH0gfSk7XG59KShYZSk7XG52YXIgY2UgPSB7fSwgZGUgPSB7fSwgV2UgPSBBICYmIEEuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIGlmIChuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aCwgYTsgciA8IGk7IHIrKylcbiAgICAgIChhIHx8ICEociBpbiB0KSkgJiYgKGEgfHwgKGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LCAwLCByKSksIGFbcl0gPSB0W3JdKTtcbiAgcmV0dXJuIGUuY29uY2F0KGEgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZGUuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMgPSBHZTtcbnZhciBwbiA9ICQ7XG5mdW5jdGlvbiBHZShlKSB7XG4gIHJldHVybiAoMCwgcG4uY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMpKGUpID8gW2VdIDogQXJyYXkuZnJvbShlLmNoaWxkcmVuKS5yZWR1Y2UoZnVuY3Rpb24odCwgbikge1xuICAgIHJldHVybiBXZShXZShbXSwgdCwgITApLCBHZShuKSwgITApO1xuICB9LCBbXSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzID0gdm9pZCAwO1xuICB2YXIgdCA9IGRlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXREZWVwZXN0QmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldERlZXBlc3RCbG9ja0VsZW1lbnRzO1xuICB9IH0pO1xufSkoY2UpO1xudmFyIFZlID0ge30sIGZlID0ge30sIFcgPSB7fSwgcGUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xucGUuaXNMaW5lQnJlYWtUYWcgPSBtbjtcbmZ1bmN0aW9uIG1uKGUpIHtcbiAgcmV0dXJuIFtcbiAgICBcIkJSXCIsXG4gICAgXCJXQlJcIlxuICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzTGluZUJyZWFrVGFnID0gdm9pZCAwO1xuICB2YXIgdCA9IHBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xpbmVCcmVha1RhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTGluZUJyZWFrVGFnO1xuICB9IH0pO1xufSkoVyk7XG52YXIgRCA9IHt9LCBtZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5tZS5pc1NpbmdsZVRhZyA9IGhuO1xuZnVuY3Rpb24gaG4oZSkge1xuICByZXR1cm4gW1xuICAgIFwiQVJFQVwiLFxuICAgIFwiQkFTRVwiLFxuICAgIFwiQlJcIixcbiAgICBcIkNPTFwiLFxuICAgIFwiQ09NTUFORFwiLFxuICAgIFwiRU1CRURcIixcbiAgICBcIkhSXCIsXG4gICAgXCJJTUdcIixcbiAgICBcIklOUFVUXCIsXG4gICAgXCJLRVlHRU5cIixcbiAgICBcIkxJTktcIixcbiAgICBcIk1FVEFcIixcbiAgICBcIlBBUkFNXCIsXG4gICAgXCJTT1VSQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJXQlJcIlxuICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzU2luZ2xlVGFnID0gdm9pZCAwO1xuICB2YXIgdCA9IG1lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc1NpbmdsZVRhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzU2luZ2xlVGFnO1xuICB9IH0pO1xufSkoRCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZmUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmZlLmdldERlZXBlc3ROb2RlID0gWWU7XG52YXIgZ24gPSBrLCB2biA9IFcsIGJuID0gRDtcbmZ1bmN0aW9uIFllKGUsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpO1xuICB2YXIgbiA9IHQgPyBcImxhc3RDaGlsZFwiIDogXCJmaXJzdENoaWxkXCIsIHIgPSB0ID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIjtcbiAgaWYgKGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVbbl0pIHtcbiAgICB2YXIgaSA9IGVbbl07XG4gICAgaWYgKCgwLCBibi5pc1NpbmdsZVRhZykoaSkgJiYgISgwLCBnbi5pc05hdGl2ZUlucHV0KShpKSAmJiAhKDAsIHZuLmlzTGluZUJyZWFrVGFnKShpKSlcbiAgICAgIGlmIChpW3JdKVxuICAgICAgICBpID0gaVtyXTtcbiAgICAgIGVsc2UgaWYgKGkucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBpLnBhcmVudE5vZGVbcl0pXG4gICAgICAgIGkgPSBpLnBhcmVudE5vZGVbcl07XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBpLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIFllKGksIHQpO1xuICB9XG4gIHJldHVybiBlO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXREZWVwZXN0Tm9kZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBmZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0RGVlcGVzdE5vZGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5nZXREZWVwZXN0Tm9kZTtcbiAgfSB9KTtcbn0pKFZlKTtcbnZhciBKZSA9IHt9LCBoZSA9IHt9LCBqID0gQSAmJiBBLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24oZSwgdCwgbikge1xuICBpZiAobiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgIGZvciAodmFyIHIgPSAwLCBpID0gdC5sZW5ndGgsIGE7IHIgPCBpOyByKyspXG4gICAgICAoYSB8fCAhKHIgaW4gdCkpICYmIChhIHx8IChhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCwgMCwgcikpLCBhW3JdID0gdFtyXSk7XG4gIHJldHVybiBlLmNvbmNhdChhIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmhlLmZpbmRBbGxJbnB1dHMgPSBrbjtcbnZhciB5biA9ICQsIENuID0gY2UsIFNuID0gViwgT24gPSBrO1xuZnVuY3Rpb24ga24oZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwoKDAsIFNuLmFsbElucHV0c1NlbGVjdG9yKSgpKSkucmVkdWNlKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICByZXR1cm4gKDAsIE9uLmlzTmF0aXZlSW5wdXQpKG4pIHx8ICgwLCB5bi5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cykobikgPyBqKGooW10sIHQsICEwKSwgW25dLCAhMSkgOiBqKGooW10sIHQsICEwKSwgKDAsIENuLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKShuKSwgITApO1xuICB9LCBbXSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmZpbmRBbGxJbnB1dHMgPSB2b2lkIDA7XG4gIHZhciB0ID0gaGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZpbmRBbGxJbnB1dHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5maW5kQWxsSW5wdXRzO1xuICB9IH0pO1xufSkoSmUpO1xudmFyIFFlID0ge30sIGdlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmdlLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMgPSBfbjtcbmZ1bmN0aW9uIF9uKGUpIHtcbiAgcmV0dXJuICEvW15cXHRcXG5cXHIgXS8udGVzdChlKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBnZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDb2xsYXBzZWRXaGl0ZXNwYWNlc1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzQ29sbGFwc2VkV2hpdGVzcGFjZXM7XG4gIH0gfSk7XG59KShRZSk7XG52YXIgdmUgPSB7fSwgYmUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShiZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuYmUuaXNFbGVtZW50ID0gSW47XG52YXIgRW4gPSBsZTtcbmZ1bmN0aW9uIEluKGUpIHtcbiAgcmV0dXJuICgwLCBFbi5pc051bWJlcikoZSkgPyAhMSA6ICEhZSAmJiAhIWUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBiZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNFbGVtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNFbGVtZW50O1xuICB9IH0pO1xufSkodmUpO1xudmFyIFplID0ge30sIHllID0ge30sIENlID0ge30sIFNlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblNlLmlzTGVhZiA9IHduO1xuZnVuY3Rpb24gd24oZSkge1xuICByZXR1cm4gZSA9PT0gbnVsbCA/ICExIDogZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNMZWFmID0gdm9pZCAwO1xuICB2YXIgdCA9IFNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xlYWZcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0xlYWY7XG4gIH0gfSk7XG59KShDZSk7XG52YXIgT2UgPSB7fSwga2UgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xua2UuaXNOb2RlRW1wdHkgPSBNbjtcbnZhciBQbiA9IFcsIGpuID0gdmUsIFRuID0gaywgTG4gPSBEO1xuZnVuY3Rpb24gTW4oZSwgdCkge1xuICB2YXIgbiA9IFwiXCI7XG4gIHJldHVybiAoMCwgTG4uaXNTaW5nbGVUYWcpKGUpICYmICEoMCwgUG4uaXNMaW5lQnJlYWtUYWcpKGUpID8gITEgOiAoKDAsIGpuLmlzRWxlbWVudCkoZSkgJiYgKDAsIFRuLmlzTmF0aXZlSW5wdXQpKGUpID8gbiA9IGUudmFsdWUgOiBlLnRleHRDb250ZW50ICE9PSBudWxsICYmIChuID0gZS50ZXh0Q29udGVudC5yZXBsYWNlKFwi4oCLXCIsIFwiXCIpKSwgdCAhPT0gdm9pZCAwICYmIChuID0gbi5yZXBsYWNlKG5ldyBSZWdFeHAodCwgXCJnXCIpLCBcIlwiKSksIG4udHJpbSgpLmxlbmd0aCA9PT0gMCk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzTm9kZUVtcHR5ID0gdm9pZCAwO1xuICB2YXIgdCA9IGtlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc05vZGVFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTm9kZUVtcHR5O1xuICB9IH0pO1xufSkoT2UpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHllLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG55ZS5pc0VtcHR5ID0gJG47XG52YXIgTm4gPSBDZSwgQW4gPSBPZTtcbmZ1bmN0aW9uICRuKGUsIHQpIHtcbiAgZS5ub3JtYWxpemUoKTtcbiAgZm9yICh2YXIgbiA9IFtlXTsgbi5sZW5ndGggPiAwOyApIHtcbiAgICB2YXIgciA9IG4uc2hpZnQoKTtcbiAgICBpZiAocikge1xuICAgICAgaWYgKGUgPSByLCAoMCwgTm4uaXNMZWFmKShlKSAmJiAhKDAsIEFuLmlzTm9kZUVtcHR5KShlLCB0KSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgbi5wdXNoLmFwcGx5KG4sIEFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAhMDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNFbXB0eSA9IHZvaWQgMDtcbiAgdmFyIHQgPSB5ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzRW1wdHk7XG4gIH0gfSk7XG59KShaZSk7XG52YXIgeGUgPSB7fSwgX2UgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuX2UuaXNGcmFnbWVudCA9IFduO1xudmFyIEJuID0gbGU7XG5mdW5jdGlvbiBXbihlKSB7XG4gIHJldHVybiAoMCwgQm4uaXNOdW1iZXIpKGUpID8gITEgOiAhIWUgJiYgISFlLm5vZGVUeXBlICYmIGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNGcmFnbWVudCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBfZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzRnJhZ21lbnQ7XG4gIH0gfSk7XG59KSh4ZSk7XG52YXIgZXQgPSB7fSwgRWUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuRWUuaXNIVE1MU3RyaW5nID0gSG47XG52YXIgRG4gPSBCO1xuZnVuY3Rpb24gSG4oZSkge1xuICB2YXIgdCA9ICgwLCBEbi5tYWtlKShcImRpdlwiKTtcbiAgcmV0dXJuIHQuaW5uZXJIVE1MID0gZSwgdC5jaGlsZEVsZW1lbnRDb3VudCA+IDA7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzSFRNTFN0cmluZyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBFZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNIVE1MU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNIVE1MU3RyaW5nO1xuICB9IH0pO1xufSkoZXQpO1xudmFyIHR0ID0ge30sIEllID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkllLm9mZnNldCA9IEZuO1xuZnVuY3Rpb24gRm4oZSkge1xuICB2YXIgdCA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIHIgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgaSA9IHQudG9wICsgciwgYSA9IHQubGVmdCArIG47XG4gIHJldHVybiB7XG4gICAgdG9wOiBpLFxuICAgIGxlZnQ6IGEsXG4gICAgYm90dG9tOiBpICsgdC5oZWlnaHQsXG4gICAgcmlnaHQ6IGEgKyB0LndpZHRoXG4gIH07XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLm9mZnNldCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBJZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwib2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQub2Zmc2V0O1xuICB9IH0pO1xufSkodHQpO1xudmFyIG50ID0ge30sIHdlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbndlLnByZXBlbmQgPSBSbjtcbmZ1bmN0aW9uIFJuKGUsIHQpIHtcbiAgQXJyYXkuaXNBcnJheSh0KSA/ICh0ID0gdC5yZXZlcnNlKCksIHQuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGUucHJlcGVuZChuKTtcbiAgfSkpIDogZS5wcmVwZW5kKHQpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5wcmVwZW5kID0gdm9pZCAwO1xuICB2YXIgdCA9IHdlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcmVwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQucHJlcGVuZDtcbiAgfSB9KTtcbn0pKG50KTtcbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUucHJlcGVuZCA9IGUub2Zmc2V0ID0gZS5tYWtlID0gZS5pc0xpbmVCcmVha1RhZyA9IGUuaXNTaW5nbGVUYWcgPSBlLmlzTm9kZUVtcHR5ID0gZS5pc0xlYWYgPSBlLmlzSFRNTFN0cmluZyA9IGUuaXNGcmFnbWVudCA9IGUuaXNFbXB0eSA9IGUuaXNFbGVtZW50ID0gZS5pc0NvbnRlbnRFZGl0YWJsZSA9IGUuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IGUuZmluZEFsbElucHV0cyA9IGUuaXNOYXRpdmVJbnB1dCA9IGUuYWxsSW5wdXRzU2VsZWN0b3IgPSBlLmdldERlZXBlc3ROb2RlID0gZS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IGUuZ2V0Q29udGVudExlbmd0aCA9IGUuZnJhZ21lbnRUb1N0cmluZyA9IGUuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSBlLmNhblNldENhcmV0ID0gZS5jYWxjdWxhdGVCYXNlbGluZSA9IGUuYmxvY2tFbGVtZW50cyA9IGUuYXBwZW5kID0gdm9pZCAwO1xuICB2YXIgdCA9IFY7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImFsbElucHV0c1NlbGVjdG9yXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuYWxsSW5wdXRzU2VsZWN0b3I7XG4gIH0gfSk7XG4gIHZhciBuID0gaztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNOYXRpdmVJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuLmlzTmF0aXZlSW5wdXQ7XG4gIH0gfSk7XG4gIHZhciByID0gRmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImFwcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByLmFwcGVuZDtcbiAgfSB9KTtcbiAgdmFyIGkgPSBaO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJibG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkuYmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIGEgPSBSZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY2FsY3VsYXRlQmFzZWxpbmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5jYWxjdWxhdGVCYXNlbGluZTtcbiAgfSB9KTtcbiAgdmFyIGwgPSBxZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY2FuU2V0Q2FyZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbC5jYW5TZXRDYXJldDtcbiAgfSB9KTtcbiAgdmFyIHMgPSAkO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjb250YWluc09ubHlJbmxpbmVFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzO1xuICB9IH0pO1xuICB2YXIgbyA9IEtlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJmcmFnbWVudFRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG8uZnJhZ21lbnRUb1N0cmluZztcbiAgfSB9KTtcbiAgdmFyIGQgPSBYZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q29udGVudExlbmd0aFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkLmdldENvbnRlbnRMZW5ndGg7XG4gIH0gfSk7XG4gIHZhciB1ID0gY2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldERlZXBlc3RCbG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHUuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBwID0gVmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldERlZXBlc3ROb2RlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHAuZ2V0RGVlcGVzdE5vZGU7XG4gIH0gfSk7XG4gIHZhciBnID0gSmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZpbmRBbGxJbnB1dHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZy5maW5kQWxsSW5wdXRzO1xuICB9IH0pO1xuICB2YXIgdyA9IFFlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbGxhcHNlZFdoaXRlc3BhY2VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHcuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcztcbiAgfSB9KTtcbiAgdmFyIF8gPSBuZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDb250ZW50RWRpdGFibGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgfSB9KTtcbiAgdmFyIHV0ID0gdmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzRWxlbWVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dC5pc0VsZW1lbnQ7XG4gIH0gfSk7XG4gIHZhciBjdCA9IFplO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0VtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGN0LmlzRW1wdHk7XG4gIH0gfSk7XG4gIHZhciBkdCA9IHhlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGR0LmlzRnJhZ21lbnQ7XG4gIH0gfSk7XG4gIHZhciBmdCA9IGV0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0hUTUxTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnQuaXNIVE1MU3RyaW5nO1xuICB9IH0pO1xuICB2YXIgcHQgPSBDZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNMZWFmXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHB0LmlzTGVhZjtcbiAgfSB9KTtcbiAgdmFyIG10ID0gT2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTm9kZUVtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG10LmlzTm9kZUVtcHR5O1xuICB9IH0pO1xuICB2YXIgaHQgPSBXO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xpbmVCcmVha1RhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBodC5pc0xpbmVCcmVha1RhZztcbiAgfSB9KTtcbiAgdmFyIGd0ID0gRDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNTaW5nbGVUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ3QuaXNTaW5nbGVUYWc7XG4gIH0gfSk7XG4gIHZhciB2dCA9IEI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm1ha2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdnQubWFrZTtcbiAgfSB9KTtcbiAgdmFyIGJ0ID0gdHQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBidC5vZmZzZXQ7XG4gIH0gfSk7XG4gIHZhciB5dCA9IG50O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcmVwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHl0LnByZXBlbmQ7XG4gIH0gfSk7XG59KShjKTtcbmNvbnN0IGggPSBcImNkeC1saXN0XCIsIG0gPSB7XG4gIHdyYXBwZXI6IGgsXG4gIGl0ZW06IGAke2h9X19pdGVtYCxcbiAgaXRlbUNvbnRlbnQ6IGAke2h9X19pdGVtLWNvbnRlbnRgLFxuICBpdGVtQ2hpbGRyZW46IGAke2h9X19pdGVtLWNoaWxkcmVuYFxufTtcbmNsYXNzIHYge1xuICAvKipcbiAgICogR2V0dGVyIGZvciBhbGwgQ1NTIGNsYXNzZXMgdXNlZCBpbiB1bm9yZGVyZWQgbGlzdCByZW5kZXJpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tLFxuICAgICAgb3JkZXJlZExpc3Q6IGAke2h9LW9yZGVyZWRgXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIHBhc3NlZCByZWFkb25seSBtb2RlIGFuZCBjb25maWcgdG8gcmVsZXZhbnQgY2xhc3MgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcmVhZG9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqIEBwYXJhbSBjb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKi9cbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHRoaXMuY29uZmlnID0gbiwgdGhpcy5yZWFkT25seSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgb2wgd3JhcHBlciBmb3IgbGlzdFxuICAgKiBAcGFyYW0gaXNSb290IC0gYm9vbGVhbiB2YXJpYWJsZSB0aGF0IHJlcHJlc2VudHMgbGV2ZWwgb2YgdGhlIHdyYXBwcmUgKHJvb3Qgb3IgY2hpbGRMaXN0KVxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgaHRtbCBvbCBlbGVtZW50XG4gICAqL1xuICByZW5kZXJXcmFwcGVyKHQpIHtcbiAgICBsZXQgbjtcbiAgICByZXR1cm4gdCA9PT0gITAgPyBuID0gYy5tYWtlKFwib2xcIiwgW3YuQ1NTLndyYXBwZXIsIHYuQ1NTLm9yZGVyZWRMaXN0XSkgOiBuID0gYy5tYWtlKFwib2xcIiwgW3YuQ1NTLm9yZGVyZWRMaXN0LCB2LkNTUy5pdGVtQ2hpbGRyZW5dKSwgbjtcbiAgfVxuICAvKipcbiAgICogUmVkbmVycyBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKiBAcGFyYW0gY29udGVudCAtIGNvbnRlbnQgdXNlZCBpbiBsaXN0IGl0ZW0gcmVuZGVyaW5nXG4gICAqIEBwYXJhbSBfbWV0YSAtIG1ldGEgb2YgdGhlIGxpc3QgaXRlbSB1bnVzZWQgaW4gcmVuZGVyaW5nIG9mIHRoZSBvcmRlcmVkIGxpc3RcbiAgICogQHJldHVybnMgLSBjcmVhdGVkIGh0bWwgbGlzdCBpdGVtIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlckl0ZW0odCwgbikge1xuICAgIGNvbnN0IHIgPSBjLm1ha2UoXCJsaVwiLCB2LkNTUy5pdGVtKSwgaSA9IGMubWFrZShcImRpdlwiLCB2LkNTUy5pdGVtQ29udGVudCwge1xuICAgICAgaW5uZXJIVE1MOiB0LFxuICAgICAgY29udGVudEVkaXRhYmxlOiAoIXRoaXMucmVhZE9ubHkpLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICByZXR1cm4gci5hcHBlbmRDaGlsZChpKSwgcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIGNvbnRlbnRcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHdyYXBwZXIgKDxsaT4pXG4gICAqIEByZXR1cm5zIC0gaXRlbSBjb250ZW50IHN0cmluZ1xuICAgKi9cbiAgZ2V0SXRlbUNvbnRlbnQodCkge1xuICAgIGNvbnN0IG4gPSB0LnF1ZXJ5U2VsZWN0b3IoYC4ke3YuQ1NTLml0ZW1Db250ZW50fWApO1xuICAgIHJldHVybiAhbiB8fCBjLmlzRW1wdHkobikgPyBcIlwiIDogbi5pbm5lckhUTUw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaXRlbSBtZXRhLCBmb3Igb3JkZXJlZCBsaXN0XG4gICAqIEByZXR1cm5zIGl0ZW0gbWV0YSBvYmplY3RcbiAgICovXG4gIGdldEl0ZW1NZXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0IGl0ZW0gbWV0YSB1c2VkIG9uIGNyZWF0aW9uIG9mIHRoZSBuZXcgaXRlbVxuICAgKi9cbiAgY29tcG9zZURlZmF1bHRNZXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuY2xhc3MgYiB7XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIGFsbCBDU1MgY2xhc3NlcyB1c2VkIGluIHVub3JkZXJlZCBsaXN0IHJlbmRlcmluZ1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm0sXG4gICAgICB1bm9yZGVyZWRMaXN0OiBgJHtofS11bm9yZGVyZWRgXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIHBhc3NlZCByZWFkb25seSBtb2RlIGFuZCBjb25maWcgdG8gcmVsZXZhbnQgY2xhc3MgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcmVhZG9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqIEBwYXJhbSBjb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKi9cbiAgY29uc3RydWN0b3IodCwgbikge1xuICAgIHRoaXMuY29uZmlnID0gbiwgdGhpcy5yZWFkT25seSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlcnMgb2wgd3JhcHBlciBmb3IgbGlzdFxuICAgKiBAcGFyYW0gaXNSb290IC0gYm9vbGVhbiB2YXJpYWJsZSB0aGF0IHJlcHJlc2VudHMgbGV2ZWwgb2YgdGhlIHdyYXBwcmUgKHJvb3Qgb3IgY2hpbGRMaXN0KVxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgaHRtbCB1bCBlbGVtZW50XG4gICAqL1xuICByZW5kZXJXcmFwcGVyKHQpIHtcbiAgICBsZXQgbjtcbiAgICByZXR1cm4gdCA9PT0gITAgPyBuID0gYy5tYWtlKFwidWxcIiwgW2IuQ1NTLndyYXBwZXIsIGIuQ1NTLnVub3JkZXJlZExpc3RdKSA6IG4gPSBjLm1ha2UoXCJ1bFwiLCBbYi5DU1MudW5vcmRlcmVkTGlzdCwgYi5DU1MuaXRlbUNoaWxkcmVuXSksIG47XG4gIH1cbiAgLyoqXG4gICAqIFJlZG5lcnMgbGlzdCBpdGVtIGVsZW1lbnRcbiAgICogQHBhcmFtIGNvbnRlbnQgLSBjb250ZW50IHVzZWQgaW4gbGlzdCBpdGVtIHJlbmRlcmluZ1xuICAgKiBAcGFyYW0gX21ldGEgLSBtZXRhIG9mIHRoZSBsaXN0IGl0ZW0gdW51c2VkIGluIHJlbmRlcmluZyBvZiB0aGUgdW5vcmRlcmVkIGxpc3RcbiAgICogQHJldHVybnMgLSBjcmVhdGVkIGh0bWwgbGlzdCBpdGVtIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlckl0ZW0odCwgbikge1xuICAgIGNvbnN0IHIgPSBjLm1ha2UoXCJsaVwiLCBiLkNTUy5pdGVtKSwgaSA9IGMubWFrZShcImRpdlwiLCBiLkNTUy5pdGVtQ29udGVudCwge1xuICAgICAgaW5uZXJIVE1MOiB0LFxuICAgICAgY29udGVudEVkaXRhYmxlOiAoIXRoaXMucmVhZE9ubHkpLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICByZXR1cm4gci5hcHBlbmRDaGlsZChpKSwgcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIGNvbnRlbnRcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHdyYXBwZXIgKDxsaT4pXG4gICAqIEByZXR1cm5zIC0gaXRlbSBjb250ZW50IHN0cmluZ1xuICAgKi9cbiAgZ2V0SXRlbUNvbnRlbnQodCkge1xuICAgIGNvbnN0IG4gPSB0LnF1ZXJ5U2VsZWN0b3IoYC4ke2IuQ1NTLml0ZW1Db250ZW50fWApO1xuICAgIHJldHVybiAhbiB8fCBjLmlzRW1wdHkobikgPyBcIlwiIDogbi5pbm5lckhUTUw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaXRlbSBtZXRhLCBmb3IgdW5vcmRlcmVkIGxpc3RcbiAgICogQHJldHVybnMgSXRlbSBtZXRhIG9iamVjdFxuICAgKi9cbiAgZ2V0SXRlbU1ldGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHQgaXRlbSBtZXRhIHVzZWQgb24gY3JlYXRpb24gb2YgdGhlIG5ldyBpdGVtXG4gICAqL1xuICBjb21wb3NlRGVmYXVsdE1ldGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5mdW5jdGlvbiBPKGUpIHtcbiAgcmV0dXJuIGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxudmFyIFAgPSB7fSwgUGUgPSB7fSwgSCA9IHt9LCBGID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuRi5nZXRDb250ZW50ZWRpdGFibGVTbGljZSA9IFVuO1xudmFyIHFuID0gYztcbmZ1bmN0aW9uIFVuKGUsIHQsIG4sIHIsIGkpIHtcbiAgdmFyIGE7XG4gIGkgPT09IHZvaWQgMCAmJiAoaSA9ICExKTtcbiAgdmFyIGwgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAociA9PT0gXCJsZWZ0XCIgPyAobC5zZXRTdGFydChlLCAwKSwgbC5zZXRFbmQodCwgbikpIDogKGwuc2V0U3RhcnQodCwgbiksIGwuc2V0RW5kKGUsIGUuY2hpbGROb2Rlcy5sZW5ndGgpKSwgaSA9PT0gITApIHtcbiAgICB2YXIgcyA9IGwuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgcmV0dXJuICgwLCBxbi5mcmFnbWVudFRvU3RyaW5nKShzKTtcbiAgfVxuICB2YXIgbyA9IGwuY2xvbmVDb250ZW50cygpLCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZC5hcHBlbmRDaGlsZChvKTtcbiAgdmFyIHUgPSAoYSA9IGQudGV4dENvbnRlbnQpICE9PSBudWxsICYmIGEgIT09IHZvaWQgMCA/IGEgOiBcIlwiO1xuICByZXR1cm4gdTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShILCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5ILmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MgPSBYbjtcbnZhciB6biA9IGMsIEtuID0gRjtcbmZ1bmN0aW9uIFhuKGUsIHQsIG4sIHIpIHtcbiAgdmFyIGkgPSAoMCwgS24uZ2V0Q29udGVudGVkaXRhYmxlU2xpY2UpKGUsIHQsIG4sIHIpO1xuICByZXR1cm4gKDAsIHpuLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMpKGkpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzID0gdm9pZCAwO1xuICB2YXIgdCA9IEg7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3NcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzO1xuICB9IH0pO1xufSkoUGUpO1xudmFyIHJ0ID0ge307XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlID0gdm9pZCAwO1xuICB2YXIgdCA9IEY7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldENvbnRlbnRlZGl0YWJsZVNsaWNlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0Q29udGVudGVkaXRhYmxlU2xpY2U7XG4gIH0gfSk7XG59KShydCk7XG52YXIgaXQgPSB7fSwgamUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShqZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuamUuZm9jdXMgPSBWbjtcbnZhciBHbiA9IGM7XG5mdW5jdGlvbiBWbihlLCB0KSB7XG4gIHZhciBuLCByO1xuICBpZiAodCA9PT0gdm9pZCAwICYmICh0ID0gITApLCAoMCwgR24uaXNOYXRpdmVJbnB1dCkoZSkpIHtcbiAgICBlLmZvY3VzKCk7XG4gICAgdmFyIGkgPSB0ID8gMCA6IGUudmFsdWUubGVuZ3RoO1xuICAgIGUuc2V0U2VsZWN0aW9uUmFuZ2UoaSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCBsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghbClcbiAgICAgIHJldHVybjtcbiAgICB2YXIgcyA9IGZ1bmN0aW9uKGcsIHcpIHtcbiAgICAgIHcgPT09IHZvaWQgMCAmJiAodyA9ICExKTtcbiAgICAgIHZhciBfID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICB3ID8gZy5pbnNlcnRCZWZvcmUoXywgZy5maXJzdENoaWxkKSA6IGcuYXBwZW5kQ2hpbGQoXyksIGEuc2V0U3RhcnQoXywgMCksIGEuc2V0RW5kKF8sIDApO1xuICAgIH0sIG8gPSBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZyAhPSBudWxsO1xuICAgIH0sIGQgPSBlLmNoaWxkTm9kZXMsIHUgPSB0ID8gZFswXSA6IGRbZC5sZW5ndGggLSAxXTtcbiAgICBpZiAobyh1KSkge1xuICAgICAgZm9yICg7IG8odSkgJiYgdS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREU7IClcbiAgICAgICAgdSA9IHQgPyB1LmZpcnN0Q2hpbGQgOiB1Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChvKHUpICYmIHUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIHZhciBwID0gKHIgPSAobiA9IHUudGV4dENvbnRlbnQpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4ubGVuZ3RoKSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogMCwgaSA9IHQgPyAwIDogcDtcbiAgICAgICAgYS5zZXRTdGFydCh1LCBpKSwgYS5zZXRFbmQodSwgaSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcyhlLCB0KTtcbiAgICB9IGVsc2VcbiAgICAgIHMoZSk7XG4gICAgbC5yZW1vdmVBbGxSYW5nZXMoKSwgbC5hZGRSYW5nZShhKTtcbiAgfVxufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5mb2N1cyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBqZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZm9jdXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5mb2N1cztcbiAgfSB9KTtcbn0pKGl0KTtcbnZhciBUZSA9IHt9LCBSID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuUi5nZXRDYXJldE5vZGVBbmRPZmZzZXQgPSBZbjtcbmZ1bmN0aW9uIFluKCkge1xuICB2YXIgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKGUgPT09IG51bGwpXG4gICAgcmV0dXJuIFtudWxsLCAwXTtcbiAgdmFyIHQgPSBlLmZvY3VzTm9kZSwgbiA9IGUuZm9jdXNPZmZzZXQ7XG4gIHJldHVybiB0ID09PSBudWxsID8gW251bGwsIDBdIDogKHQubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFICYmIHQuY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmICh0LmNoaWxkTm9kZXNbbl0gIT09IHZvaWQgMCA/ICh0ID0gdC5jaGlsZE5vZGVzW25dLCBuID0gMCkgOiAodCA9IHQuY2hpbGROb2Rlc1tuIC0gMV0sIHQudGV4dENvbnRlbnQgIT09IG51bGwgJiYgKG4gPSB0LnRleHRDb250ZW50Lmxlbmd0aCkpKSwgW3QsIG5dKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0ID0gdm9pZCAwO1xuICB2YXIgdCA9IFI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldENhcmV0Tm9kZUFuZE9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldENhcmV0Tm9kZUFuZE9mZnNldDtcbiAgfSB9KTtcbn0pKFRlKTtcbnZhciBhdCA9IHt9LCBxID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xucS5nZXRSYW5nZSA9IEpuO1xuZnVuY3Rpb24gSm4oKSB7XG4gIHZhciBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICByZXR1cm4gZSAmJiBlLnJhbmdlQ291bnQgPyBlLmdldFJhbmdlQXQoMCkgOiBudWxsO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXRSYW5nZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBxO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXRSYW5nZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldFJhbmdlO1xuICB9IH0pO1xufSkoYXQpO1xudmFyIGx0ID0ge30sIExlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkxlLmlzQ2FyZXRBdEVuZE9mSW5wdXQgPSB4bjtcbnZhciBEZSA9IGMsIFFuID0gVGUsIFpuID0gUGU7XG5mdW5jdGlvbiB4bihlKSB7XG4gIHZhciB0ID0gKDAsIERlLmdldERlZXBlc3ROb2RlKShlLCAhMCk7XG4gIGlmICh0ID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKCgwLCBEZS5pc05hdGl2ZUlucHV0KSh0KSlcbiAgICByZXR1cm4gdC5zZWxlY3Rpb25FbmQgPT09IHQudmFsdWUubGVuZ3RoO1xuICB2YXIgbiA9ICgwLCBRbi5nZXRDYXJldE5vZGVBbmRPZmZzZXQpKCksIHIgPSBuWzBdLCBpID0gblsxXTtcbiAgcmV0dXJuIHIgPT09IG51bGwgPyAhMSA6ICgwLCBabi5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzKShlLCByLCBpLCBcInJpZ2h0XCIpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0NhcmV0QXRFbmRPZklucHV0ID0gdm9pZCAwO1xuICB2YXIgdCA9IExlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NhcmV0QXRFbmRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNDYXJldEF0RW5kT2ZJbnB1dDtcbiAgfSB9KTtcbn0pKGx0KTtcbnZhciBzdCA9IHt9LCBNZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5NZS5pc0NhcmV0QXRTdGFydE9mSW5wdXQgPSBucjtcbnZhciBUID0gYywgZXIgPSBSLCB0ciA9IEg7XG5mdW5jdGlvbiBucihlKSB7XG4gIHZhciB0ID0gKDAsIFQuZ2V0RGVlcGVzdE5vZGUpKGUpO1xuICBpZiAodCA9PT0gbnVsbCB8fCAoMCwgVC5pc0VtcHR5KShlKSlcbiAgICByZXR1cm4gITA7XG4gIGlmICgoMCwgVC5pc05hdGl2ZUlucHV0KSh0KSlcbiAgICByZXR1cm4gdC5zZWxlY3Rpb25FbmQgPT09IDA7XG4gIGlmICgoMCwgVC5pc0VtcHR5KShlKSlcbiAgICByZXR1cm4gITA7XG4gIHZhciBuID0gKDAsIGVyLmdldENhcmV0Tm9kZUFuZE9mZnNldCkoKSwgciA9IG5bMF0sIGkgPSBuWzFdO1xuICByZXR1cm4gciA9PT0gbnVsbCA/ICExIDogKDAsIHRyLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MpKGUsIHIsIGksIFwibGVmdFwiKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNDYXJldEF0U3RhcnRPZklucHV0ID0gdm9pZCAwO1xuICB2YXIgdCA9IE1lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NhcmV0QXRTdGFydE9mSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0NhcmV0QXRTdGFydE9mSW5wdXQ7XG4gIH0gfSk7XG59KShzdCk7XG52YXIgb3QgPSB7fSwgTmUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTmUuc2F2ZSA9IGFyO1xudmFyIHJyID0gYywgaXIgPSBxO1xuZnVuY3Rpb24gYXIoKSB7XG4gIHZhciBlID0gKDAsIGlyLmdldFJhbmdlKSgpLCB0ID0gKDAsIHJyLm1ha2UpKFwic3BhblwiKTtcbiAgaWYgKHQuaWQgPSBcImN1cnNvclwiLCB0LmhpZGRlbiA9ICEwLCAhIWUpXG4gICAgcmV0dXJuIGUuaW5zZXJ0Tm9kZSh0KSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHIgJiYgKGUuc2V0U3RhcnRBZnRlcih0KSwgZS5zZXRFbmRBZnRlcih0KSwgci5yZW1vdmVBbGxSYW5nZXMoKSwgci5hZGRSYW5nZShlKSwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdC5yZW1vdmUoKTtcbiAgICAgIH0sIDE1MCkpO1xuICAgIH07XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLnNhdmUgPSB2b2lkIDA7XG4gIHZhciB0ID0gTmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInNhdmVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5zYXZlO1xuICB9IH0pO1xufSkob3QpO1xuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5zYXZlID0gZS5pc0NhcmV0QXRTdGFydE9mSW5wdXQgPSBlLmlzQ2FyZXRBdEVuZE9mSW5wdXQgPSBlLmdldFJhbmdlID0gZS5nZXRDYXJldE5vZGVBbmRPZmZzZXQgPSBlLmZvY3VzID0gZS5nZXRDb250ZW50ZWRpdGFibGVTbGljZSA9IGUuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBQZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzc1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3M7XG4gIH0gfSk7XG4gIHZhciBuID0gcnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldENvbnRlbnRlZGl0YWJsZVNsaWNlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG4uZ2V0Q29udGVudGVkaXRhYmxlU2xpY2U7XG4gIH0gfSk7XG4gIHZhciByID0gaXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZvY3VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuZm9jdXM7XG4gIH0gfSk7XG4gIHZhciBpID0gVGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldENhcmV0Tm9kZUFuZE9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpLmdldENhcmV0Tm9kZUFuZE9mZnNldDtcbiAgfSB9KTtcbiAgdmFyIGEgPSBhdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0UmFuZ2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5nZXRSYW5nZTtcbiAgfSB9KTtcbiAgdmFyIGwgPSBsdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDYXJldEF0RW5kT2ZJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsLmlzQ2FyZXRBdEVuZE9mSW5wdXQ7XG4gIH0gfSk7XG4gIHZhciBzID0gc3Q7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dDtcbiAgfSB9KTtcbiAgdmFyIG8gPSBvdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwic2F2ZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvLnNhdmU7XG4gIH0gfSk7XG59KShQKTtcbmNsYXNzIGYge1xuICAvKipcbiAgICogR2V0dGVyIGZvciBhbGwgQ1NTIGNsYXNzZXMgdXNlZCBpbiB1bm9yZGVyZWQgbGlzdCByZW5kZXJpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tLFxuICAgICAgY2hlY2tsaXN0OiBgJHtofS1jaGVja2xpc3RgLFxuICAgICAgaXRlbUNoZWNrZWQ6IGAke2h9X19jaGVja2JveC0tY2hlY2tlZGAsXG4gICAgICBub0hvdmVyOiBgJHtofV9fY2hlY2tib3gtLW5vLWhvdmVyYCxcbiAgICAgIGNoZWNrYm94OiBgJHtofV9fY2hlY2tib3gtY2hlY2tgLFxuICAgICAgY2hlY2tib3hDb250YWluZXI6IGAke2h9X19jaGVja2JveGBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gcGFzc2VkIHJlYWRvbmx5IG1vZGUgYW5kIGNvbmZpZyB0byByZWxldmFudCBjbGFzcyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSByZWFkb25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICogQHBhcmFtIGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdGhpcy5jb25maWcgPSBuLCB0aGlzLnJlYWRPbmx5ID0gdDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB1bCB3cmFwcGVyIGZvciBsaXN0XG4gICAqIEBwYXJhbSBpc1Jvb3QgLSBib29sZWFuIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyBsZXZlbCBvZiB0aGUgd3JhcHByZSAocm9vdCBvciBjaGlsZExpc3QpXG4gICAqIEByZXR1cm5zIC0gY3JlYXRlZCBodG1sIHVsIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlcldyYXBwZXIodCkge1xuICAgIGxldCBuO1xuICAgIHJldHVybiB0ID09PSAhMCA/IChuID0gYy5tYWtlKFwidWxcIiwgW2YuQ1NTLndyYXBwZXIsIGYuQ1NTLmNoZWNrbGlzdF0pLCBuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAocikgPT4ge1xuICAgICAgY29uc3QgaSA9IHIudGFyZ2V0O1xuICAgICAgaWYgKGkpIHtcbiAgICAgICAgY29uc3QgYSA9IGkuY2xvc2VzdChgLiR7Zi5DU1MuY2hlY2tib3hDb250YWluZXJ9YCk7XG4gICAgICAgIGEgJiYgYS5jb250YWlucyhpKSAmJiB0aGlzLnRvZ2dsZUNoZWNrYm94KGEpO1xuICAgICAgfVxuICAgIH0pKSA6IG4gPSBjLm1ha2UoXCJ1bFwiLCBbZi5DU1MuY2hlY2tsaXN0LCBmLkNTUy5pdGVtQ2hpbGRyZW5dKSwgbjtcbiAgfVxuICAvKipcbiAgICogUmVkbmVycyBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKiBAcGFyYW0gY29udGVudCAtIGNvbnRlbnQgdXNlZCBpbiBsaXN0IGl0ZW0gcmVuZGVyaW5nXG4gICAqIEBwYXJhbSBtZXRhIC0gbWV0YSBvZiB0aGUgbGlzdCBpdGVtIHVzZWQgaW4gcmVuZGVyaW5nIG9mIHRoZSBjaGVja2xpc3RcbiAgICogQHJldHVybnMgLSBjcmVhdGVkIGh0bWwgbGlzdCBpdGVtIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlckl0ZW0odCwgbikge1xuICAgIGNvbnN0IHIgPSBjLm1ha2UoXCJsaVwiLCBbZi5DU1MuaXRlbSwgZi5DU1MuaXRlbV0pLCBpID0gYy5tYWtlKFwiZGl2XCIsIGYuQ1NTLml0ZW1Db250ZW50LCB7XG4gICAgICBpbm5lckhUTUw6IHQsXG4gICAgICBjb250ZW50RWRpdGFibGU6ICghdGhpcy5yZWFkT25seSkudG9TdHJpbmcoKVxuICAgIH0pLCBhID0gYy5tYWtlKFwic3BhblwiLCBmLkNTUy5jaGVja2JveCksIGwgPSBjLm1ha2UoXCJkaXZcIiwgZi5DU1MuY2hlY2tib3hDb250YWluZXIpO1xuICAgIHJldHVybiBuLmNoZWNrZWQgPT09ICEwICYmIGwuY2xhc3NMaXN0LmFkZChmLkNTUy5pdGVtQ2hlY2tlZCksIGEuaW5uZXJIVE1MID0gQ3QsIGwuYXBwZW5kQ2hpbGQoYSksIHIuYXBwZW5kQ2hpbGQobCksIHIuYXBwZW5kQ2hpbGQoaSksIHI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaXRlbSBjb250ZW50XG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB3cmFwcGVyICg8bGk+KVxuICAgKiBAcmV0dXJucyAtIGl0ZW0gY29udGVudCBzdHJpbmdcbiAgICovXG4gIGdldEl0ZW1Db250ZW50KHQpIHtcbiAgICBjb25zdCBuID0gdC5xdWVyeVNlbGVjdG9yKGAuJHtmLkNTUy5pdGVtQ29udGVudH1gKTtcbiAgICByZXR1cm4gIW4gfHwgYy5pc0VtcHR5KG4pID8gXCJcIiA6IG4uaW5uZXJIVE1MO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbWV0YSBvYmplY3Qgb2YgY2VydGFpbiBlbGVtZW50XG4gICAqIEBwYXJhbSBpdGVtIC0gd2lsbCBiZSByZXR1cm5lZCBtZXRhIGluZm9ybWF0aW9uIG9mIHRoaXMgaXRlbVxuICAgKiBAcmV0dXJucyBJdGVtIG1ldGEgb2JqZWN0XG4gICAqL1xuICBnZXRJdGVtTWV0YSh0KSB7XG4gICAgY29uc3QgbiA9IHQucXVlcnlTZWxlY3RvcihgLiR7Zi5DU1MuY2hlY2tib3hDb250YWluZXJ9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrZWQ6IG4gPyBuLmNsYXNzTGlzdC5jb250YWlucyhmLkNTUy5pdGVtQ2hlY2tlZCkgOiAhMVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCBpdGVtIG1ldGEgdXNlZCBvbiBjcmVhdGlvbiBvZiB0aGUgbmV3IGl0ZW1cbiAgICovXG4gIGNvbXBvc2VEZWZhdWx0TWV0YSgpIHtcbiAgICByZXR1cm4geyBjaGVja2VkOiAhMSB9O1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgY2hlY2tsaXN0IGl0ZW0gc3RhdGVcbiAgICogQHBhcmFtIGNoZWNrYm94IC0gY2hlY2tib3ggZWxlbWVudCB0byBiZSB0b2dnbGVkXG4gICAqL1xuICB0b2dnbGVDaGVja2JveCh0KSB7XG4gICAgdC5jbGFzc0xpc3QudG9nZ2xlKGYuQ1NTLml0ZW1DaGVja2VkKSwgdC5jbGFzc0xpc3QuYWRkKGYuQ1NTLm5vSG92ZXIpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IodCksIHsgb25jZTogITAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2xhc3MgcmVzcG9uc2libGUgZm9yIHNwZWNpYWwgaG92ZXIgYmVoYXZpb3Igb24gYW4gaXRlbVxuICAgKiBAcGFyYW0gZWwgLSBpdGVtIHdyYXBwZXJcbiAgICovXG4gIHJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKHQpIHtcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUoZi5DU1Mubm9Ib3Zlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIFUoZSwgdCA9IFwiYWZ0ZXJcIikge1xuICBjb25zdCBuID0gW107XG4gIGxldCByO1xuICBmdW5jdGlvbiBpKGEpIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgXCJhZnRlclwiOlxuICAgICAgICByZXR1cm4gYS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICBjYXNlIFwiYmVmb3JlXCI6XG4gICAgICAgIHJldHVybiBhLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGZvciAociA9IGkoZSk7IHIgIT09IG51bGw7IClcbiAgICBuLnB1c2gociksIHIgPSBpKHIpO1xuICByZXR1cm4gbi5sZW5ndGggIT09IDAgPyBuIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHkoZSwgdCA9ICEwKSB7XG4gIGxldCBuID0gZTtcbiAgcmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKG0uaXRlbSkgJiYgKG4gPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke20uaXRlbUNoaWxkcmVufWApKSwgbiA9PT0gbnVsbCA/IFtdIDogdCA/IEFycmF5LmZyb20obi5xdWVyeVNlbGVjdG9yQWxsKGA6c2NvcGUgPiAuJHttLml0ZW19YCkpIDogQXJyYXkuZnJvbShuLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke20uaXRlbX1gKSk7XG59XG5mdW5jdGlvbiBscihlKSB7XG4gIHJldHVybiBlLm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNyKGUpIHtcbiAgcmV0dXJuIGUucXVlcnlTZWxlY3RvcihgLiR7bS5pdGVtQ2hpbGRyZW59YCkgIT09IG51bGw7XG59XG5mdW5jdGlvbiBDKGUpIHtcbiAgcmV0dXJuIGUucXVlcnlTZWxlY3RvcihgLiR7bS5pdGVtQ2hpbGRyZW59YCk7XG59XG5mdW5jdGlvbiB6KGUpIHtcbiAgbGV0IHQgPSBlO1xuICBlLmNsYXNzTGlzdC5jb250YWlucyhtLml0ZW0pICYmICh0ID0gQyhlKSksIHQgIT09IG51bGwgJiYgeSh0KS5sZW5ndGggPT09IDAgJiYgdC5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIE4oZSkge1xuICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yKGAuJHttLml0ZW1Db250ZW50fWApO1xufVxuZnVuY3Rpb24gRShlLCB0ID0gITApIHtcbiAgY29uc3QgbiA9IE4oZSk7XG4gIG4gJiYgUC5mb2N1cyhuLCB0KTtcbn1cbmNsYXNzIEsge1xuICAvKipcbiAgICogR2V0dGVyIG1ldGhvZCB0byBnZXQgY3VycmVudCBpdGVtXG4gICAqIEByZXR1cm5zIGN1cnJlbnQgbGlzdCBpdGVtIG9yIG51bGwgaWYgY2FyZXQgcG9zaXRpb24gaXMgbm90IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJdGVtKCkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG4gPSB0LmFuY2hvck5vZGU7XG4gICAgcmV0dXJuICFuIHx8IChPKG4pIHx8IChuID0gbi5wYXJlbnROb2RlKSwgIW4pIHx8ICFPKG4pID8gbnVsbCA6IG4uY2xvc2VzdChgLiR7bS5pdGVtfWApO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIG5lc3RpbmcgbGV2ZWwgb2YgdGhlIGN1cnJlbnQgaXRlbSwgbnVsbCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAgICovXG4gIGdldCBjdXJyZW50SXRlbUxldmVsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIGlmICh0ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG4gPSB0LnBhcmVudE5vZGUsIHIgPSAwO1xuICAgIGZvciAoOyBuICE9PSBudWxsICYmIG4gIT09IHRoaXMubGlzdFdyYXBwZXI7IClcbiAgICAgIE8obikgJiYgbi5jbGFzc0xpc3QuY29udGFpbnMobS5pdGVtKSAmJiAociArPSAxKSwgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gciArIDE7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbiBhbGwgcGFzc2VkIHBhcmFtcyBhbmQgcmVuZGVyZXIgdG8gcmVsZXZhbnQgY2xhc3MgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gcGFyYW1zIC0gdG9vbCBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSBwYXJhbXMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0gcGFyYW1zLnJlYWRPbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKiBAcGFyYW0gcmVuZGVyZXIgLSByZW5kZXJlciBpbnN0YW5jZSBpbml0aWFsaXplZCBpbiB0b29sIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogbiwgYXBpOiByLCByZWFkT25seTogaSwgYmxvY2s6IGEgfSwgbCkge1xuICAgIHRoaXMuY29uZmlnID0gbiwgdGhpcy5kYXRhID0gdCwgdGhpcy5yZWFkT25seSA9IGksIHRoaXMuYXBpID0gciwgdGhpcy5ibG9jayA9IGEsIHRoaXMucmVuZGVyZXIgPSBsO1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgbGlzdCB3aXRoIGNvbnRlbnRzXG4gICAqIEByZXR1cm5zIEZpbGxlZCB3aXRoIGNvbnRlbnQgd3JhcHBlciBlbGVtZW50IG9mIHRoZSBsaXN0XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdFdyYXBwZXIgPSB0aGlzLnJlbmRlcmVyLnJlbmRlcldyYXBwZXIoITApLCB0aGlzLmRhdGEuaXRlbXMubGVuZ3RoID8gdGhpcy5hcHBlbmRJdGVtcyh0aGlzLmRhdGEuaXRlbXMsIHRoaXMubGlzdFdyYXBwZXIpIDogdGhpcy5hcHBlbmRJdGVtcyhcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgbWV0YToge30sXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0aGlzLmxpc3RXcmFwcGVyXG4gICAgKSwgdGhpcy5yZWFkT25seSB8fCB0aGlzLmxpc3RXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImtleWRvd25cIixcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodC5rZXkpIHtcbiAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIHRoaXMuZW50ZXJQcmVzc2VkKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgICAgICAgdGhpcy5iYWNrc3BhY2UodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVGFiXCI6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gdGhpcy5zaGlmdFRhYih0KSA6IHRoaXMuYWRkVGFiKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAhMVxuICAgICksIFwic3RhcnRcIiBpbiB0aGlzLmRhdGEubWV0YSAmJiB0aGlzLmRhdGEubWV0YS5zdGFydCAhPT0gdm9pZCAwICYmIHRoaXMuY2hhbmdlU3RhcnRXaXRoKHRoaXMuZGF0YS5tZXRhLnN0YXJ0KSwgXCJjb3VudGVyVHlwZVwiIGluIHRoaXMuZGF0YS5tZXRhICYmIHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlICE9PSB2b2lkIDAgJiYgdGhpcy5jaGFuZ2VDb3VudGVycyh0aGlzLmRhdGEubWV0YS5jb3VudGVyVHlwZSksIHRoaXMubGlzdFdyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGxpc3QgY29udGVudCBzYXZpbmdcbiAgICogQHBhcmFtIHdyYXBwZXIgLSBvcHRpb25hbCBhcmd1bWVudCB3cmFwcGVyXG4gICAqIEByZXR1cm5zIHdob2xlIGxpc3Qgc2F2ZWQgZGF0YSBpZiB3cmFwcGVyIG5vdCBwYXNzZXMsIG90aGVyd2lzZSB3aWxsIHJldHVybiBkYXRhIG9mIHRoZSBwYXNzZWQgd3JhcHBlclxuICAgKi9cbiAgc2F2ZSh0KSB7XG4gICAgY29uc3QgbiA9IHQgPz8gdGhpcy5saXN0V3JhcHBlciwgciA9IChsKSA9PiB5KGwpLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgZCA9IEMobyksIHUgPSB0aGlzLnJlbmRlcmVyLmdldEl0ZW1Db250ZW50KG8pLCBwID0gdGhpcy5yZW5kZXJlci5nZXRJdGVtTWV0YShvKSwgZyA9IGQgPyByKGQpIDogW107XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB1LFxuICAgICAgICBtZXRhOiBwLFxuICAgICAgICBpdGVtczogZ1xuICAgICAgfTtcbiAgICB9KSwgaSA9IG4gPyByKG4pIDogW107XG4gICAgbGV0IGEgPSB7XG4gICAgICBzdHlsZTogdGhpcy5kYXRhLnN0eWxlLFxuICAgICAgbWV0YToge30sXG4gICAgICBpdGVtczogaVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zdHlsZSA9PT0gXCJvcmRlcmVkXCIgJiYgKGEubWV0YSA9IHtcbiAgICAgIHN0YXJ0OiB0aGlzLmRhdGEubWV0YS5zdGFydCxcbiAgICAgIGNvdW50ZXJUeXBlOiB0aGlzLmRhdGEubWV0YS5jb3VudGVyVHlwZVxuICAgIH0pLCBhO1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBzYW5pdHphdGlvbiBjb25maWcuIEFsbG93IG9ubHkgdGFncyB0aGF0IGFyZSBhbGxvd2VkIGluIHRoZSBUb29sLlxuICAgKiBAcmV0dXJucyAtIGNvbmZpZyB0aGF0IGRldGVybWluZXMgdGFncyBzdXBwb3N0ZWQgYnkgcGFzdGUgaGFuZGxlclxuICAgKiBAdG9kbyAtIHJlZmFjdG9yIGFuZCBtb3ZlIHRvIGxpc3QgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIk9MXCIsIFwiVUxcIiwgXCJMSVwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHNwZWNpZmllZCBob3QgdG8gbWVyZ2UgdHdvIExpc3QgYmxvY2tzLlxuICAgKiBDYWxsZWQgYnkgRWRpdG9yLmpzIGJ5IGJhY2tzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBCbG9ja1xuICAgKlxuICAgKiBDb250ZW50IG9mIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBuZXh0IExpc3Qgd291bGQgYmUgbWVyZ2VkIHdpdGggZGVlcGVzdCBpdGVtIGluIGN1cnJlbnQgbGlzdFxuICAgKiBPdGhlciBpdGVtcyBvZiB0aGUgbmV4dCBMaXN0IHdvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IGxpc3Qgd2l0aG91dCBhbnkgY2hhbmdlcyBpbiBuZXN0aW5nIGxldmVsc1xuICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgb2YgdGhlIHNlY29uZCBsaXN0IHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnRcbiAgICovXG4gIG1lcmdlKHQpIHtcbiAgICBjb25zdCBuID0gdGhpcy5ibG9jay5ob2xkZXIucXVlcnlTZWxlY3RvckFsbChgLiR7bS5pdGVtfWApLCByID0gbltuLmxlbmd0aCAtIDFdLCBpID0gTihyKTtcbiAgICBpZiAociA9PT0gbnVsbCB8fCBpID09PSBudWxsIHx8IChpLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0Lml0ZW1zWzBdLmNvbnRlbnQpLCB0aGlzLmxpc3RXcmFwcGVyID09PSB2b2lkIDApKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB5KHRoaXMubGlzdFdyYXBwZXIpO1xuICAgIGlmIChhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gYVthLmxlbmd0aCAtIDFdO1xuICAgIGxldCBzID0gQyhsKTtcbiAgICBjb25zdCBvID0gdC5pdGVtcy5zaGlmdCgpO1xuICAgIG8gIT09IHZvaWQgMCAmJiAoby5pdGVtcy5sZW5ndGggIT09IDAgJiYgKHMgPT09IG51bGwgJiYgKHMgPSB0aGlzLnJlbmRlcmVyLnJlbmRlcldyYXBwZXIoITEpKSwgdGhpcy5hcHBlbmRJdGVtcyhvLml0ZW1zLCBzKSksIHQuaXRlbXMubGVuZ3RoID4gMCAmJiB0aGlzLmFwcGVuZEl0ZW1zKHQuaXRlbXMsIHRoaXMubGlzdFdyYXBwZXIpKTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCBmcm9tIEVkaXRvci5cbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKiBAdG9kbyAtIHJlZmFjdG9yIGFuZCBtb3ZlIHRvIGxpc3QgaW5zdGFuY2VcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IG4gPSB0LmRldGFpbC5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IHRoaXMucGFzdGVIYW5kbGVyKG4pO1xuICAgIGNvbnN0IHIgPSB0aGlzLmxpc3RXcmFwcGVyO1xuICAgIHIgJiYgci5wYXJlbnROb2RlICYmIHIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5yZW5kZXIoKSwgcik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBVTCwgT0wgYW5kIExJIHRhZ3MgcGFzdGUgYW5kIHJldHVybnMgTGlzdCBkYXRhXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRoYXQgY29udGFpbnMgd2hvbGUgbGlzdFxuICAgKiBAdG9kbyAtIHJlZmFjdG9yIGFuZCBtb3ZlIHRvIGxpc3QgaW5zdGFuY2VcbiAgICovXG4gIHBhc3RlSGFuZGxlcih0KSB7XG4gICAgY29uc3QgeyB0YWdOYW1lOiBuIH0gPSB0O1xuICAgIGxldCByID0gXCJ1bm9yZGVyZWRcIiwgaTtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgXCJPTFwiOlxuICAgICAgICByID0gXCJvcmRlcmVkXCIsIGkgPSBcIm9sXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlVMXCI6XG4gICAgICBjYXNlIFwiTElcIjpcbiAgICAgICAgciA9IFwidW5vcmRlcmVkXCIsIGkgPSBcInVsXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSB7XG4gICAgICBzdHlsZTogcixcbiAgICAgIG1ldGE6IHt9LFxuICAgICAgaXRlbXM6IFtdXG4gICAgfTtcbiAgICByID09PSBcIm9yZGVyZWRcIiAmJiAodGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGUgPSBcIm51bWVyaWNcIiwgdGhpcy5kYXRhLm1ldGEuc3RhcnQgPSAxKTtcbiAgICBjb25zdCBsID0gKHMpID0+IEFycmF5LmZyb20ocy5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gbGlcIikpLm1hcCgoZCkgPT4ge1xuICAgICAgY29uc3QgdSA9IGQucXVlcnlTZWxlY3RvcihgOnNjb3BlID4gJHtpfWApLCBwID0gdSA/IGwodSkgOiBbXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGQuaW5uZXJIVE1MID8/IFwiXCIsXG4gICAgICAgIG1ldGE6IHt9LFxuICAgICAgICBpdGVtczogcFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gYS5pdGVtcyA9IGwodCksIGE7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgb3JkZXJlZCBsaXN0IHN0YXJ0IHByb3BlcnR5IHZhbHVlXG4gICAqIEBwYXJhbSBpbmRleCAtIG5ldyB2YWx1ZSBvZiB0aGUgc3RhcnQgcHJvcGVydHlcbiAgICovXG4gIGNoYW5nZVN0YXJ0V2l0aCh0KSB7XG4gICAgdGhpcy5saXN0V3JhcHBlci5zdHlsZS5zZXRQcm9wZXJ0eShcImNvdW50ZXItcmVzZXRcIiwgYGl0ZW0gJHt0IC0gMX1gKSwgdGhpcy5kYXRhLm1ldGEuc3RhcnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIG9yZGVyZWQgbGlzdCBjb3VudGVyVHlwZSBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0gY291bnRlclR5cGUgLSBuZXcgdmFsdWUgb2YgdGhlIGNvdW50ZXJUeXBlIHZhbHVlXG4gICAqL1xuICBjaGFuZ2VDb3VudGVycyh0KSB7XG4gICAgdGhpcy5saXN0V3JhcHBlci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbGlzdC1jb3VudGVyLXR5cGVcIiwgdCksIHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID0gdDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBFbnRlciBrZXlwcmVzc1xuICAgKiBAcGFyYW0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBlbnRlclByZXNzZWQodCkge1xuICAgIHZhciBzO1xuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIGlmICh0LnN0b3BQcm9wYWdhdGlvbigpLCB0LnByZXZlbnREZWZhdWx0KCksIHQuaXNDb21wb3NpbmcgfHwgbiA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gKChzID0gdGhpcy5yZW5kZXJlcikgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZ2V0SXRlbUNvbnRlbnQobikudHJpbSgpLmxlbmd0aCkgPT09IDAsIGkgPSBuLnBhcmVudE5vZGUgPT09IHRoaXMubGlzdFdyYXBwZXIsIGEgPSBuLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IG51bGwsIGwgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKTtcbiAgICBpZiAoaSAmJiByKVxuICAgICAgaWYgKGxyKG4pICYmICFzcihuKSkge1xuICAgICAgICBhID8gdGhpcy5jb252ZXJ0SXRlbVRvRGVmYXVsdEJsb2NrKGwsICEwKSA6IHRoaXMuY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNwbGl0TGlzdChuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGVsc2UgaWYgKHIpIHtcbiAgICAgIHRoaXMudW5zaGlmdEl0ZW0obik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLnNwbGl0SXRlbShuKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGJhY2tzcGFjZVxuICAgKiBAcGFyYW0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBiYWNrc3BhY2UodCkge1xuICAgIHZhciByO1xuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIGlmIChuICE9PSBudWxsICYmIFAuaXNDYXJldEF0U3RhcnRPZklucHV0KG4pICYmICgociA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaXNDb2xsYXBzZWQpICE9PSAhMSkge1xuICAgICAgaWYgKHQuc3RvcFByb3BhZ2F0aW9uKCksIG4ucGFyZW50Tm9kZSA9PT0gdGhpcy5saXN0V3JhcHBlciAmJiBuLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0Rmlyc3RJdGVtVG9EZWZhdWx0QmxvY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLm1lcmdlSXRlbVdpdGhQcmV2aW91cyhuKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSBpbmRlbnRhdGlvbiBmb3IgY3VycmVudCBpdGVtXG4gICAqIEBwYXJhbSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIHNoaWZ0VGFiKHQpIHtcbiAgICB0LnN0b3BQcm9wYWdhdGlvbigpLCB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuY3VycmVudEl0ZW0gIT09IG51bGwgJiYgdGhpcy51bnNoaWZ0SXRlbSh0aGlzLmN1cnJlbnRJdGVtKTtcbiAgfVxuICAvKipcbiAgICogRGVjcmVhc2UgaW5kZW50YXRpb24gb2YgdGhlIHBhc3NlZCBpdGVtXG4gICAqIEBwYXJhbSBpdGVtIC0gbGlzdCBpdGVtIHRvIGJlIHVuc2hpZnRlZFxuICAgKi9cbiAgdW5zaGlmdEl0ZW0odCkge1xuICAgIGlmICghdC5wYXJlbnROb2RlIHx8ICFPKHQucGFyZW50Tm9kZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHQucGFyZW50Tm9kZS5jbG9zZXN0KGAuJHttLml0ZW19YCk7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCByID0gQyh0KTtcbiAgICBpZiAodC5wYXJlbnRFbGVtZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBVKHQpO1xuICAgIGkgIT09IG51bGwgJiYgKHIgPT09IG51bGwgJiYgKHIgPSB0aGlzLnJlbmRlcmVyLnJlbmRlcldyYXBwZXIoITEpKSwgaS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICByLmFwcGVuZENoaWxkKGEpO1xuICAgIH0pLCB0LmFwcGVuZENoaWxkKHIpKSwgbi5hZnRlcih0KSwgRSh0LCAhMSksIHoobik7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIGxpc3Qgc3BsaXR0aW5nIGFuZCBtb3ZpbmcgdHJhaWxpbmcgaXRlbXMgdG8gdGhlIG5ldyBzZXBhcmF0ZWQgbGlzdFxuICAgKiBAcGFyYW0gaXRlbSAtIGN1cnJlbnQgaXRlbSBodG1sIGVsZW1lbnRcbiAgICovXG4gIHNwbGl0TGlzdCh0KSB7XG4gICAgY29uc3QgbiA9IHkodCksIHIgPSB0aGlzLmJsb2NrLCBpID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCk7XG4gICAgaWYgKG4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBvID0gblswXTtcbiAgICAgIHRoaXMudW5zaGlmdEl0ZW0obyksIEUodCwgITEpO1xuICAgIH1cbiAgICBpZiAodC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBudWxsICYmIHQucGFyZW50Tm9kZSA9PT0gdGhpcy5saXN0V3JhcHBlcikge1xuICAgICAgdGhpcy5jb252ZXJ0SXRlbVRvRGVmYXVsdEJsb2NrKGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhID0gVSh0KTtcbiAgICBpZiAoYSA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gdGhpcy5yZW5kZXJlci5yZW5kZXJXcmFwcGVyKCEwKTtcbiAgICBhLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGwuYXBwZW5kQ2hpbGQobyk7XG4gICAgfSk7XG4gICAgY29uc3QgcyA9IHRoaXMuc2F2ZShsKTtcbiAgICBzLm1ldGEuc3RhcnQgPSB0aGlzLmRhdGEuc3R5bGUgPT0gXCJvcmRlcmVkXCIgPyAxIDogdm9pZCAwLCB0aGlzLmFwaS5ibG9ja3MuaW5zZXJ0KHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubmFtZSwgcywgdGhpcy5jb25maWcsIGkgKyAxKSwgdGhpcy5jb252ZXJ0SXRlbVRvRGVmYXVsdEJsb2NrKGkgKyAxKSwgbC5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgaXMgdXNlZCBmb3Igc3BsaXR0aW5nIGl0ZW0gY29udGVudCBhbmQgbW92aW5nIHRyYWlsaW5nIGNvbnRlbnQgdG8gdGhlIG5ldyBzaWJsaW5nIGl0ZW1cbiAgICogQHBhcmFtIGN1cnJlbnRJdGVtIC0gY3VycmVudCBpdGVtIGh0bWwgZWxlbWVudFxuICAgKi9cbiAgc3BsaXRJdGVtKHQpIHtcbiAgICBjb25zdCBbbiwgcl0gPSBQLmdldENhcmV0Tm9kZUFuZE9mZnNldCgpO1xuICAgIGlmIChuID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBOKHQpO1xuICAgIGxldCBhO1xuICAgIGkgPT09IG51bGwgPyBhID0gXCJcIiA6IGEgPSBQLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlKGksIG4sIHIsIFwicmlnaHRcIiwgITApO1xuICAgIGNvbnN0IGwgPSBDKHQpLCBzID0gdGhpcy5yZW5kZXJJdGVtKGEpO1xuICAgIHQgPT0gbnVsbCB8fCB0LmFmdGVyKHMpLCBsICYmIHMuYXBwZW5kQ2hpbGQobCksIEUocyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIG1lcmdpbmcgY3VycmVudCBpdGVtIHdpdGggcHJldmlvdXMgb25lXG4gICAqIENvbnRlbnQgb2YgdGhlIGN1cnJlbnQgaXRlbSB3b3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgaXRlbVxuICAgKiBDdXJyZW50IGl0ZW0gY2hpbGRyZW4gd291bGQgbm90IGNoYW5nZSBuZXN0aW5nIGxldmVsXG4gICAqIEBwYXJhbSBpdGVtIC0gY3VycmVudCBpdGVtIGh0bWwgZWxlbWVudFxuICAgKi9cbiAgbWVyZ2VJdGVtV2l0aFByZXZpb3VzKHQpIHtcbiAgICBjb25zdCBuID0gdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCByID0gdC5wYXJlbnROb2RlO1xuICAgIGlmIChyID09PSBudWxsIHx8ICFPKHIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSByLmNsb3Nlc3QoYC4ke20uaXRlbX1gKTtcbiAgICBpZiAoIW4gJiYgIWkgfHwgbiAmJiAhTyhuKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYTtcbiAgICBpZiAobikge1xuICAgICAgY29uc3QgcCA9IHkobiwgITEpO1xuICAgICAgcC5sZW5ndGggIT09IDAgJiYgcC5sZW5ndGggIT09IDAgPyBhID0gcFtwLmxlbmd0aCAtIDFdIDogYSA9IG47XG4gICAgfSBlbHNlXG4gICAgICBhID0gaTtcbiAgICBjb25zdCBsID0gdGhpcy5yZW5kZXJlci5nZXRJdGVtQ29udGVudCh0KTtcbiAgICBpZiAoIWEpXG4gICAgICByZXR1cm47XG4gICAgRShhLCAhMSk7XG4gICAgY29uc3QgcyA9IE4oYSk7XG4gICAgaWYgKHMgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgcy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgbCk7XG4gICAgY29uc3QgbyA9IHkodCk7XG4gICAgaWYgKG8ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0LnJlbW92ZSgpLCB6KGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkID0gbiB8fCBpLCB1ID0gQyhkKSA/PyB0aGlzLnJlbmRlcmVyLnJlbmRlcldyYXBwZXIoITEpO1xuICAgIG4gPyBvLmZvckVhY2goKHApID0+IHtcbiAgICAgIHUuYXBwZW5kQ2hpbGQocCk7XG4gICAgfSkgOiBvLmZvckVhY2goKHApID0+IHtcbiAgICAgIHUucHJlcGVuZChwKTtcbiAgICB9KSwgQyhkKSA9PT0gbnVsbCAmJiBhLmFwcGVuZENoaWxkKHUpLCB0LnJlbW92ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgaW5kZW50YXRpb24gdG8gY3VycmVudCBpdGVtXG4gICAqIEBwYXJhbSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGFkZFRhYih0KSB7XG4gICAgdmFyIGE7XG4gICAgdC5zdG9wUHJvcGFnYXRpb24oKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoKChhID0gdGhpcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBhLm1heExldmVsKSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBsID0gdGhpcy5jdXJyZW50SXRlbUxldmVsO1xuICAgICAgaWYgKGwgIT09IG51bGwgJiYgbCA9PT0gdGhpcy5jb25maWcubWF4TGV2ZWwpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IG4ucHJldmlvdXNTaWJsaW5nO1xuICAgIGlmIChyID09PSBudWxsIHx8ICFPKHIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBDKHIpO1xuICAgIGlmIChpKVxuICAgICAgaS5hcHBlbmRDaGlsZChuKSwgeShuKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIGkuYXBwZW5kQ2hpbGQocyk7XG4gICAgICB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLnJlbmRlcmVyLnJlbmRlcldyYXBwZXIoITEpO1xuICAgICAgbC5hcHBlbmRDaGlsZChuKSwgeShuKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGwuYXBwZW5kQ2hpbGQobyk7XG4gICAgICB9KSwgci5hcHBlbmRDaGlsZChsKTtcbiAgICB9XG4gICAgeihuKSwgRShuLCAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgY3VycmVudCBpdGVtIHRvIGRlZmF1bHQgYmxvY2sgd2l0aCBwYXNzZWQgaW5kZXhcbiAgICogQHBhcmFtIG5ld0Jsb3hrSW5kZXggLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50cyBpbmRleCwgd2hlcmUgd291bGQgYmUgaW5zZXRlZCBkZWZhdWx0IGJsb2NrXG4gICAqIEBwYXJhbSByZW1vdmVMaXN0IC0gb3B0aW9uYWwgcGFyYW1ldGVyLCB0aGF0IHJlcHJlc2VudHMgY29uZGl0aW9uLCBpZiBMaXN0IHNob3VsZCBiZSByZW1vdmVkXG4gICAqL1xuICBjb252ZXJ0SXRlbVRvRGVmYXVsdEJsb2NrKHQsIG4pIHtcbiAgICBsZXQgcjtcbiAgICBjb25zdCBpID0gdGhpcy5jdXJyZW50SXRlbSwgYSA9IGkgIT09IG51bGwgPyB0aGlzLnJlbmRlcmVyLmdldEl0ZW1Db250ZW50KGkpIDogXCJcIjtcbiAgICBuID09PSAhMCAmJiB0aGlzLmFwaS5ibG9ja3MuZGVsZXRlKCksIHQgIT09IHZvaWQgMCA/IHIgPSB0aGlzLmFwaS5ibG9ja3MuaW5zZXJ0KHZvaWQgMCwgeyB0ZXh0OiBhIH0sIHZvaWQgMCwgdCkgOiByID0gdGhpcy5hcGkuYmxvY2tzLmluc2VydCgpLCBpID09IG51bGwgfHwgaS5yZW1vdmUoKSwgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayhyLCBcInN0YXJ0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGZpcnN0IGl0ZW0gb2YgdGhlIGxpc3QgdG8gZGVmYXVsdCBibG9ja1xuICAgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSBjYWxsZWQgd2hlbiBiYWNrc3BhY2UgYnV0dG9uIHByZXNzZWQgYXQgc3RhcnQgb2YgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIGxpc3RcbiAgICogRmlyc3QgaXRlbSBvZiB0aGUgbGlzdCB3b3VsZCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHBhcmFncmFwaCBhbmQgZmlyc3QgaXRlbSBjaGlsZHJlbiB3b3VsZCBiZSB1bnNoaWZ0ZWRcbiAgICovXG4gIGNvbnZlcnRGaXJzdEl0ZW1Ub0RlZmF1bHRCbG9jaygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICBpZiAodCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0geSh0KTtcbiAgICBpZiAobi5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IGwgPSBuWzBdO1xuICAgICAgdGhpcy51bnNoaWZ0SXRlbShsKSwgRSh0KTtcbiAgICB9XG4gICAgY29uc3QgciA9IFUodCksIGkgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgYSA9IHIgPT09IG51bGw7XG4gICAgdGhpcy5jb252ZXJ0SXRlbVRvRGVmYXVsdEJsb2NrKGksIGEpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBjYWxscyByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIHJlbmRlcmVyIHdpdGggYSBuZWNlc3NhcnkgaXRlbSBtZXRhIGNhc3RcbiAgICogQHBhcmFtIGl0ZW1Db250ZW50IC0gY29udGVudCB0byBiZSByZW5kZXJlZCBpbiBuZXcgaXRlbVxuICAgKiBAcGFyYW0gbWV0YSAtIG1ldGEgdXNlZCBpbiBsaXN0IGl0ZW0gcmVuZGVyaW5nXG4gICAqIEByZXR1cm5zIGh0bWwgZWxlbWVudCBvZiB0aGUgcmVuZGVyZWQgaXRlbVxuICAgKi9cbiAgcmVuZGVySXRlbSh0LCBuKSB7XG4gICAgY29uc3QgciA9IG4gPz8gdGhpcy5yZW5kZXJlci5jb21wb3NlRGVmYXVsdE1ldGEoKTtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIHRoaXMucmVuZGVyZXIgaW5zdGFuY2VvZiB2OlxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXJJdGVtKHQsIHIpO1xuICAgICAgY2FzZSB0aGlzLnJlbmRlcmVyIGluc3RhbmNlb2YgYjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVySXRlbSh0LCByKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlckl0ZW0odCwgcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIGNoaWxkcmVuIGxpc3RcbiAgICogQHBhcmFtIGl0ZW1zIC0gbGlzdCBkYXRhIHVzZWQgaW4gaXRlbSByZW5kZXJpbmdcbiAgICogQHBhcmFtIHBhcmVudEVsZW1lbnQgLSB3aGVyZSB0byBhcHBlbmQgcGFzc2VkIGl0ZW1zXG4gICAqL1xuICBhcHBlbmRJdGVtcyh0LCBuKSB7XG4gICAgdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnJlbmRlckl0ZW0oci5jb250ZW50LCByLm1ldGEpO1xuICAgICAgaWYgKG4uYXBwZW5kQ2hpbGQoaSksIHIuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGwgPSAoYSA9IHRoaXMucmVuZGVyZXIpID09IG51bGwgPyB2b2lkIDAgOiBhLnJlbmRlcldyYXBwZXIoITEpO1xuICAgICAgICB0aGlzLmFwcGVuZEl0ZW1zKHIuaXRlbXMsIGwpLCBpLmFwcGVuZENoaWxkKGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBJID0ge1xuICB3cmFwcGVyOiBgJHtofS1zdGFydC13aXRoLWZpZWxkYCxcbiAgaW5wdXQ6IGAke2h9LXN0YXJ0LXdpdGgtZmllbGRfX2lucHV0YCxcbiAgc3RhcnRXaXRoRWxlbWVudFdyYXBwZXJJbnZhbGlkOiBgJHtofS1zdGFydC13aXRoLWZpZWxkLS1pbnZhbGlkYFxufTtcbmZ1bmN0aW9uIG9yKGUsIHsgdmFsdWU6IHQsIHBsYWNlaG9sZGVyOiBuLCBhdHRyaWJ1dGVzOiByLCBzYW5pdGl6ZTogaSB9KSB7XG4gIGNvbnN0IGEgPSBjLm1ha2UoXCJkaXZcIiwgSS53cmFwcGVyKSwgbCA9IGMubWFrZShcImlucHV0XCIsIEkuaW5wdXQsIHtcbiAgICBwbGFjZWhvbGRlcjogbixcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHByZXZlbnQgZm9jdXNpbmcgb24gdGhlIGlucHV0IGJ5IFRhYiBrZXlcbiAgICAgKiAoUG9wb3ZlciBpbiB0aGUgVG9vbGJhciBsYXlzIGJlbG93IHRoZSBibG9ja3MsXG4gICAgICogc28gVGFiIGluIHRoZSBsYXN0IGJsb2NrIHdpbGwgZm9jdXMgdGhpcyBoaWRkZW4gaW5wdXQgaWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0KVxuICAgICAqL1xuICAgIHRhYkluZGV4OiAtMSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgc3RhcnQgcHJvcGVydHksIGlmIGl0IGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gaXQgaXMgc2V0IHRvIG9uZVxuICAgICAqL1xuICAgIHZhbHVlOiB0XG4gIH0pO1xuICBmb3IgKGNvbnN0IHMgaW4gcilcbiAgICBsLnNldEF0dHJpYnV0ZShzLCByW3NdKTtcbiAgcmV0dXJuIGEuYXBwZW5kQ2hpbGQobCksIGwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IHtcbiAgICBpICE9PSB2b2lkIDAgJiYgKGwudmFsdWUgPSBpKGwudmFsdWUpKTtcbiAgICBjb25zdCBzID0gbC5jaGVja1ZhbGlkaXR5KCk7XG4gICAgIXMgJiYgIWEuY2xhc3NMaXN0LmNvbnRhaW5zKEkuc3RhcnRXaXRoRWxlbWVudFdyYXBwZXJJbnZhbGlkKSAmJiBhLmNsYXNzTGlzdC5hZGQoSS5zdGFydFdpdGhFbGVtZW50V3JhcHBlckludmFsaWQpLCBzICYmIGEuY2xhc3NMaXN0LmNvbnRhaW5zKEkuc3RhcnRXaXRoRWxlbWVudFdyYXBwZXJJbnZhbGlkKSAmJiBhLmNsYXNzTGlzdC5yZW1vdmUoSS5zdGFydFdpdGhFbGVtZW50V3JhcHBlckludmFsaWQpLCBzICYmIGUobC52YWx1ZSk7XG4gIH0pLCBhO1xufVxuY29uc3QgTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBkZWZhdWx0IGFyYWJpYyBudW1iZXJzIGZvciBjb3VudGVyc1xuICAgKi9cbiAgW1wiTnVtZXJpY1wiLCBcIm51bWVyaWNcIl0sXG4gIC8qKlxuICAgKiBWYWx1ZSB0aGF0IHJlcHJlc2VudHMgbG93ZXIgcm9tYW4gbnVtYmVycyBmb3IgY291bnRlcmVzXG4gICAqL1xuICBbXCJMb3dlciBSb21hblwiLCBcImxvd2VyLXJvbWFuXCJdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIHVwcGVyIHJvbWFuIG51bWJlcnMgZm9yIGNvdW50ZXJzXG4gICAqL1xuICBbXCJVcHBlciBSb21hblwiLCBcInVwcGVyLXJvbWFuXCJdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIGxvd2VyIGFscGhhIGNoYXJhY3RlcnMgZm9yIGNvdW50ZXJzXG4gICAqL1xuICBbXCJMb3dlciBBbHBoYVwiLCBcImxvd2VyLWFscGhhXCJdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIHVwcGVyIGFscGhhIGNoYXJhY3RlcnMgZm9yIGNvdW50ZXJzXG4gICAqL1xuICBbXCJVcHBlciBBbHBoYVwiLCBcInVwcGVyLWFscGhhXCJdXG5dKSwgSGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIC8qKlxuICAgKiBWYWx1ZSB0aGF0IHJlcHJlc2VudHMgSWNvbiBmb3IgTnVtZXJpYyBjb3VudGVyIHR5cGVcbiAgICovXG4gIFtcIm51bWVyaWNcIiwgU3RdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIEljb24gZm9yIExvd2VyIFJvbWFuIGNvdW50ZXIgdHlwZVxuICAgKi9cbiAgW1wibG93ZXItcm9tYW5cIiwgT3RdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIEljb24gZm9yIFVwcGVyIFJvbWFuIGNvdW50ZXIgdHlwZVxuICAgKi9cbiAgW1widXBwZXItcm9tYW5cIiwga3RdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIEljb24gZm9yIExvd2VyIEFscGhhIGNvdW50ZXIgdHlwZVxuICAgKi9cbiAgW1wibG93ZXItYWxwaGFcIiwgRXRdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIEljb24gZm9yIFVwcGVyIEFscGhhIGNvdW50ZXIgdHlwZVxuICAgKi9cbiAgW1widXBwZXItYWxwaGFcIiwgX3RdXG5dKTtcbmZ1bmN0aW9uIHVyKGUpIHtcbiAgcmV0dXJuIGUucmVwbGFjZSgvXFxEKy9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGNyKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlLml0ZW1zWzBdID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBkcihlKSB7XG4gIHJldHVybiAhKFwibWV0YVwiIGluIGUpO1xufVxuZnVuY3Rpb24gZnIoZSkge1xuICByZXR1cm4gdHlwZW9mIGUuaXRlbXNbMF0gIT0gXCJzdHJpbmdcIiAmJiBcInRleHRcIiBpbiBlLml0ZW1zWzBdICYmIFwiY2hlY2tlZFwiIGluIGUuaXRlbXNbMF0gJiYgdHlwZW9mIGUuaXRlbXNbMF0udGV4dCA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlLml0ZW1zWzBdLmNoZWNrZWQgPT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBwcihlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcmV0dXJuIGNyKGUpID8gKGUuaXRlbXMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQucHVzaCh7XG4gICAgICBjb250ZW50OiBuLFxuICAgICAgbWV0YToge30sXG4gICAgICBpdGVtczogW11cbiAgICB9KTtcbiAgfSksIHtcbiAgICBzdHlsZTogZS5zdHlsZSxcbiAgICBtZXRhOiB7fSxcbiAgICBpdGVtczogdFxuICB9KSA6IGZyKGUpID8gKGUuaXRlbXMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQucHVzaCh7XG4gICAgICBjb250ZW50OiBuLnRleHQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIGNoZWNrZWQ6IG4uY2hlY2tlZFxuICAgICAgfSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH0pO1xuICB9KSwge1xuICAgIHN0eWxlOiBcImNoZWNrbGlzdFwiLFxuICAgIG1ldGE6IHt9LFxuICAgIGl0ZW1zOiB0XG4gIH0pIDogZHIoZSkgPyB7XG4gICAgc3R5bGU6IGUuc3R5bGUsXG4gICAgbWV0YToge30sXG4gICAgaXRlbXM6IGUuaXRlbXNcbiAgfSA6IGU7XG59XG5jbGFzcyBHIHtcbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byB1c2UgbmF0aXZlIEVudGVyIGJlaGF2aW91clxuICAgKi9cbiAgc3RhdGljIGdldCBlbmFibGVMaW5lQnJlYWtzKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWNvbjogJGUsXG4gICAgICAgIHRpdGxlOiBcIlVub3JkZXJlZCBMaXN0XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdHlsZTogXCJ1bm9yZGVyZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpY29uOiBCZSxcbiAgICAgICAgdGl0bGU6IFwiT3JkZXJlZCBMaXN0XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdHlsZTogXCJvcmRlcmVkXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWNvbjogQWUsXG4gICAgICAgIHRpdGxlOiBcIkNoZWNrbGlzdFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3R5bGU6IFwiY2hlY2tsaXN0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIHNhbml0emF0aW9uIGNvbmZpZy4gQWxsb3cgb25seSB0YWdzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFRvb2wuXG4gICAqIEByZXR1cm5zIC0gcGFzdGUgY29uZmlnIG9iamVjdCB1c2VkIGluIGVkaXRvclxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiT0xcIiwgXCJVTFwiLCBcIkxJXCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmcm9tIHRleHQgdG8gbGlzdCB3aXRoIGltcG9ydCBhbmQgZXhwb3J0IGxpc3QgdG8gdGV4dFxuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6ICh0KSA9PiBHLmpvaW5SZWN1cnNpdmUodCksXG4gICAgICBpbXBvcnQ6ICh0LCBuKSA9PiAoe1xuICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250ZW50OiB0LFxuICAgICAgICAgICAgbWV0YToge30sXG4gICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0eWxlOiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5kZWZhdWx0U3R5bGUpICE9PSB2b2lkIDAgPyBuLmRlZmF1bHRTdHlsZSA6IFwidW5vcmRlcmVkXCJcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGxpc3Qgc3R5bGUgbmFtZVxuICAgKi9cbiAgZ2V0IGxpc3RTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0eWxlIHx8IHRoaXMuZGVmYXVsdExpc3RTdHlsZTtcbiAgfVxuICAvKipcbiAgICogU2V0IGxpc3Qgc3R5bGVcbiAgICogQHBhcmFtIHN0eWxlIC0gbmV3IHN0eWxlIHRvIHNldFxuICAgKi9cbiAgc2V0IGxpc3RTdHlsZSh0KSB7XG4gICAgdmFyIHI7XG4gICAgdGhpcy5kYXRhLnN0eWxlID0gdCwgdGhpcy5jaGFuZ2VUYWJ1bGF0b3JCeVN0eWxlKCk7XG4gICAgY29uc3QgbiA9IHRoaXMubGlzdC5yZW5kZXIoKTtcbiAgICAociA9IHRoaXMubGlzdEVsZW1lbnQpID09IG51bGwgfHwgci5yZXBsYWNlV2l0aChuKSwgdGhpcy5saXN0RWxlbWVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBwYXJhbXMgLSB0b29sIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHBhcmFtcy5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSBwYXJhbXMucmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogbiwgYXBpOiByLCByZWFkT25seTogaSwgYmxvY2s6IGEgfSkge1xuICAgIHZhciBzO1xuICAgIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IGksIHRoaXMuY29uZmlnID0gbiwgdGhpcy5ibG9jayA9IGEsIHRoaXMuZGVmYXVsdExpc3RTdHlsZSA9ICgocyA9IHRoaXMuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZWZhdWx0U3R5bGUpIHx8IFwidW5vcmRlcmVkXCI7XG4gICAgY29uc3QgbCA9IHtcbiAgICAgIHN0eWxlOiB0aGlzLmRlZmF1bHRMaXN0U3R5bGUsXG4gICAgICBtZXRhOiB7fSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmtleXModCkubGVuZ3RoID8gcHIodCkgOiBsLCB0aGlzLmxpc3RTdHlsZSA9PT0gXCJvcmRlcmVkXCIgJiYgdGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGUgPT09IHZvaWQgMCAmJiAodGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGUgPSBcIm51bWVyaWNcIiksIHRoaXMuY2hhbmdlVGFidWxhdG9yQnlTdHlsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gbGlzdCB0byB0ZXh0IGZvciBjb252ZXJzaW9uQ29uZmlnXG4gICAqIEBwYXJhbSBkYXRhIC0gY3VycmVudCBkYXRhIG9mIHRoZSBsaXN0XG4gICAqIEByZXR1cm5zIC0gc3RyaW5nIG9mIHRoZSByZWN1cnNpdmVseSBtZXJnZWQgY29udGVudHMgb2YgdGhlIGl0ZW1zIG9mIHRoZSBsaXN0XG4gICAqL1xuICBzdGF0aWMgam9pblJlY3Vyc2l2ZSh0KSB7XG4gICAgcmV0dXJuIHQuaXRlbXMubWFwKChuKSA9PiBgJHtuLmNvbnRlbnR9ICR7Ry5qb2luUmVjdXJzaXZlKG4pfWApLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbnRlbnQgcmVuZGVyaW5nXG4gICAqIEByZXR1cm5zIHJlbmRlcmVkIGxpc3Qgd3JhcHBlciB3aXRoIGFsbCBjb250ZW50c1xuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3RFbGVtZW50ID0gdGhpcy5saXN0LnJlbmRlcigpLCB0aGlzLmxpc3RFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb250ZW50IHNhdmluZ1xuICAgKiBAcmV0dXJucyBmb3JtYXR0ZWQgY29udGVudCB1c2VkIGluIGVkaXRvclxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhID0gdGhpcy5saXN0LnNhdmUoKSwgdGhpcy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtZXJnaW5kIHR3byBsaXN0cyBpbnRvIG9uZVxuICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgb2YgdGhlIG5leHQgc3RhbmRpbmcgbGlzdCwgdGhhdCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggY3VycmVudFxuICAgKi9cbiAgbWVyZ2UodCkge1xuICAgIHRoaXMubGlzdC5tZXJnZSh0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBCbG9jayBUdW5lIGFsbG93aW5nIHRvIGNoYW5nZSB0aGUgbGlzdCBzdHlsZVxuICAgKiBAcmV0dXJucyBhcnJheSBvZiB0dW5lIGNvbmZpZ3NcbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIGNvbnN0IHQgPSBbXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJVbm9yZGVyZWRcIiksXG4gICAgICAgIGljb246ICRlLFxuICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5saXN0U3R5bGUgPT0gXCJ1bm9yZGVyZWRcIixcbiAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4ge1xuICAgICAgICAgIHRoaXMubGlzdFN0eWxlID0gXCJ1bm9yZGVyZWRcIjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIk9yZGVyZWRcIiksXG4gICAgICAgIGljb246IEJlLFxuICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5saXN0U3R5bGUgPT0gXCJvcmRlcmVkXCIsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IFwib3JkZXJlZFwiO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiQ2hlY2tsaXN0XCIpLFxuICAgICAgICBpY29uOiBBZSxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMubGlzdFN0eWxlID09IFwiY2hlY2tsaXN0XCIsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IFwiY2hlY2tsaXN0XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICAgIGlmICh0aGlzLmxpc3RTdHlsZSA9PT0gXCJvcmRlcmVkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSBvcihcbiAgICAgICAgKGEpID0+IHRoaXMuY2hhbmdlU3RhcnRXaXRoKE51bWJlcihhKSksXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogU3RyaW5nKHRoaXMuZGF0YS5tZXRhLnN0YXJ0ID8/IDEpLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBcInRydWVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2FuaXRpemU6IChhKSA9PiB1cihhKVxuICAgICAgICB9XG4gICAgICApLCByID0gW1xuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIlN0YXJ0IHdpdGhcIiksXG4gICAgICAgICAgaWNvbjogSXQsXG4gICAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHMoMjgyMCkgY2FuIG5vdCB1c2UgUG9wb3Zlckl0ZW0gZW51bSBmcm9tIGVkaXRvci5qcyB0eXBlc1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaHRtbFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sIGkgPSB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJDb3VudGVyIHR5cGVcIiksXG4gICAgICAgIGljb246IEhlLmdldCh0aGlzLmRhdGEubWV0YS5jb3VudGVyVHlwZSksXG4gICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBMLmZvckVhY2goKGEsIGwpID0+IHtcbiAgICAgICAgaS5jaGlsZHJlbi5pdGVtcy5wdXNoKHtcbiAgICAgICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KGwpLFxuICAgICAgICAgIGljb246IEhlLmdldChMLmdldChsKSksXG4gICAgICAgICAgaXNBY3RpdmU6IHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID09PSBMLmdldChsKSxcbiAgICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlQ291bnRlcnMoTC5nZXQobCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgdC5wdXNoKHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9LCAuLi5yLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgZnJvbSBFZGl0b3IuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IHsgdGFnTmFtZTogbiB9ID0gdC5kZXRhaWwuZGF0YTtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgXCJPTFwiOlxuICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IFwib3JkZXJlZFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVTFwiOlxuICAgICAgY2FzZSBcIkxJXCI6XG4gICAgICAgIHRoaXMubGlzdFN0eWxlID0gXCJ1bm9yZGVyZWRcIjtcbiAgICB9XG4gICAgdGhpcy5saXN0Lm9uUGFzdGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBVTCwgT0wgYW5kIExJIHRhZ3MgcGFzdGUgYW5kIHJldHVybnMgTGlzdCBkYXRhXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRoYXQgY29udGFpbnMgd2hvbGUgbGlzdFxuICAgKi9cbiAgcGFzdGVIYW5kbGVyKHQpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0LnBhc3RlSGFuZGxlcih0KTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBvcmRlcmVkIGxpc3QgY291bnRlclR5cGUgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIGNvdW50ZXJUeXBlIC0gbmV3IHZhbHVlIG9mIHRoZSBjb3VudGVyVHlwZSB2YWx1ZVxuICAgKi9cbiAgY2hhbmdlQ291bnRlcnModCkge1xuICAgIHZhciBuO1xuICAgIChuID0gdGhpcy5saXN0KSA9PSBudWxsIHx8IG4uY2hhbmdlQ291bnRlcnModCksIHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID0gdDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBvcmRlcmVkIGxpc3Qgc3RhcnQgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIGluZGV4IC0gbmV3IHZhbHVlIG9mIHRoZSBzdGFydCBwcm9wZXJ0eVxuICAgKi9cbiAgY2hhbmdlU3RhcnRXaXRoKHQpIHtcbiAgICB2YXIgbjtcbiAgICAobiA9IHRoaXMubGlzdCkgPT0gbnVsbCB8fCBuLmNoYW5nZVN0YXJ0V2l0aCh0KSwgdGhpcy5kYXRhLm1ldGEuc3RhcnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2hhbmdpbmcgdGFidWxhdG9yIHJlc3BlY3RmdWxseSB0byBwYXNzZWQgc3R5bGVcbiAgICovXG4gIGNoYW5nZVRhYnVsYXRvckJ5U3R5bGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLmxpc3RTdHlsZSkge1xuICAgICAgY2FzZSBcIm9yZGVyZWRcIjpcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IEsoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMucmVhZE9ubHksXG4gICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGJsb2NrOiB0aGlzLmJsb2NrXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuZXcgdih0aGlzLnJlYWRPbmx5LCB0aGlzLmNvbmZpZylcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidW5vcmRlcmVkXCI6XG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBLKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0aGlzLnJlYWRPbmx5LFxuICAgICAgICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBibG9jazogdGhpcy5ibG9ja1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3IGIodGhpcy5yZWFkT25seSwgdGhpcy5jb25maWcpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNoZWNrbGlzdFwiOlxuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgSyhcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZWFkT25seTogdGhpcy5yZWFkT25seSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYmxvY2s6IHRoaXMuYmxvY2tcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5ldyBmKHRoaXMucmVhZE9ubHksIHRoaXMuY29uZmlnKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEcgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/list/dist/editorjs-list.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@editorjs/raw/dist/raw.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@editorjs/raw/dist/raw.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ s)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-rawtool__textarea{min-height:200px;resize:vertical;border-radius:8px;border:0;background-color:#1e2128;font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:12px;line-height:1.6;letter-spacing:-.2px;color:#a1a7b6;overscroll-behavior:contain}\")),document.head.appendChild(e)}}catch(o){console.error(\"vite-plugin-css-injected-by-js\",o)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M16.6954 5C17.912 5 18.8468 6.07716 18.6755 7.28165L17.426 16.0659C17.3183 16.8229 16.7885 17.4522 16.061 17.6873L12.6151 18.8012C12.2152 18.9304 11.7848 18.9304 11.3849 18.8012L7.93898 17.6873C7.21148 17.4522 6.6817 16.8229 6.57403 16.0659L5.32454 7.28165C5.15322 6.07716 6.088 5 7.30461 5H16.6954Z\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 8.4H9L9.42857 11.7939H14.5714L14.3571 13.2788L14.1429 14.7636L12 15.4L9.85714 14.7636L9.77143 14.3394\"/></svg>';\n/**\n * Raw HTML Tool for CodeX Editor\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass s {\n  /**\n   * Notify core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Should this tool be displayed at the Editor's Toolbox\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get displayInToolbox() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the RawTool textarea\n   *\n   * @returns {boolean}\n   * @public\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: a,\n      title: \"Raw HTML\"\n    };\n  }\n  /**\n   * @typedef {object} RawData — plugin saved data\n   * @param {string} html - previously saved HTML code\n   * @property\n   */\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {RawData} data — previously saved HTML data\n   * @param {object} config - user config for Tool\n   * @param {object} api - CodeX Editor API\n   * @param {boolean} readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: e, api: r, readOnly: i }) {\n    this.api = r, this.readOnly = i, this.placeholder = r.i18n.t(e.placeholder || s.DEFAULT_PLACEHOLDER), this.CSS = {\n      baseClass: this.api.styles.block,\n      input: this.api.styles.input,\n      wrapper: \"ce-rawtool\",\n      textarea: \"ce-rawtool__textarea\"\n    }, this.data = {\n      html: t.html || \"\"\n    }, this.textarea = null, this.resizeDebounce = null;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement} this.element - RawTool's wrapper\n   * @public\n   */\n  render() {\n    const t = document.createElement(\"div\"), e = 100;\n    return this.textarea = document.createElement(\"textarea\"), t.classList.add(this.CSS.baseClass, this.CSS.wrapper), this.textarea.classList.add(this.CSS.textarea, this.CSS.input), this.textarea.textContent = this.data.html, this.textarea.placeholder = this.placeholder, this.readOnly ? this.textarea.disabled = !0 : this.textarea.addEventListener(\"input\", () => {\n      this.onInput();\n    }), t.appendChild(this.textarea), setTimeout(() => {\n      this.resize();\n    }, e), t;\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} rawToolsWrapper - RawTool's wrapper, containing textarea with raw HTML code\n   * @returns {RawData} - raw HTML code\n   * @public\n   */\n  save(t) {\n    return {\n      html: t.querySelector(\"textarea\").value\n    };\n  }\n  /**\n   * Default placeholder for RawTool's textarea\n   *\n   * @public\n   * @returns {string}\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"Enter HTML code\";\n  }\n  /**\n   * Automatic sanitize config\n   */\n  static get sanitize() {\n    return {\n      html: !0\n      // Allow HTML tags\n    };\n  }\n  /**\n   * Textarea change event\n   *\n   * @returns {void}\n   */\n  onInput() {\n    this.resizeDebounce && clearTimeout(this.resizeDebounce), this.resizeDebounce = setTimeout(() => {\n      this.resize();\n    }, 200);\n  }\n  /**\n   * Resize textarea to fit whole height\n   *\n   * @returns {void}\n   */\n  resize() {\n    this.textarea.style.height = \"auto\", this.textarea.style.height = this.textarea.scrollHeight + \"px\";\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3Jhdy9kaXN0L3Jhdy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MsNkRBQTZELGlCQUFpQixnQkFBZ0Isa0JBQWtCLFNBQVMseUJBQXlCLHdEQUF3RCxlQUFlLGdCQUFnQixxQkFBcUIsY0FBYyw0QkFBNEIsa0NBQWtDLFNBQVMsbURBQW1EO0FBQ2plO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3Jhdy9kaXN0L3Jhdy5tanM/NTM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1yYXd0b29sX190ZXh0YXJlYXttaW4taGVpZ2h0OjIwMHB4O3Jlc2l6ZTp2ZXJ0aWNhbDtib3JkZXItcmFkaXVzOjhweDtib3JkZXI6MDtiYWNrZ3JvdW5kLWNvbG9yOiMxZTIxMjg7Zm9udC1mYW1pbHk6TWVubG8sTW9uYWNvLENvbnNvbGFzLENvdXJpZXIgTmV3LG1vbm9zcGFjZTtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxLjY7bGV0dGVyLXNwYWNpbmc6LS4ycHg7Y29sb3I6I2ExYTdiNjtvdmVyc2Nyb2xsLWJlaGF2aW9yOmNvbnRhaW59XCIpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaChvKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsbyl9fSkoKTtcbmNvbnN0IGEgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYuNjk1NCA1QzE3LjkxMiA1IDE4Ljg0NjggNi4wNzcxNiAxOC42NzU1IDcuMjgxNjVMMTcuNDI2IDE2LjA2NTlDMTcuMzE4MyAxNi44MjI5IDE2Ljc4ODUgMTcuNDUyMiAxNi4wNjEgMTcuNjg3M0wxMi42MTUxIDE4LjgwMTJDMTIuMjE1MiAxOC45MzA0IDExLjc4NDggMTguOTMwNCAxMS4zODQ5IDE4LjgwMTJMNy45Mzg5OCAxNy42ODczQzcuMjExNDggMTcuNDUyMiA2LjY4MTcgMTYuODIyOSA2LjU3NDAzIDE2LjA2NTlMNS4zMjQ1NCA3LjI4MTY1QzUuMTUzMjIgNi4wNzcxNiA2LjA4OCA1IDcuMzA0NjEgNUgxNi42OTU0WlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNSA4LjRIOUw5LjQyODU3IDExLjc5MzlIMTQuNTcxNEwxNC4zNTcxIDEzLjI3ODhMMTQuMTQyOSAxNC43NjM2TDEyIDE1LjRMOS44NTcxNCAxNC43NjM2TDkuNzcxNDMgMTQuMzM5NFwiLz48L3N2Zz4nO1xuLyoqXG4gKiBSYXcgSFRNTCBUb29sIGZvciBDb2RlWCBFZGl0b3JcbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGNvZGV4LnNvKVxuICogQGNvcHlyaWdodCBDb2RlWCAyMDE4XG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuY2xhc3MgcyB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIFNob3VsZCB0aGlzIHRvb2wgYmUgZGlzcGxheWVkIGF0IHRoZSBFZGl0b3IncyBUb29sYm94XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRpc3BsYXlJblRvb2xib3goKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byBwcmVzcyBFbnRlciBpbnNpZGUgdGhlIFJhd1Rvb2wgdGV4dGFyZWFcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBnZXQgZW5hYmxlTGluZUJyZWFrcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUb29sIHRvb2xib3ggc2V0dGluZ3NcbiAgICogaWNvbiAtIFRvb2wgaWNvbidzIFNWR1xuICAgKiB0aXRsZSAtIHRpdGxlIHRvIHNob3cgaW4gdG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7e2ljb246IHN0cmluZywgdGl0bGU6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGEsXG4gICAgICB0aXRsZTogXCJSYXcgSFRNTFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gUmF3RGF0YSDigJQgcGx1Z2luIHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgLSBwcmV2aW91c2x5IHNhdmVkIEhUTUwgY29kZVxuICAgKiBAcHJvcGVydHlcbiAgICovXG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge1Jhd0RhdGF9IGRhdGEg4oCUIHByZXZpb3VzbHkgc2F2ZWQgSFRNTCBkYXRhXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0ge29iamVjdH0gYXBpIC0gQ29kZVggRWRpdG9yIEFQSVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiB0LCBjb25maWc6IGUsIGFwaTogciwgcmVhZE9ubHk6IGkgfSkge1xuICAgIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IGksIHRoaXMucGxhY2Vob2xkZXIgPSByLmkxOG4udChlLnBsYWNlaG9sZGVyIHx8IHMuREVGQVVMVF9QTEFDRUhPTERFUiksIHRoaXMuQ1NTID0ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICBpbnB1dDogdGhpcy5hcGkuc3R5bGVzLmlucHV0LFxuICAgICAgd3JhcHBlcjogXCJjZS1yYXd0b29sXCIsXG4gICAgICB0ZXh0YXJlYTogXCJjZS1yYXd0b29sX190ZXh0YXJlYVwiXG4gICAgfSwgdGhpcy5kYXRhID0ge1xuICAgICAgaHRtbDogdC5odG1sIHx8IFwiXCJcbiAgICB9LCB0aGlzLnRleHRhcmVhID0gbnVsbCwgdGhpcy5yZXNpemVEZWJvdW5jZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9IHRoaXMuZWxlbWVudCAtIFJhd1Rvb2wncyB3cmFwcGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZSA9IDEwMDtcbiAgICByZXR1cm4gdGhpcy50ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSwgdC5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJhc2VDbGFzcywgdGhpcy5DU1Mud3JhcHBlciksIHRoaXMudGV4dGFyZWEuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy50ZXh0YXJlYSwgdGhpcy5DU1MuaW5wdXQpLCB0aGlzLnRleHRhcmVhLnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmh0bWwsIHRoaXMudGV4dGFyZWEucGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyLCB0aGlzLnJlYWRPbmx5ID8gdGhpcy50ZXh0YXJlYS5kaXNhYmxlZCA9ICEwIDogdGhpcy50ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vbklucHV0KCk7XG4gICAgfSksIHQuYXBwZW5kQ2hpbGQodGhpcy50ZXh0YXJlYSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LCBlKSwgdDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHJhd1Rvb2xzV3JhcHBlciAtIFJhd1Rvb2wncyB3cmFwcGVyLCBjb250YWluaW5nIHRleHRhcmVhIHdpdGggcmF3IEhUTUwgY29kZVxuICAgKiBAcmV0dXJucyB7UmF3RGF0YX0gLSByYXcgSFRNTCBjb2RlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUodCkge1xuICAgIHJldHVybiB7XG4gICAgICBodG1sOiB0LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKS52YWx1ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIFJhd1Rvb2wncyB0ZXh0YXJlYVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiRW50ZXIgSFRNTCBjb2RlXCI7XG4gIH1cbiAgLyoqXG4gICAqIEF1dG9tYXRpYyBzYW5pdGl6ZSBjb25maWdcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGh0bWw6ICEwXG4gICAgICAvLyBBbGxvdyBIVE1MIHRhZ3NcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBUZXh0YXJlYSBjaGFuZ2UgZXZlbnRcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBvbklucHV0KCkge1xuICAgIHRoaXMucmVzaXplRGVib3VuY2UgJiYgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplRGVib3VuY2UpLCB0aGlzLnJlc2l6ZURlYm91bmNlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sIDIwMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2l6ZSB0ZXh0YXJlYSB0byBmaXQgd2hvbGUgaGVpZ2h0XG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHRoaXMudGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGhpcy50ZXh0YXJlYS5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIHMgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@editorjs/raw/dist/raw.mjs\n");

/***/ })

};
;